spritenoshade LDEXPLOSION
action LAMEDUKE_EXPLOSION_FRAMES 0 20 1 1 2
action LAMEDUKE_EXPLOSION_FRAMES_SLOW 0 20 1 1 4
actor LDEXPLOSION 0
{
	ifactioncount 20
		killit
	
	ifaction 0
	{
		action LAMEDUKE_EXPLOSION_FRAMES
		setactor[THISACTOR].shade -127
		setactor[THISACTOR].blend 255
		setactor[THISACTOR].mdflags 16
		cstat 130
		
		ifrnd 128
			cstator 4
		
		getactor[THISACTOR].htpicnum TEMP
		switch TEMP
			case PLASMABALL:
				espawn FIRESHELL
				setactor[RETURN].pal 198
				setactorvar[RETURN].ANIMATE_LIFETIME 32 // End time
				setactorvar[RETURN].XREPEAT_MEMORY 0 // Start radius
				setactorvar[RETURN].YREPEAT_MEMORY 48 // End radius
				setactorvar[RETURN].SPAWN_ORIGANG 72 // Rotational Speed
				setvar RETURN 0
				
				setvar ANIMATE_FLAGS ANIMATE_FLAG_SCALE
				setvarvar ANIMATE_STARTCLOCK ANIMATE_CLOCK // Timer
				setvar ANIMATE_LIFETIME 96 // End time
				getactor[THISACTOR].xrepeat TEMP
				setvarvar XREPEAT_MEMORY TEMP // Start radius
				mulvar TEMP 3
				setvarvar YREPEAT_MEMORY TEMP // End radius
				
				// fallthrough
			case PLASMABALL2:
			case PLASMABALL3:
				spritepal 1
				break
		endswitch
	}
}
enda

spritenoshade SHOCKWAVE
actor SHOCKWAVE 0
{
	ifaction 0
	{
		cstat 10274
		setactor[THISACTOR].shade -127
		setactor[THISACTOR].blend 255
		setactor[THISACTOR].mdflags 16
		setvar ANIMATE_FLAGS ANIMATE_FLAG_ROTATE_SCALE_AND_FADE
		
		setvarvar ANIMATE_STARTCLOCK ANIMATE_CLOCK // Timer
		setvar ANIMATE_LIFETIME 24 // End time
		setvar SPAWN_ORIGANG 8 // Rotational Speed
		
		setvar XREPEAT_MEMORY 0 // Start radius
		setvar YREPEAT_MEMORY 128 // End radius
		
		ifspawnedby TANK
		{
			setvar YREPEAT_MEMORY 255
		}
		
		action ANULLACTION
	}
	
	ifcount 30
		killit
}
enda

spritenoshade FIRESHELL
spritenopal FIRESHELL
actor FIRESHELL 0
{
	ifcount 30
		killit
}
enda

spritenoshade RAILGUNTRAIL
action RAILGUN_TRAIL_FRAMES 0 16 5 1 2
actor RAILGUNTRAIL 1 RAILGUN_TRAIL_FRAMES
{
	ifactioncount 16
		killit
	
	ifcount 1
		nullop
	else ifcount 0
	{
		setactor[THISACTOR].shade -127
		//setactor[THISACTOR].xoffset -32
		cstat 130
	}
}
enda

action BLOODFRAMES 0 4 1 1 15
action BLOODFRAMES_FAST 0 4 1 1 8
actor BLOOD 0 BLOODFRAMES
{
	ifcount 1 { }
	else
	{
		ifinwater
		{
			ifrnd 30
			{
				espawn BLOODINFLUID2
				getactor[THISACTOR].pal TEMP2
				setactor[RETURN].pal TEMP2
				randvar TEMP2 8
				addvar TEMP2 8
				setactor[RETURN].xrepeat TEMP2
				setactor[RETURN].yrepeat TEMP2
				setvar RETURN 0
			}
			killit
		}
		
		ifspawnedby JIBS6
			action BLOODFRAMES_FAST
	}
	
	ifactioncount 4
		killit
}
enda

actor JUMPPAD 0
{
	getactor[THISACTOR].sectnum TEMP
	setvarvar TEMP2 SECTOR_TYPES[TEMP]
	orvar TEMP2 SECTORTYPE_JUMPPAD
	setarray SECTOR_TYPES[TEMP] TEMP2	
	
	getactor[THISACTOR].xvel TEMP2
	setarray SECTOR_JUMPX[TEMP] TEMP2
	
	getactor[THISACTOR].yvel TEMP2
	setarray SECTOR_JUMPY[TEMP] TEMP2
	
	getactor[THISACTOR].hitag TEMP2
	setarray SECTOR_JUMPZ[TEMP] TEMP2
	
	killit
}
enda

action FAUCET_ANIM 0 2 1 1 2
actor FAUCET 0 ANULLACTION
	ifhitspace
	ifcount 30
	ifpdistl RETRIEVEDISTANCE
	ifcansee
	ifp pfacing
	{
		resetcount
		resetactioncount
		sound FAUCET_ON
		sound FAUCET_RUN
		action FAUCET_ANIM
		cactor FAUCET_RUNNING 
	}
enda

actor FAUCET_RUNNING 0 FAUCET_ANIM
	ifactioncount 60
	{
		sound FAUCET_RUN
		resetactioncount
	}
	
	ifhitspace
	ifcount 30
	ifpdistl RETRIEVEDISTANCE
	ifcansee
	ifp pfacing
	{
		resetcount
		resetactioncount
		sound FAUCET_OFF
		stopsound FAUCET_RUN
		action ANULLACTION
		cactor FAUCET 
	}
enda

actor FAUCET_RUNNING2
	sound FAUCET_RUN
	action FAUCET_ANIM
	cactor FAUCET_RUNNING
enda

state trigger_actors
	headspritestat CURSPRITE STAT_ACTOR
	setvarvar LASTSPRITE CURSPRITE
	whilevarn CURSPRITE -1
	{
		getactorvar[CURSPRITE].LOTAG_MEMORY TEMP
		ifvarvare LOTAG_MEMORY TEMP // Check if lotag matches
		{
			setactorvar[CURSPRITE].PAL_MEMORY 1 // PAL_MEMORY = Activating state for timed platforms
		}
				
		nextspritestat CURSPRITE LASTSPRITE
		setvarvar LASTSPRITE CURSPRITE
	}
ends

actor CUSTOMACTIVATOR
	ifspawnedby RESPAWN
	{
		getactor[THISACTOR].htowner TEMP
		getactor[TEMP].lotag LOTAG_MEMORY
			
		/*
		redefinequote 400 CUSTOMACTIVATOR OWNER: %d | LOTAG: %d
		qsprintf 400 400 TEMP LOTAG_MEMORY
		userquote 400
		*/
			
		state trigger_actors
			
		espawn RESPAWN
		setactor[RETURN].lotag LOTAG_MEMORY
		setactor[RETURN].hitag 9998
		setvar RETURN 0
		
		killit
	}
	else
	{
		killit
	}
enda

actor CUSTOMTOUCHPLATE
	ifaction 0
	{
		cstat 32768
		action ANULLACTION
	}
	
	headspritestat CURSPRITE STAT_PLAYER
	whilevarn CURSPRITE -1
	{
		getactor[CURSPRITE].sectnum TEMP
		ifvarvare SECTNUM_MEMORY TEMP // Check if sector matches
		{
			state trigger_actors
			break
		}
				
		nextspritestat CURSPRITE CURSPRITE
	}
enda

// XREPEAT_MEMORY = Internal Timer
// LOTAG = Switch Channel
// SPAWN_ORIGANG = Original Z Position
// XVEL/SPAWN_ORIGX = Time To Pause
// Z/SPAWN_ORIGZ = Destination Z Position
// ZVEL/SPAWN_ORIGZVEL = Z Velocity
action TRIGGERED 0
action WAITING 0
action RETURNING 0
actor TIMEDPLATFORM
{
	ifaction ANULLACTION
	{
		ifvare PAL_MEMORY 1 // ACTIVATING
		{
			setvar XREPEAT_MEMORY 0
			setsector[THISACTOR].floorzvel SPAWN_ORIGZVEL
			setsector[THISACTOR].floorzgoal SPAWN_ORIGZ
			action TRIGGERED
		}
	}
	
	ifaction TRIGGERED
	{
		getsector[THISACTOR].floorzgoal TEMP
		ifvare TEMP -1
		{
			action WAITING
		}
	}
	
	ifaction WAITING
	{
		addvar XREPEAT_MEMORY 1
		ifvarvare XREPEAT_MEMORY SPAWN_ORIGX
		{
			setsector[THISACTOR].floorzvel SPAWN_ORIGZVEL
			setsector[THISACTOR].floorzgoal SPAWN_ORIGANG
			setvar XREPEAT_MEMORY 0
			action RETURNING
		}
	}
	
	ifaction RETURNING
	{
		getsector[THISACTOR].floorzgoal TEMP
		ifvare TEMP -1
		{
			setvar PAL_MEMORY 0 // No longer activating
			action ANULLACTION
		}
	}
	
	ifaction 0
	{
		cstat 32768
		getsector[THISACTOR].floorz SPAWN_ORIGANG
		getactor[THISACTOR].xvel SPAWN_ORIGX
		getactor[THISACTOR].z SPAWN_ORIGZ
		getactor[THISACTOR].zvel SPAWN_ORIGZVEL
		action ANULLACTION
	}
}
enda

// HITAG = Stop Sound
// LOTAG = Start Sound
state platform_sound
	ifaction ANULLACTION
	{
		getsector[THISACTOR].floorzgoal TEMP
		ifvarn TEMP -1
		{
			ifvarn LOTAG_MEMORY -32768 // -32768 = No Sound
				soundvar LOTAG_MEMORY
			
			ifvarn HITAG_MEMORY -32768 // -32768 = No Sound			
				stopsoundvar HITAG_MEMORY
				
			action TRIGGERED
		}
	}
	
	ifaction TRIGGERED
	{
		getsector[THISACTOR].floorzgoal TEMP
		ifvare TEMP -1
		{	
			ifvarn HITAG_MEMORY -32768 // 32768 = No Sound
				soundvar HITAG_MEMORY
				
			ifvarn LOTAG_MEMORY -32768 // -32768 = No Sound
				stopsoundvar LOTAG_MEMORY
				
			action ANULLACTION
		}
	}
ends

// HITAG = Close Sound
// LOTAG = Open Sound
state door_sound
	ifaction ANULLACTION
	{
		getsector[THISACTOR].ceilingzgoal TEMP
		ifvarn TEMP -1
		{
			getsector[THISACTOR].ceilingz TEMP2
			getsector[THISACTOR].floorz TEMP3		
			ifvarvare TEMP2 TEMP3 // Open
			{
				soundvar LOTAG_MEMORY
				stopsoundvar HITAG_MEMORY
			}
			else // Close
			{
				soundvar HITAG_MEMORY
				stopsoundvar LOTAG_MEMORY
			}
			
			action TRIGGERED
		}
	}
	
	ifaction TRIGGERED
	{
		getsector[THISACTOR].ceilingzgoal TEMP
		ifvare TEMP -1
		{
			action ANULLACTION
		}
	}
ends

// SECTNUM_MEMORY = Sector Lotag
actor CONTEXTSOUND 0
{
	switch SECTNUM_MEMORY
		case 20:
			state door_sound
			break
		default:
			state platform_sound
			break
	endswitch
	
	ifaction 0
	{
		cstat 32768
		action ANULLACTION
		getsector[THISACTOR].lotag SECTNUM_MEMORY
	}
}
enda

actor STARTWEAPONCHANGER
	setvarvar START_WEAPON LOTAG_MEMORY
	killit
enda

actor MOONGRAVITY
	getactor[THISACTOR].sectnum TEMP
	setvarvar TEMP2 SECTOR_TYPES[TEMP]
	orvar TEMP2 SECTORTYPE_LOWGRAVITY
	setarray SECTOR_TYPES[TEMP] TEMP2
	killit
enda

actor SPACESECTOR
	getactor[THISACTOR].sectnum TEMP
	setvarvar TEMP2 SECTOR_TYPES[TEMP]
	orvar TEMP2 SECTORTYPE_SPACE
	setarray SECTOR_TYPES[TEMP] TEMP2
	killit
enda

action TELEFOG1 0 2 1 1 12
action TELEFOG2 0 10 1 1 12
spriteflags DOOM_TELEFOG 16388
actor DOOM_TELEFOG 10
{
	ifaction TELEFOG1
	{
		ifactioncount 2
		action TELEFOG2
	}
	else ifaction TELEFOG2
	{
		ifactioncount 10
		{
			killit
		}
	}
	
	ifaction 0
	{
		setactor[THISACTOR].shade -127
		cstat 128
		sizeat 56 48
		sound DSTELEPT
		action TELEFOG1
	}
}
enda

// SFLAG_NOEVENTCODE + SFLAG_NOCLIP + SFLAG_SMOOTHMOVE + SFLAG_NOTELEPORT
spriteflags SNOWFLAKE 26752
actor SNOWFLAKE 0
	ifaction 0
	{
		getactor[THISACTOR].sectnum TEMP
		ifvare TEMP -1
		{
			killit
		}
		
		fall
		cstat 130
		sizeat 6 6
		action ANULLACTION
	}
	
	// s->xvel = (krand()&7)+(sintable[T1&2047]>>9);
	randvar TEMP 7
	getactor[THISACTOR].htg_t 0 TEMP2
	sin TEMP3 TEMP2
	shiftvarr TEMP3 9
	addvarvar TEMP TEMP3
	setvarvar SPAWN_ORIGX TEMP
		
	randvar TEMP 7
	setvarvar TEMP2 EXTRA_MEMORY
	sin TEMP3 TEMP2
	shiftvarr TEMP3 9
	addvarvar TEMP TEMP3
	setvarvar SPAWN_ORIGY TEMP
	
	movesprite THISACTOR SPAWN_ORIGX SPAWN_ORIGY 0 0 CLIPDIST_MEMORY
	
	getactor[THISACTOR].z TEMP
	addvar TEMP 512
	setactor[THISACTOR].z TEMP
	
	// T1 += (krand()&63);
	randvar TEMP 63
	getactor[THISACTOR].htg_t 0 TEMP2
	addvarvar TEMP2 TEMP
	setactor[THISACTOR].htg_t 0 TEMP2
	
	// EXTRA_MEMORY += (krand()&63);
	randvar TEMP 63
	addvarvar EXTRA_MEMORY TEMP
	
	iffloordistl 4
		killit
enda

state spawn_snow
	getactor[THISACTOR].x SPAWN_ORIGX
	randvar TEMP 20480
	subvar TEMP 10240
	addvarvar SPAWN_ORIGX TEMP
	
	getactor[THISACTOR].y SPAWN_ORIGY
	randvar TEMP 20480
	subvar TEMP 10240
	addvarvar SPAWN_ORIGY TEMP
	
	updatesector SPAWN_ORIGX SPAWN_ORIGY SECTNUM_MEMORY
	
	ifvarn SECTNUM_MEMORY -1
	{
		getsector[SECTNUM_MEMORY].ceilingstat TEMP
		ifvarand TEMP 1
		{
			espawn SNOWFLAKE
			changespritesect RETURN SECTNUM_MEMORY
			
			setactor[RETURN].x SPAWN_ORIGX
			setactor[RETURN].y SPAWN_ORIGY
			
			getsector[SECTNUM_MEMORY].ceilingz TEMP2
			setactor[RETURN].z TEMP2
			
			setvar RETURN 0
		}
	}
ends

actor SNOWFLAKESPAWNER
	ifaction 0
	{
		cstat 32768
		action ANULLACTION
	}
	
	state spawn_snow
	state spawn_snow
enda

state zteleporter_moveactor
	setvarvar TEMP CURSPRITE // Don't overwrite this until after teleporting!
	
	headspritestat CURSPRITE STAT_ACTOR
	setvarvar LASTSPRITE CURSPRITE
	whilevarn CURSPRITE -1
	{
		getactor[CURSPRITE].picnum TEMP2
		ifvare TEMP2 ZTDESTINATION
		{
			getactorvar[CURSPRITE].HITAG_MEMORY TEMP2
			ifvarvare HITAG_MEMORY TEMP2
			{
				getactor[CURSPRITE].x SPAWN_ORIGX
				getactor[CURSPRITE].y SPAWN_ORIGY
				getactor[CURSPRITE].z SPAWN_ORIGZ
				getactor[CURSPRITE].ang SPAWN_ORIGANG
				
				getactor[TEMP].picnum TEMP2
				ifvare TEMP2 APLAYER
				{
					getactor[TEMP].yvel TEMP
					setplayer[TEMP].posx SPAWN_ORIGX
					setplayer[TEMP].posy SPAWN_ORIGY
					setplayer[TEMP].posz SPAWN_ORIGZ
					setplayer[TEMP].ang SPAWN_ORIGANG
				}
				else
				{
					setactor[TEMP].x SPAWN_ORIGX
					setactor[TEMP].y SPAWN_ORIGY
					setactor[TEMP].z SPAWN_ORIGZ
					setactor[TEMP].ang SPAWN_ORIGANG
				}
				
				espawn TRANSPORTERBEAM
				getactor[THISACTOR].x TEMP
				getactor[THISACTOR].y TEMP2
				getactor[THISACTOR].z TEMP3
				setactor[RETURN].x TEMP
				setactor[RETURN].y TEMP2
				setactor[RETURN].z TEMP3
				sound TELEPORTER
				setvar RETURN 0
				
				espawn TRANSPORTERBEAM
				setactor[RETURN].x SPAWN_ORIGX
				setactor[RETURN].y SPAWN_ORIGY
				setactor[RETURN].z SPAWN_ORIGZ
				actorsound RETURN TELEPORTER
				setvar RETURN 0
				
				setvar CURSPRITE -1
				break
			}
		}
				
		nextspritestat CURSPRITE LASTSPRITE
		setvarvar LASTSPRITE CURSPRITE
	}
ends

state zteleporter_search
	setvarvar LASTSPRITE CURSPRITE
	whilevarn CURSPRITE -1
	{
		dist TEMP THISACTOR CURSPRITE
		
		ifvarvarl TEMP LOTAG_MEMORY
		{
			state zteleporter_moveactor
			setvar CURSPRITE -1
			break
		}
				
		nextspritestat CURSPRITE LASTSPRITE
		setvarvar LASTSPRITE CURSPRITE
	}
ends

actor ZTELEPORTER
	ifaction 0
	{
		cstat 32768
		action ANULLACTION
	}
	
	headspritestat CURSPRITE STAT_PLAYER
	state zteleporter_search
	
	headspritestat CURSPRITE STAT_PROJECTILE
	state zteleporter_search
enda

actor ZTDESTINATION
	ifaction 0
	{
		cstat 32768
		action ANULLACTION
	}
enda

action PIGJIB1_ANIM 0 6 1 1 16
action PIGJIB1_LAND 175 6 1 1 6
actor PIGJIB1 0
	ifaction 0
	{
		setactor[THISACTOR].mdflags 16
		setvar ANIMATE_FLAGS ANIMATE_FLAG_BLOODBRIGHT
		setvar ISADULT ADULT_LOCKOUTONLY
		cstat 128
		action PIGJIB1_ANIM
	}
	
	ifaction PIGJIB1_LAND
	{
		fall
		ifactioncount 6
		{
			killit
		}
	}
	else
	{
		state gore_movement
		
		espawn BLOOD
		getactor[THISACTOR].pal TEMP2
		setactor[RETURN].pal TEMP2
		setvar RETURN 0
		
		iffloordistl 4
		{
			state gibsound
			
			espawn PIGJIB1_ONGROUND
			setactor[RETURN].pal TEMP2
			setvar RETURN 0
			
			resetactioncount
			cstat 0
			action PIGJIB1_LAND
		}
	}
enda

state onground_gib_code
	fall
	ifcount 300
	{
		//cstator 2
		getactor[THISACTOR].alpha TEMP
		addvar TEMP 4
		setactor[THISACTOR].alpha TEMP
		
		ifvarg TEMP 254
			killit
	}
	else ifcount 1 { }
	else ifcount 0
	{
		sizeat 32 32
		getactor[THISACTOR].pal TEMP3
			
		ifrnd 128 { eqspawn WALLBLOOD2 }
		ifrnd 64 { eqspawn 1622 }
		else { eqspawn WALLBLOOD5 }
			
		setactor[RETURN].pal TEMP3
		
		randvar TEMP3 2048
		setactor[RETURN].ang TEMP3
		
		randvar TEMP3 16
		addvar TEMP3 32
		setactor[RETURN].xrepeat TEMP3
		
		randvar TEMP3 16
		addvar TEMP3 32
		setactor[RETURN].yrepeat TEMP3
		
		ifrnd 128 { setactor[RETURN].cstat 32 }
		else { setactor[RETURN].cstat 36 }
			
		setvar RETURN 0
	}
ends

actor PIGJIB1_ONGROUND
{
	ifspawnedby PIGJIB1_ONGROUND { }
	else
	{
		state onground_gib_code
	}
}
enda

actor DUKETORSO_ONGROUND
{
	ifspawnedby DUKETORSO_ONGROUND { }
	else
	{
		state onground_gib_code
	}
}
enda

actor DUKEGUN_ONGROUND
{
	ifspawnedby DUKEGUN_ONGROUND { }
	else
	{
		state onground_gib_code
	}
}
enda

actor DUKELEG_ONGROUND
{
	ifspawnedby DUKELEG_ONGROUND { }
	else
	{
		state onground_gib_code
	}
}
enda

actor JIBS1_ONGROUND
{
	ifspawnedby JIBS1_ONGROUND { }
	else
	{
		state onground_gib_code
	}
}
enda

actor JIBS2_ONGROUND
{
	ifspawnedby JIBS2_ONGROUND { }
	else
	{
		state onground_gib_code
	}
}
enda

actor JIBS3_ONGROUND
{
	ifspawnedby JIBS3_ONGROUND { }
	else
	{
		state onground_gib_code
	}
}
enda

actor JIBS4_ONGROUND
{
	ifspawnedby JIBS4_ONGROUND { }
	else
	{
		state onground_gib_code
	}
}
enda

actor JIBS5_ONGROUND
{
	ifspawnedby JIBS5_ONGROUND { }
	else
	{
		state onground_gib_code
	}
}
enda

actor HEADJIB1_ONGROUND
{
	ifspawnedby HEADJIB1_ONGROUND { }
	else
	{
		state onground_gib_code
	}
}
enda

actor ARMJIB1_ONGROUND
{
	ifspawnedby ARMJIB1_ONGROUND { }
	else
	{
		state onground_gib_code
	}
}
enda

actor LEGJIB1_ONGROUND
{
	ifspawnedby LEGJIB1_ONGROUND { }
	else
	{
		state onground_gib_code
	}
}
enda

actor RANDYSSHITTYCOMMENTARY 0
	killit
enda

spriteflags BLOODSPURT 8192
action BLOODSPURT_ANIM 0 4 1 1 4
action BLOODSPURT_LAND 188 6 1 1 6
actor BLOODSPURT 0
	ifaction 0
	{
		setactor[THISACTOR].mdflags 16
		setvar ANIMATE_FLAGS ANIMATE_FLAG_BLOODBRIGHT
		setvar ISADULT ADULT_LOCKOUTONLY
		sizeat 12 12
		cstat 128
		action BLOODSPURT_ANIM
	}
	
	ifaction BLOODSPURT_LAND
	{
		fall
		ifactioncount 6
		{
			killit
		}
	}
	else
	{
		state gore_movement
		iffloordistl 4
		{
			ifrnd 64
			{
				randvar RANDOM_SOUND 3
				switch RANDOM_SOUND
					case 0: sound BLOOD_SPLAT1 break
					case 1: sound BLOOD_SPLAT2 break
					case 2: sound BLOOD_SPLAT3 break
					case 3: sound BLOOD_SPLAT4 break
				endswitch
			}
				
			resetactioncount
			cstat 0
			action BLOODSPURT_LAND
		}
	}
	
	espawn SPURTTRAIL
	getactor[THISACTOR].pal TEMP
	setactor[RETURN].pal TEMP
	getactor[THISACTOR].htbposx TEMP
	setactor[RETURN].htbposx TEMP
	getactor[THISACTOR].htbposy TEMP
	setactor[RETURN].htbposy TEMP
	getactor[THISACTOR].htbposz TEMP
	setactor[RETURN].htbposz TEMP
	setvar RETURN 0
enda

action SPURTTRAIL_ANIM 0 5 1 1 8
actor SPURTTRAIL 0
	fall
	
	ifaction 0
	{
		sizeat 24 24
		cstat 128
		
		ifrnd 128
			cstator 4
		ifrnd 128
			cstator 8
		
		setactor[THISACTOR].mdflags 16
		setvar ANIMATE_FLAGS ANIMATE_FLAG_BLOODBRIGHT
		orvar ANIMATE_FLAGS ANIMATE_FLAG_FADEOUT
		setvar ISADULT ADULT_LOCKOUTONLY

		setvarvar ANIMATE_STARTCLOCK ANIMATE_CLOCK // Timer
		setvar ANIMATE_LIFETIME 60 // End time
		
		action SPURTTRAIL_ANIM
	}
	
	ifactioncount 5
	{
		killit
	}
	
	iffloordistl 4
	{
		killit
	}
enda

action EXPLOSIONSPARK_ANIM 0 6 1 1 12
spriteflags EXPLOSIONSPARK 16388 //SFLAG_NOSHADE + SFLAG_NOTELEPORT
actor EXPLOSIONSPARK 1	
	ifaction 0
	{
		setactor[THISACTOR].shade -127
		setactor[THISACTOR].blend 255
		
		ifspawnedby TANK
		{
			sizeat 32 32
		}
		else
		{
			sizeat 20 20
		}
		
		cstat 130
		
		ifrnd 128
		{
			cstator 4
		}
		ifrnd 128
		{
			cstator 8
		}
		
		action EXPLOSIONSPARK_ANIM
	}
	
	state gore_movement
	
	ifactioncount 6
		killit
enda

spriteflags TRACER 8196
actor TRACER 0
	ifaction 0
	{
		setactor[THISACTOR].shade -127
		setactor[THISACTOR].blend 255
		sizeat 10 10
		cstat 32768
		action ANULLACTION
	}
	else
	{
		ifcount 2 { }
		else ifcount 1
		{
			cstat 2178
		}
	}
	
	state tracer_movement
enda

spriteflags PELLET 8192
actor PELLET 0
	ifaction 0
	{
		sizeat 10 10
		cstat 32768
		action ANULLACTION
	}
	else
	{
		ifcount 2 { }
		else ifcount 1
		{
			cstat 128
		}
	}
	
	state tracer_movement
enda

action WATERDRIPSPLASH_ANIM 1 9 1 1 2
actor WATERDRIPSPLASH_FIXED 0
{
	ifaction 0
	{
		ifrnd 128
			cstator 4
			
		sizeat 24 24
		action WATERDRIPSPLASH_ANIM
	}
	else ifactioncount 9
		killit
		
	fall
}
enda

action BLOODINFLUID1_ANIM 0 16 1 1 8
actor BLOODINFLUID1 0
{
	ifaction 0
	{
		cstat 130
		
		ifrnd 128
			cstator 4
		ifrnd 128
			cstator 8
		
		setactor[THISACTOR].mdflags 16
		orvar ANIMATE_FLAGS ANIMATE_FLAG_SCALE
		orvar ANIMATE_FLAGS ANIMATE_FLAG_FADEOUT
		orvar ANIMATE_FLAGS ANIMATE_FLAG_BLOODBRIGHT
		
		setvarvar ANIMATE_STARTCLOCK ANIMATE_CLOCK // Timer
		setvar ANIMATE_LIFETIME 256 // End time
		setvar SPAWN_ORIGANG 0 // Rotational Speed
		
		getactor[THISACTOR].xrepeat TEMP
		setvarvar XREPEAT_MEMORY TEMP // Start radius
		mulvar TEMP 3
		setvarvar YREPEAT_MEMORY TEMP // End radius
		
		action BLOODINFLUID1_ANIM
	}
	
	ifactioncount 16
		killit
}
enda

action BLOODINFLUID2_ANIM 0 16 1 1 8
actor BLOODINFLUID2 0
{
	ifaction 0
	{
		cstat 130
		
		ifrnd 128
			cstator 4
		
		setactor[THISACTOR].mdflags 16
		orvar ANIMATE_FLAGS ANIMATE_FLAG_SCALE
		orvar ANIMATE_FLAGS ANIMATE_FLAG_FADEOUT
		orvar ANIMATE_FLAGS ANIMATE_FLAG_BLOODBRIGHT
		
		setvarvar ANIMATE_STARTCLOCK ANIMATE_CLOCK // Timer
		setvar ANIMATE_LIFETIME 256 // End time
		setvar SPAWN_ORIGANG 0 // Rotational Speed
		
		getactor[THISACTOR].xrepeat TEMP
		setvarvar XREPEAT_MEMORY TEMP // Start radius
		mulvar TEMP 4
		setvarvar YREPEAT_MEMORY TEMP // End radius
		
		action BLOODINFLUID2_ANIM
	}
	
	ifactioncount 16
		killit
}
enda

action RICOCHET_SPARK_ANIM1 0 1 1 1 2
action RICOCHET_SPARK_ANIM2 1 1 1 1 2
action RICOCHET_SPARK_ANIM3 2 1 1 1 2
action RICOCHET_SPARK_ANIM4 3 1 1 1 2
action RICOCHET_SPARK_ANIM5 4 1 1 1 2
spritenoshade RICOCHET_SPARK
actor RICOCHET_SPARK 0
{
	ifaction 0
	{
		sound PISTOL_RICOCHET
		
		setactor[THISACTOR].shade -127
		
		randvar TEMP3 14
		addvar TEMP3 10
		setactor[THISACTOR].xrepeat TEMP3
		setactor[THISACTOR].yrepeat TEMP3
		
		randvar TEMP3 4
		switch TEMP3
			case 0: action RICOCHET_SPARK_ANIM1 break
			case 1: action RICOCHET_SPARK_ANIM2 break
			case 2: action RICOCHET_SPARK_ANIM3 break
			case 3: action RICOCHET_SPARK_ANIM4 break
			case 4: action RICOCHET_SPARK_ANIM5 break
		endswitch
	}
	else
	{
		ifactioncount 1
			cstat 32768
			
		ifcount 8
			killit
	}
}
enda

//actor JIBS6 0 enda

state random_creepy_sound
	randvar TEMP 18
	switch TEMP
		case 0: sound CREEPYAMB_01 break
		case 1: sound CREEPYAMB_02 break
		case 2: sound CREEPYAMB_03 break
		case 3: sound CREEPYAMB_04 break
		case 4: sound CREEPYAMB_05 break
		case 5: sound CREEPYAMB_06 break
		case 6: sound CREEPYAMB_07 break
		case 7: sound CREEPYAMB_08 break
		case 8: sound CREEPYAMB_09 break
		case 9: sound CREEPYAMB_10 break
		case 10: sound CREEPYAMB_11 break
		case 11: sound CREEPYAMB_12 break
		case 12: sound CREEPYAMB_13 break
		case 13: sound CREEPYAMB_14 break
		case 14: sound CREEPYAMB_15 break
		case 15: sound CREEPYAMB_16 break
		case 16: sound CREEPYAMB_17 break
		case 17: sound CREEPYAMB_18 break
		case 18: sound CREEPYAMB_19 break
	endswitch
ends

action TROLLGE_ANIM1 0 1 1 1 4
action TROLLGE_ANIM2 1 1 1 1 4
action TROLLGE_ANIM3 2 1 1 1 4
action TROLLGE_ANIM4 3 1 1 1 4
action TROLLGE_ANIM5 4 1 1 1 4
action TROLLGE_ANIM6 5 1 1 1 4
action TROLLGE_ANIM7 6 1 1 1 4
action TROLLGE_WAIT 0 1 1 1 40

spritenoshade TROLLGE
actor TROLLGE 0
	sleeptime 0
	ifaction 0
	{
		sizeat 64 64
		cstat 32768
		setactor[THISACTOR].shade -8
		setvar EXTRA_MEMORY 900
		state random_creepy_sound
		action TROLLGE_WAIT
	}
	else ifaction TROLLGE_WAIT
	{
		subvar EXTRA_MEMORY 1
		ifvarl EXTRA_MEMORY 1
		{
			setvarvar TEMP2 MULTIMODE
			subvar TEMP2 1
			randvarvar TEMP TEMP2
			getplayer[TEMP].posx SPAWN_ORIGX
			getplayer[TEMP].posy SPAWN_ORIGY
			getplayer[TEMP].posz SPAWN_ORIGZ
			getplayer[TEMP].cursectnum SECTNUM_MEMORY
			changespritesect THISACTOR SECTNUM_MEMORY
			
			randvar TEMP 8192
			subvar TEMP 4096
			addvarvar SPAWN_ORIGX TEMP
			
			randvar TEMP 8192
			subvar TEMP 4096
			addvarvar SPAWN_ORIGY TEMP
			
			randvar TEMP 2048
			subvar TEMP 1024
			addvarvar SPAWN_ORIGZ TEMP
			
			setsprite THISACTOR SPAWN_ORIGX SPAWN_ORIGY SPAWN_ORIGZ
			
			randvar TEMP 6
			switch TEMP
				case 0: action TROLLGE_ANIM1 break
				case 1: action TROLLGE_ANIM2 break
				case 2: action TROLLGE_ANIM3 break
				case 3: action TROLLGE_ANIM4 break
				case 4: action TROLLGE_ANIM5 break
				case 5: action TROLLGE_ANIM6 break
				case 6: action TROLLGE_ANIM7 break
			endswitch
			
			resetactioncount
			cstat 2
			
			randvar EXTRA_MEMORY 750
			addvar EXTRA_MEMORY 1800
			state random_creepy_sound
		}
	}
	else
	{
		ifactioncount 3
		{
			cstat 32768
			action TROLLGE_WAIT
		}
		else ifactioncount 2
		{
			cstator 512
		}
	}
	
enda

action SUS_ANIM1 0 1 1 1 4
action SUS_ANIM2 -1 1 1 1 4
action SUS_ANIM3 -2 1 1 1 4
action SUS_ANIM4 -3 1 1 1 4
action SUS_ANIM5 -4 1 1 1 4
action SUS_ANIM6 -5 1 1 1 4
action SUS_ANIM7 -6 1 1 1 4
action SUS_WAIT 0 1 1 1 40
spritenoshade SUS
actor SUS 0
	ifaction 0
	{
		cstator 32768
		randvar EXTRA_MEMORY 300
		addvar EXTRA_MEMORY 100
		action SUS_WAIT
	}
	else ifaction SUS_WAIT
	{
		ifpdistl 3072
		{
			ifp pfacing
			ifcansee
			{
				subvar EXTRA_MEMORY 1
				
				// Nightvision makes them angry...
				getplayer[THISACTOR].heat_on TEMP
				ifvare TEMP 1
					subvar EXTRA_MEMORY 1
			}
		}
		
		ifvarl EXTRA_MEMORY 1
		{
			randvar EXTRA_MEMORY 600
			addvar EXTRA_MEMORY 200
			setactor[THISACTOR].alpha 0
			getactor[THISACTOR].cstat TEMP
			ifvarand TEMP 32768
			{
				xorvar TEMP 32768
				setactor[THISACTOR].cstat TEMP
			}
			
			
			randvar TEMP 6
			switch TEMP
				case 0:
					action SUS_ANIM1
					break
				case 1:
					action SUS_ANIM2
					break
				case 2:
					action SUS_ANIM3
					break
				case 3:
					action SUS_ANIM4
					break
				case 4:
					action SUS_ANIM5
					break
				case 5:
					action SUS_ANIM6
					break
				case 6:
					action SUS_ANIM7
					break
			endswitch
			
			getactor[THISACTOR].picnum TEMP2
			subvarvar TEMP2 TEMP
			
			randvar TEMP 5
			addvar TEMP 12
			setplayervar[THISACTOR].SCARETIME TEMP
			setplayervar[THISACTOR].SCAREPIC TEMP2
			getactor[THISACTOR].pal TEMP3
			setplayervar[THISACTOR].SCAREPAL TEMP3
			
			setvarvar STATE_PARAM1 THISACTOR
			state random_stinger
			
			getplayer[THISACTOR].heat_on TEMP
			ifvare TEMP 1
				addphealth -25
				
			addphealth -25
			palfrom 16 63 63 63
		}
	}
	else
	{
		ifactioncount 5
		{
			cstator 32768
			action SUS_WAIT
		}
		else ifactioncount 4
		{
			setactor[THISACTOR].alpha 128
		}
		else ifactioncount 3
		{
			setactor[THISACTOR].alpha 64
		}
		else ifactioncount 2
		{
			setactor[THISACTOR].alpha 8
		}
	}
enda

move SHADOWP_MOVE 80 0
spriteflags SHADOWPLAYER 2
action SHADOWP_STAND 1 1 5 1 1
action SHADOWP_WALK 21 4 5 1 16
actor SHADOWPLAYER 0
	fall
	ifaction 0
	{
		setactor[THISACTOR].cstat 514
		setactor[THISACTOR].mdflags 16
		resetcount
		
		ifrnd 32
		{
			action SHADOWP_WALK
			move SHADOWP_MOVE geth
		}
		else
			action SHADOWP_STAND
	}
	
	ifcount 90
	ifrnd 1
	{
		killit
	}
enda

actor IMSUFFERING 0
	ifaction 0
	{
		setvarvar APPARITION_LAIRSPRITEID THISACTOR
		cstat 32768
		action ANULLACTION
		userquote 199
	}
enda

defstate syntax_look_for_player
	setvar STATE_RETURN 0
	setvar STATE_TEMP1 0
	
	headspritestat CURSPRITE STAT_PLAYER
	whilevarn CURSPRITE -1
	{
		getactor[CURSPRITE].extra STATE_TEMP2
		
		ifvarg STATE_TEMP2 0
		{
			canseespr THISACTOR CURSPRITE STATE_TEMP1
			
			ifvarn STATE_TEMP1 1
			{
				getactor[THISACTOR].z TEMP3
				subvar TEMP3 4096
				setactor[THISACTOR].z TEMP3
				
				getactor[CURSPRITE].z TEMP3
				subvar TEMP3 4096
				setactor[CURSPRITE].z TEMP3
				
				canseespr THISACTOR CURSPRITE STATE_TEMP1
				
				getactor[THISACTOR].z TEMP3
				addvar TEMP3 4096
				setactor[THISACTOR].z TEMP3
				
				getactor[CURSPRITE].z TEMP3
				addvar TEMP3 4096
				setactor[CURSPRITE].z TEMP3
			}
		}
		
		nextspritestat CURSPRITE CURSPRITE
		
		ifvare STATE_TEMP1 1
		{
			setvar STATE_RETURN 1
			setvar CURSPRITE -1
			break
		}
	}
ends

spritenoshade SYNTAXEYE
action EYE_ACTIVATE1 2 5 1 1 1
action EYE_ACTIVATE2 4 1 1 1 1
action EYE_ACTIVATE3 7 1 1 1 1
action EYE_ACTIVATE4 2 5 1 1 1
action EYE_ACTIVATE5 4 1 1 1 1
action EYE_ACTIVATE6 7 3 1 1 1
action EYE_IDLE_ON 0 1 1 1 1
action EYE_IDLE_OFF 0 1 1 1 1
action EYE_OFF 9 8 1 -1 1
actor SYNTAXEYE 0
	sleeptime 0
	ifaction 0
	{
		cstator 32768
		setactor[THISACTOR].shade -127
		action EYE_IDLE_OFF
	}
	
	ifaction EYE_IDLE_OFF
	{
		state syntax_look_for_player
		
		ifvare STATE_RETURN 1
		{
			getactor[THISACTOR].cstat TEMP
			ifvarand TEMP 32768
				xorvar TEMP 32768
			setactor[THISACTOR].cstat TEMP
			
			sound FP_SYNTAX
			action EYE_ACTIVATE1
		}
	}
	
	ifaction EYE_IDLE_ON
	{
		state syntax_look_for_player
		ifvare STATE_RETURN 1
		{
			setvar EXTRA_MEMORY 0
		}
		else
		{
			addvar EXTRA_MEMORY 1
			ifvarg EXTRA_MEMORY 180
			{
				setvar EXTRA_MEMORY 0
				action EYE_OFF
			}
		}
	}
	
	ifaction EYE_OFF
	ifactioncount 8
	{
		cstator 32768
		action EYE_IDLE_OFF
	}
	
	ifaction EYE_ACTIVATE1
	ifactioncount 5
		action EYE_ACTIVATE2
		
	ifaction EYE_ACTIVATE2
	ifactioncount 1
		action EYE_ACTIVATE3
		
	ifaction EYE_ACTIVATE3
	ifactioncount 1
		action EYE_ACTIVATE4
		
	ifaction EYE_ACTIVATE4
	ifactioncount 5
		action EYE_ACTIVATE5
		
	ifaction EYE_ACTIVATE5
	ifactioncount 1
		action EYE_ACTIVATE6
		
	ifaction EYE_ACTIVATE6
	ifactioncount 3
		action EYE_IDLE_ON
enda

actor ARCTRAP 0
	ifaction 0
	{
		ifvare LOTAG_MEMORY 0 // LOTAG_MEMORY is a timer.
			setvar LOTAG_MEMORY 150
			
		setvarvar EXTRA_MEMORY HITAG_MEMORY // HITAG_MEMORY is an initial timer offset.
		
		//redefinequote 500 Arc HITAG_MEMORY: %d
		//qsprintf 500 500 HITAG_MEMORY
		//userquote 500
		
		action ANULLACTION
	}
	
	sleeptime 0
	addvar EXTRA_MEMORY 1
	ifvarvarg EXTRA_MEMORY LOTAG_MEMORY
	{
		sound FP_ELECTRICARC
		espawn ARCTRAPZAP
		getactor[THISACTOR].cstat TEMP
		setactor[RETURN].cstat TEMP
		getactor[THISACTOR].xrepeat TEMP
		setactor[RETURN].xrepeat TEMP
		getactor[THISACTOR].yrepeat TEMP
		setactor[RETURN].yrepeat TEMP
		getactor[THISACTOR].ang TEMP
		setactor[RETURN].ang TEMP
		setvar RETURN 0
		
		setvar EXTRA_MEMORY 0
	}
enda

defstate weird_hitscan_bullshit
	getactor[THISACTOR].x SPAWN_ORIGX
	getactor[THISACTOR].y SPAWN_ORIGY
	getactor[THISACTOR].z SPAWN_ORIGZ
	getactor[THISACTOR].sectnum SECTNUM_MEMORY
	getactor[THISACTOR].ang SPAWN_ORIGANG
	
	setvar PICNUM_MEMORY -1
	addvar SPAWN_ORIGANG 512
	
	cos TEMP SPAWN_ORIGANG
	sin TEMP2 SPAWN_ORIGANG
	hitscan SPAWN_ORIGX SPAWN_ORIGY SPAWN_ORIGZ SECTNUM_MEMORY TEMP TEMP2 0 TEMP3 TEMP4 PICNUM_MEMORY DEST_X DEST_Y DEST_Z CLIPMASK1
	
	ifvare PICNUM_MEMORY -1
	{
		addvar SPAWN_ORIGANG -1024
		cos TEMP SPAWN_ORIGANG
		sin TEMP2 SPAWN_ORIGANG
		hitscan SPAWN_ORIGX SPAWN_ORIGY SPAWN_ORIGZ SECTNUM_MEMORY TEMP TEMP2 0 TEMP3 TEMP4 PICNUM_MEMORY DEST_X DEST_Y DEST_Z CLIPMASK1
	}
	
	ifvarg PICNUM_MEMORY -1
	{
		getactor[THISACTOR].xrepeat TEMP
		mulvar TEMP 12
		ldist TEMP2 THISACTOR PICNUM_MEMORY
		ifvarvarl TEMP2 TEMP
		{
			setvar STATE_PARAM1 25
			setvarvar STATE_PARAM2 PICNUM_MEMORY
			setvar STATE_PARAM3 PLASMABALL
			setvar STATE_PARAM4 0
			state apply_damage
		}
	}
ends

action ARC_ANIM1 0 6 1 1 1
actor ARCTRAPZAP 0
	ifaction 0
	{
		cstator 2
		setactor[THISACTOR].blend 255
		action ARC_ANIM1
	}
	
	ifcount 30
	{
		getactor[THISACTOR].yrepeat TEMP
		subvar TEMP 8
		setactor[THISACTOR].yrepeat TEMP
		ifvarl TEMP 1
			killit
	}
	else
	{
		state weird_hitscan_bullshit
	}
enda

// STATE_PARAM1 = Angle Offset
// STATE_PARAM2 = Axis (0 = xrepeat, 1 = yrepeat)
defstate magma_spew
	espawn MAGMASPEW
	setactor[RETURN].cstat 144
			
	// Spew scale should be xrepeat - xrepeat>>2
	ifvare STATE_PARAM2 0
	{
		getactor[THISACTOR].xrepeat TEMP
		getactor[THISACTOR].xrepeat TEMP2
	}
	else
	{
		getactor[THISACTOR].yrepeat TEMP
		getactor[THISACTOR].yrepeat TEMP2
	}
	
	shiftvarr TEMP2 2
	subvarvar TEMP TEMP2
	setactor[RETURN].xrepeat TEMP
	setactor[RETURN].yrepeat 52

	// Spew offset should be x/yrepeat * 6
	ifvare STATE_PARAM2 0
		getactor[THISACTOR].yrepeat TEMP
	else
		getactor[THISACTOR].xrepeat TEMP
	mulvar TEMP 6
	
	// x = offset * cos(ang) >> 14
	getactor[THISACTOR].ang TEMP3
	addvarvar TEMP3 STATE_PARAM1
	cos TEMP3 TEMP3
	mulvarvar TEMP TEMP3
	shiftvarr TEMP 14
	getactor[RETURN].x TEMP4
	addvarvar TEMP4 TEMP
	setactor[RETURN].x TEMP4
	setactor[RETURN].htbposx TEMP4
	
	// Spew offset should be yrepeat * 6
	ifvare STATE_PARAM2 0
		getactor[THISACTOR].yrepeat TEMP
	else
		getactor[THISACTOR].xrepeat TEMP
	mulvar TEMP 6
	
	// y = offset * sin(ang) >> 14
	getactor[THISACTOR].ang TEMP3
	addvarvar TEMP3 STATE_PARAM1
	sin TEMP3 TEMP3
	mulvarvar TEMP TEMP3
	shiftvarr TEMP 14
	getactor[RETURN].y TEMP4
	addvarvar TEMP4 TEMP
	setactor[RETURN].y TEMP4
	setactor[RETURN].htbposy TEMP4
	
	getactor[THISACTOR].ang TEMP
	addvarvar TEMP STATE_PARAM1
	setactor[RETURN].ang TEMP
	
	getactor[THISACTOR].z TEMP
	subvar TEMP 9216
	setactor[RETURN].z TEMP
	setactor[RETURN].htbposz TEMP
	
	setvar RETURN 0
ends

action VALVE_OPEN 0 7 1 1 1
action VALVE_CLOSE 7 7 1 -1 1
action VALVE_SPEW 7 1 1 1 1
actor MAGMAVALVE 0
	sleeptime 0
	ifaction 0
	{
		cstator 257 // Make sure it is solid.
		
		ifvare LOTAG_MEMORY 0 // LOTAG_MEMORY is a timer.
			setvar LOTAG_MEMORY 150
			
		setvarvar EXTRA_MEMORY HITAG_MEMORY // HITAG_MEMORY is an initial timer offset.
		
		action ANULLACTION
	}
	
	ifaction VALVE_OPEN
	{
		ifactioncount 7
		{
			action VALVE_SPEW
			resetcount
		}
	}
	else ifaction VALVE_SPEW
	{
		getactor[THISACTOR].htg_t 0 TEMP
		modvar TEMP 3
		ifvare TEMP 0
		{
			/* // Only use this on one axis...
			getactor[THISACTOR].yrepeat TEMP
			shiftvarr TEMP 2
			getactor[THISACTOR].xrepeat TEMP3
			subvarvar TEMP3 TEMP
			*/
			sound FP_MAGMASPEW

			setvar STATE_PARAM1 0
			setvar STATE_PARAM2 0
			state magma_spew
			setvar STATE_PARAM2 0
			setvar STATE_PARAM1 1024
			state magma_spew
			
			setvar STATE_PARAM2 1
			setvar STATE_PARAM1 512
			state magma_spew
			
			setvar STATE_PARAM2 1
			setvar STATE_PARAM1 1536
			state magma_spew
			
			espawn MAGMASPEWCAP
			getactor[THISACTOR].ang TEMP
			setactor[RETURN].ang TEMP
			setactor[RETURN].cstat 33
			
			// Spew scale should be xrepeat - xrepeat>>2
			getactor[THISACTOR].xrepeat TEMP
			getactor[THISACTOR].xrepeat TEMP2
			shiftvarr TEMP2 2
			subvarvar TEMP TEMP2
			setactor[RETURN].xrepeat TEMP
			
			getactor[THISACTOR].yrepeat TEMP
			getactor[THISACTOR].yrepeat TEMP2
			shiftvarr TEMP2 2
			subvarvar TEMP TEMP2
			setactor[RETURN].yrepeat TEMP

			setvar RETURN 0
		}
		
		setvar STATE_PARAM1 2 // Intensity
		setvar STATE_PARAM2 6144 // Radius
		state start_shake
		
		ifcount 90
		{
			action VALVE_CLOSE
		}
	}
	else ifaction VALVE_CLOSE
	{
		ifactioncount 7
			action ANULLACTION
	}
	else ifaction ANULLACTION
	{
		addvar EXTRA_MEMORY 1
		ifvarvarg EXTRA_MEMORY LOTAG_MEMORY
		{
			action VALVE_OPEN
			setvar EXTRA_MEMORY 0
		}
	}
enda

action MAGMAKILL 0 1 1 1 1
move magmafall 0 1024
defstate magma_spew_shared
	// ASS
	sleeptime 0
	ifmove 0
	{
		move magmafall getv noclip
		setactor[THISACTOR].shade -127
	}
	
	getactor[THISACTOR].x TEMP
	getactor[THISACTOR].y TEMP2
	getactor[THISACTOR].z TEMP3
	getactor[THISACTOR].sectnum TEMP4
	getflorzofslope TEMP4 TEMP TEMP2 DEST_Z
	
	ifaction MAGMAKILL
	{
		subvar TEMP3 9216
		ifvarvarg TEMP3 DEST_Z
			killit
	}
	else
	{
		addvar TEMP3 12288
		ifvarvarg TEMP3 DEST_Z
		{
			ifactor MAGMASPEW
			{
				espawn MAGMASPLASH
				getactor[THISACTOR].xrepeat TEMP
				shiftvarr TEMP 1
				setactor[RETURN].xrepeat TEMP
				setactor[RETURN].yrepeat 64
				setactor[RETURN].cstat 48
				setactor[RETURN].yoffset 16
				setactor[RETURN].shade -127
				setactor[RETURN].z DEST_Z
				setactor[RETURN].htbposz DEST_Z
				setvar RETURN 0
				
				espawn MAGMASPLASH
				getactor[THISACTOR].xrepeat TEMP
				shiftvarr TEMP 1
				setactor[RETURN].xrepeat TEMP
				setactor[RETURN].yrepeat 64
				setactor[RETURN].cstat 32
				setactor[RETURN].shade -127
				setactor[RETURN].z DEST_Z
				setactor[RETURN].htbposz DEST_Z
				setvar RETURN 0
			}
			
			action MAGMAKILL
			move magmafall getv noclip
		}
	}
ends

spriteflags MAGMASPEW 1048580 // SFLAG_NOSHADE(4) + SFLAG_NODAMAGEPUSH(1048576)
actor MAGMASPEW 0
	state magma_spew_shared
enda

spriteflags MAGMASPEW 1048580 // SFLAG_NOSHADE(4) + SFLAG_NODAMAGEPUSH(1048576)
actor MAGMASPEWCAP 0
	state magma_spew_shared
enda

spritenoshade MAGMASPLASH
actor MAGMASPLASH 0
	ifaction 0
	{
		action ANULLACTION
	}
	
	ifcount 6 { killit }
	else ifcount 4 { }
	else ifcount 3
	{
		setactor[THISACTOR].mdflags 16
		orvar ANIMATE_FLAGS ANIMATE_FLAG_FADEOUT
		setvarvar ANIMATE_STARTCLOCK ANIMATE_CLOCK // Timer
		setvar ANIMATE_LIFETIME 12 // End time
	}
enda

action ALARM_START 0 5 1 1 1
action ALARM_LOOP 0 5 1 1 1
actor ALARMSIGN 0
	sleeptime 0
	
	ifaction 0
	{
		cstator 257 // Make sure it is solid.
		
		ifvare LOTAG_MEMORY 0 // LOTAG_MEMORY is a timer.
			setvar LOTAG_MEMORY 150
			
		setvarvar EXTRA_MEMORY HITAG_MEMORY // HITAG_MEMORY is an initial timer offset.
		
		action ANULLACTION
	}
	
	ifaction ALARM_LOOP
	{
		ifcount 104
			action ANULLACTION
	}
	else ifaction ALARM_START
	{
		addvar EXTRA_MEMORY 1
		ifvarvarg EXTRA_MEMORY LOTAG_MEMORY
		{
			setvar EXTRA_MEMORY 0
			action ALARM_LOOP
			resetcount
		}
	}
	else ifaction ANULLACTION
	{
		addvar EXTRA_MEMORY 1
		setvarvar TEMP LOTAG_MEMORY
		subvar TEMP 30
		ifvarvarg EXTRA_MEMORY TEMP
		{
			action ALARM_START
			sound FP_HAZARDALARM
			resetcount
		}
	}
enda


define SCRAP_WORKSLIKE 4226
defineprojectile COLORSCRAP1 PROJ_WORKSLIKE SCRAP_WORKSLIKE
defineprojectile COLORSCRAP1 PROJ_XREPEAT 32
defineprojectile COLORSCRAP1 PROJ_YREPEAT 32
defineprojectile COLORSCRAP1 PROJ_VEL 256
defineprojectile COLORSCRAP1 PROJ_DROP -256
defineprojectile COLORSCRAP1 PROJ_SPAWNS 0
defineprojectile COLORSCRAP1 PROJ_SOUND -1
defineprojectile COLORSCRAP1 PROJ_HITRADIUS 0
defineprojectile COLORSCRAP1 PROJ_CSTAT 128
defineprojectile COLORSCRAP1 PROJ_EXTRA 0
defineprojectile COLORSCRAP1 PROJ_CLIPDIST 1
defineprojectile COLORSCRAP1 PROJ_BSOUND -1
defineprojectile COLORSCRAP1 PROJ_ISOUND -1

defineprojectile COLORSCRAP2 PROJ_WORKSLIKE SCRAP_WORKSLIKE
defineprojectile COLORSCRAP2 PROJ_XREPEAT 32
defineprojectile COLORSCRAP2 PROJ_YREPEAT 32
defineprojectile COLORSCRAP2 PROJ_VEL 256
defineprojectile COLORSCRAP2 PROJ_DROP -256
defineprojectile COLORSCRAP2 PROJ_SPAWNS 0
defineprojectile COLORSCRAP2 PROJ_SOUND -1
defineprojectile COLORSCRAP2 PROJ_HITRADIUS 0
defineprojectile COLORSCRAP2 PROJ_CSTAT 128
defineprojectile COLORSCRAP2 PROJ_EXTRA 0 
defineprojectile COLORSCRAP2 PROJ_CLIPDIST 1
defineprojectile COLORSCRAP2 PROJ_BSOUND -1
defineprojectile COLORSCRAP2 PROJ_ISOUND -1

defineprojectile COLORSCRAP3 PROJ_WORKSLIKE SCRAP_WORKSLIKE
defineprojectile COLORSCRAP3 PROJ_XREPEAT 32
defineprojectile COLORSCRAP3 PROJ_YREPEAT 32
defineprojectile COLORSCRAP3 PROJ_VEL 256
defineprojectile COLORSCRAP3 PROJ_DROP -256
defineprojectile COLORSCRAP3 PROJ_SPAWNS 0
defineprojectile COLORSCRAP3 PROJ_SOUND -1
defineprojectile COLORSCRAP3 PROJ_HITRADIUS 0
defineprojectile COLORSCRAP3 PROJ_CSTAT 128
defineprojectile COLORSCRAP3 PROJ_EXTRA 0
defineprojectile COLORSCRAP3 PROJ_CLIPDIST 1
defineprojectile COLORSCRAP3 PROJ_BSOUND -1
defineprojectile COLORSCRAP3 PROJ_ISOUND -1

defineprojectile COLORSCRAP4 PROJ_WORKSLIKE SCRAP_WORKSLIKE
defineprojectile COLORSCRAP4 PROJ_XREPEAT 32
defineprojectile COLORSCRAP4 PROJ_YREPEAT 32
defineprojectile COLORSCRAP4 PROJ_VEL 256
defineprojectile COLORSCRAP4 PROJ_DROP -256
defineprojectile COLORSCRAP4 PROJ_SPAWNS 0
defineprojectile COLORSCRAP4 PROJ_SOUND -1
defineprojectile COLORSCRAP4 PROJ_HITRADIUS 0
defineprojectile COLORSCRAP4 PROJ_CSTAT 128
defineprojectile COLORSCRAP4 PROJ_EXTRA 0 
defineprojectile COLORSCRAP4 PROJ_CLIPDIST 1
defineprojectile COLORSCRAP4 PROJ_BSOUND -1
defineprojectile COLORSCRAP4 PROJ_ISOUND -1

// Tile NoPal entries (no actor defs)
spritenopal TBPIPE01