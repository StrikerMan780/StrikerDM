spritenoshade LDEXPLOSION
action LAMEDUKE_EXPLOSION_FRAMES 0 10 1 1 2
action LAMEDUKE_EXPLOSION_FRAMES_SLOW 0 10 1 1 4
actor LDEXPLOSION 1 LAMEDUKE_EXPLOSION_FRAMES
{
	ifactioncount 10
		killit
	
	ifcount 1
		nullop
	else ifcount 0
	{
		setactor[THISACTOR].shade -127
		cstat 128
		ifspawnedby PLASMABALL
		{
			spritepal 1
			cstator 2
		}
		else ifspawnedby PLASMABALL2
		{
			spritepal 1
			cstator 2
		}
	}
}
enda

spritenoshade RAILGUNTRAIL
action RAILGUN_TRAIL_FRAMES 0 16 5 1 2
actor RAILGUNTRAIL 1 RAILGUN_TRAIL_FRAMES
{
	ifactioncount 16
		killit
	
	ifcount 1
		nullop
	else ifcount 0
	{
		setactor[THISACTOR].shade -127
		//setactor[THISACTOR].xoffset -32
		cstat 130
	}
}
enda

action GIBBLOODFRAMES -1 4 1 1 15
actor GIBBLOOD 0 GIBBLOODFRAMES	
{
	ifcount 1
	{
	}
	else
	{
		cstator 128
		cstator 2
	
		ifrnd 128
			sizeat 32 32
		else ifrnd 128
			sizeat 24 24
	
		ifrnd 128
		{
			cstator 4
		}
		ifrnd 128
		{
			cstator 8
		}
	}
  
	sizeto 72 72 sizeto 72 72 sizeto 72 72
	ifactioncount 4 killit
}
enda

actor JUMPPAD 0
{
	// Change this to quick access variables when it comes time.
	getplayer[THISACTOR].cursectnum TEMP
	getactor[THISACTOR].sectnum TEMP2
	ifvarvare TEMP TEMP2 // Check if sector matches
	{
		ifp ponground
		{
			getplayervar[THISACTOR].JUMPPAD_HIT TEMP // Did they already hit the jump pad?
			ifvarn TEMP 1 // If not, let's do this.
			{
				sound JUMPPADSOUND
				setplayer[THISACTOR].on_ground 0 // No longer on the ground.
				
				getplayer[THISACTOR].posz TEMP // Kick them off the ground a little, to stop them from being "magnetized" to the ground.
				subvar TEMP 16384
				setplayer[THISACTOR].posz TEMP
				
				getactor[THISACTOR].hitag TEMP
				ifvare TEMP 0
				{
					setvar TEMP2 -4096 // If not hitag is set, -4096 is the default velocity.
				}
				else ifvarg TEMP 0
				{
					setvar TEMP2 0
					subvarvar TEMP2 TEMP
				}
				
				setplayer[THISACTOR].poszv TEMP2 // Launch
				
				setplayervar[THISACTOR].JUMPPAD_HIT 1 // They're in the air.
				
				// Set X/Y Velocities
				getactor[THISACTOR].xvel TEMP2
				mulvar TEMP2 1024
				setplayervar[THISACTOR].JUMPPAD_XVEL TEMP2
				
				getactor[THISACTOR].yvel TEMP2
				mulvar TEMP2 1024
				setplayervar[THISACTOR].JUMPPAD_YVEL TEMP2
			}
		}
	}
	
	ifaction 0
	{
		cstat 32768
		action ANULLACTION
	}
}
enda

action FAUCET_ANIM 0 2 1 1 2
actor FAUCET 0 ANULLACTION
	ifhitspace
	ifcount 30
	ifpdistl RETRIEVEDISTANCE
	ifcansee
	ifp pfacing
	{
		resetcount
		resetactioncount
		sound FAUCET_ON
		sound FAUCET_RUN
		action FAUCET_ANIM
		cactor FAUCET_RUNNING 
	}
enda

actor FAUCET_RUNNING 0 FAUCET_ANIM
	ifactioncount 60
	{
		sound FAUCET_RUN
		resetactioncount
	}
	
	ifhitspace
	ifcount 30
	ifpdistl RETRIEVEDISTANCE
	ifcansee
	ifp pfacing
	{
		resetcount
		resetactioncount
		sound FAUCET_OFF
		stopsound FAUCET_RUN
		action ANULLACTION
		cactor FAUCET 
	}
enda

actor FAUCET_RUNNING2
	sound FAUCET_RUN
	action FAUCET_ANIM
	cactor FAUCET_RUNNING
enda

state trigger_actors
	headspritestat CURSPRITE 1 // STAT_ACTOR
	setvarvar LASTSPRITE CURSPRITE
	whilevarn CURSPRITE -1
	{
		getactorvar[CURSPRITE].LOTAG_MEMORY TEMP
		ifvarvare LOTAG_MEMORY TEMP // Check if lotag matches
		{
			setactorvar[CURSPRITE].ACTIVATING 1
		}
				
		nextspritestat CURSPRITE LASTSPRITE
		setvarvar LASTSPRITE CURSPRITE
	}
ends

actor CUSTOMACTIVATOR
	ifspawnedby RESPAWN
	{
		getactor[THISACTOR].htowner OWNER
		getactor[OWNER].lotag LOTAG_MEMORY
			
		/*
		redefinequote 400 CUSTOMACTIVATOR OWNER: %d | LOTAG: %d
		qsprintf 400 400 OWNER LOTAG_MEMORY
		userquote 400
		*/
			
		state trigger_actors
			
		espawn RESPAWN
		setactor[RETURN].lotag LOTAG_MEMORY
		setactor[RETURN].hitag 9998
		setvar RETURN 0
		
		killit
	}
	else
	{
		killit
	}
enda

actor CUSTOMTOUCHPLATE
	ifaction 0
	{
		cstat 32768
		action ANULLACTION
	}
	
	headspritestat CURSPRITE 10 // STAT_PLAYER
	setvarvar LASTSPRITE CURSPRITE
	whilevarn CURSPRITE -1
	{
		getactor[CURSPRITE].sectnum TEMP
		ifvarvare SECTNUM_MEMORY TEMP // Check if sector matches
		{
			state trigger_actors
			break
		}
				
		nextspritestat CURSPRITE LASTSPRITE
		setvarvar LASTSPRITE CURSPRITE
	}
enda

// XREPEAT_MEMORY = Internal Timer
// HITAG = Switch Channel
// LOTAG = Sector for Platform
// SPAWN_ORIGZ = Original Z Position
// XVEL/SPAWN_ORIGX = Time To Pause
// YVEL/SPAWN_ORIGY = Destination Z Position
// ZVEL/SPAWN_ORIGZVEL = Z Velocity
action TRIGGERED 0
action WAITING 0
action RETURNING 0
actor TIMEDPLATFORM
{
	ifaction ANULLACTION
	{
		ifvare ACTIVATING 1
		{
			setvar XREPEAT_MEMORY 0
			setsector[THISACTOR].floorzvel SPAWN_ORIGZVEL
			setsector[THISACTOR].floorzgoal SPAWN_ORIGY
			action TRIGGERED
		}
	}
	
	ifaction TRIGGERED
	{
		getsector[THISACTOR].floorzgoal TEMP
		ifvare TEMP -1
		{
			action WAITING
		}
	}
	
	ifaction WAITING
	{
		addvar XREPEAT_MEMORY 1
		ifvarvare XREPEAT_MEMORY SPAWN_ORIGX
		{
			setsector[THISACTOR].floorzvel SPAWN_ORIGZVEL
			setsector[THISACTOR].floorzgoal SPAWN_ORIGZ
			setvar XREPEAT_MEMORY 0
			action RETURNING
		}
	}
	
	ifaction RETURNING
	{
		getsector[THISACTOR].floorzgoal TEMP
		ifvare TEMP -1
		{
			setvar ACTIVATING 0
			action ANULLACTION
		}
	}
	
	ifaction 0
	{
		cstat 32768
		getsector[THISACTOR].floorz SPAWN_ORIGZ
		getactor[THISACTOR].xvel SPAWN_ORIGX
		getactor[THISACTOR].yvel SPAWN_ORIGY
		getactor[THISACTOR].zvel SPAWN_ORIGZVEL
		action ANULLACTION
	}
}
enda

state platform_sound
	ifaction ANULLACTION
	{
		getsector[THISACTOR].floorzgoal TEMP
		ifvarn TEMP -1
		{
			soundvar LOTAG_MEMORY
			stopsoundvar HITAG_MEMORY
			action TRIGGERED
		}
	}
	
	ifaction TRIGGERED
	{
		getsector[THISACTOR].floorzgoal TEMP
		ifvare TEMP -1
		{
			soundvar HITAG_MEMORY
			stopsoundvar LOTAG_MEMORY
			action ANULLACTION
		}
	}
ends

state door_sound
	ifaction ANULLACTION
	{
		getsector[THISACTOR].ceilingzgoal TEMP
		ifvarn TEMP -1
		{
			getsector[THISACTOR].ceilingz TEMP2
			getsector[THISACTOR].floorz TEMP3		
			ifvarvare TEMP2 TEMP3 // Open
			{
				soundvar LOTAG_MEMORY
				stopsoundvar HITAG_MEMORY
			}
			else // Close
			{
				soundvar HITAG_MEMORY
				stopsoundvar LOTAG_MEMORY
			}
			
			action TRIGGERED
		}
	}
	
	ifaction TRIGGERED
	{
		getsector[THISACTOR].ceilingzgoal TEMP
		ifvare TEMP -1
		{
			action ANULLACTION
		}
	}
ends

// SECTNUM_MEMORY = Sector Lotag
actor CONTEXTSOUND 0
{
	switch SECTNUM_MEMORY
		case 20:
			state door_sound
			break
		default:
			state platform_sound
			break
	endswitch
	
	ifaction 0
	{
		cstat 32768
		action ANULLACTION
		getsector[THISACTOR].lotag SECTNUM_MEMORY
	}
}
enda

actor STARTWEAPONCHANGER
	setvarvar START_WEAPON LOTAG_MEMORY
	killit
enda

// SFLAG_NOEVENTCODE + SFLAG_NOCLIP + SFLAG_SMOOTHMOVE + SFLAG_NOTELEPORT
spriteflags SNOWFLAKE 26752
actor SNOWFLAKE
	ifaction 0
	{
		getactor[THISACTOR].sectnum TEMP
		ifvare TEMP -1
		{
			killit
		}
		
		cstat 130
		sizeat 6 6
		action ANULLACTION
	}
	
	fall
	
	getactor[THISACTOR].zvel TEMP
	ifvarg TEMP 164
	{
		setactor[THISACTOR].zvel 164
	}
	
	// s->xvel = (krand()&7)+(sintable[T1&2047]>>9);
	randvar TEMP 7
	getactor[THISACTOR].htg_t 0 TEMP2
	sin TEMP3 TEMP2
	shiftvarr TEMP3 9
	addvarvar TEMP TEMP3
	setvarvar SPAWN_ORIGX TEMP
	
	
	randvar TEMP 7
	setvarvar TEMP2 EXTRA_MEMORY
	sin TEMP3 TEMP2
	shiftvarr TEMP3 9
	addvarvar TEMP TEMP3
	setvarvar SPAWN_ORIGY TEMP
	
	movesprite THISACTOR SPAWN_ORIGX SPAWN_ORIGY 0 0 CLIPDIST_MEMORY
	
	// T1 += (krand()&63);
	randvar TEMP 63
	getactor[THISACTOR].htg_t 0 TEMP2
	addvarvar TEMP2 TEMP
	setactor[THISACTOR].htg_t 0 TEMP2
	
	// EXTRA_MEMORY += (krand()&63);
	randvar TEMP 63
	addvarvar EXTRA_MEMORY TEMP
	
	iffloordistl 4
		killit
enda

state spawn_snow
	getactor[THISACTOR].x SPAWN_ORIGX
	randvar TEMP 20480
	subvar TEMP 10240
	addvarvar SPAWN_ORIGX TEMP
	
	getactor[THISACTOR].y SPAWN_ORIGY
	randvar TEMP 20480
	subvar TEMP 10240
	addvarvar SPAWN_ORIGY TEMP
	
	updatesector SPAWN_ORIGX SPAWN_ORIGY SECTNUM_MEMORY
	
	ifvarn SECTNUM_MEMORY -1
	{
		getsector[SECTNUM_MEMORY].ceilingstat TEMP
		ifvarand TEMP 1
		{
			espawn SNOWFLAKE
			changespritesect RETURN SECTNUM_MEMORY
			
			setactor[RETURN].x SPAWN_ORIGX
			setactor[RETURN].y SPAWN_ORIGY
			
			getsector[SECTNUM_MEMORY].ceilingz TEMP2
			setactor[RETURN].z TEMP2
			
			setvar RETURN 0
		}
	}
ends

actor SNOWFLAKESPAWNER
	ifaction 0
	{
		cstat 32768
		action ANULLACTION
	}
	
	state spawn_snow
	state spawn_snow
enda

state onground_gib_code
	fall
	ifcount 316
	{
		killit
	}
	else ifcount 308
	{
		cstator 512
	}
	else ifcount 300
	{
		cstator 2
	}
	else ifcount 1 { }
	else ifcount 0
	{
		sizeat 32 32
		getactor[THISACTOR].pal TEMP3
			
		ifrnd 128 { eqspawn WALLBLOOD2 }
		ifrnd 64 { eqspawn 1622 }
		else { eqspawn WALLBLOOD5 }
			
		setactor[RETURN].pal TEMP3
		
		randvar TEMP3 2048
		setactor[RETURN].ang TEMP3
		
		randvar TEMP3 16
		addvar TEMP3 32
		setactor[RETURN].xrepeat TEMP3
		
		randvar TEMP3 16
		addvar TEMP3 32
		setactor[RETURN].yrepeat TEMP3
		
		ifrnd 128 { setactor[RETURN].cstat 32 }
		else { setactor[RETURN].cstat 36 }
			
		setvar RETURN 0
	}
ends

actor DUKETORSO_ONGROUND
{
	ifspawnedby DUKETORSO_ONGROUND { }
	else
	{
		state onground_gib_code
	}
}
enda

actor DUKEGUN_ONGROUND
{
	ifspawnedby DUKEGUN_ONGROUND { }
	else
	{
		state onground_gib_code
	}
}
enda

actor DUKELEG_ONGROUND
{
	ifspawnedby DUKELEG_ONGROUND { }
	else
	{
		state onground_gib_code
	}
}
enda

actor JIBS1_ONGROUND
{
	ifspawnedby JIBS1_ONGROUND { }
	else
	{
		state onground_gib_code
	}
}
enda

actor JIBS2_ONGROUND
{
	ifspawnedby JIBS2_ONGROUND { }
	else
	{
		state onground_gib_code
	}
}
enda

actor JIBS3_ONGROUND
{
	ifspawnedby JIBS3_ONGROUND { }
	else
	{
		state onground_gib_code
	}
}
enda

actor JIBS4_ONGROUND
{
	ifspawnedby JIBS4_ONGROUND { }
	else
	{
		state onground_gib_code
	}
}
enda

actor JIBS5_ONGROUND
{
	ifspawnedby JIBS5_ONGROUND { }
	else
	{
		state onground_gib_code
	}
}
enda

define SCRAP_WORKSLIKE 4226
defineprojectile COLORSCRAP1 PROJ_WORKSLIKE SCRAP_WORKSLIKE
defineprojectile COLORSCRAP1 PROJ_XREPEAT 32
defineprojectile COLORSCRAP1 PROJ_YREPEAT 32
defineprojectile COLORSCRAP1 PROJ_VEL 256
defineprojectile COLORSCRAP1 PROJ_DROP -256
defineprojectile COLORSCRAP1 PROJ_SPAWNS 0
defineprojectile COLORSCRAP1 PROJ_SOUND -1
defineprojectile COLORSCRAP1 PROJ_HITRADIUS 0
defineprojectile COLORSCRAP1 PROJ_CSTAT 128
defineprojectile COLORSCRAP1 PROJ_EXTRA 0
defineprojectile COLORSCRAP1 PROJ_CLIPDIST 1
defineprojectile COLORSCRAP1 PROJ_BSOUND -1
defineprojectile COLORSCRAP1 PROJ_ISOUND -1

defineprojectile COLORSCRAP2 PROJ_WORKSLIKE SCRAP_WORKSLIKE
defineprojectile COLORSCRAP2 PROJ_XREPEAT 32
defineprojectile COLORSCRAP2 PROJ_YREPEAT 32
defineprojectile COLORSCRAP2 PROJ_VEL 256
defineprojectile COLORSCRAP2 PROJ_DROP -256
defineprojectile COLORSCRAP2 PROJ_SPAWNS 0
defineprojectile COLORSCRAP2 PROJ_SOUND -1
defineprojectile COLORSCRAP2 PROJ_HITRADIUS 0
defineprojectile COLORSCRAP2 PROJ_CSTAT 128
defineprojectile COLORSCRAP2 PROJ_EXTRA 0 
defineprojectile COLORSCRAP2 PROJ_CLIPDIST 1
defineprojectile COLORSCRAP2 PROJ_BSOUND -1
defineprojectile COLORSCRAP2 PROJ_ISOUND -1

defineprojectile COLORSCRAP3 PROJ_WORKSLIKE SCRAP_WORKSLIKE
defineprojectile COLORSCRAP3 PROJ_XREPEAT 32
defineprojectile COLORSCRAP3 PROJ_YREPEAT 32
defineprojectile COLORSCRAP3 PROJ_VEL 256
defineprojectile COLORSCRAP3 PROJ_DROP -256
defineprojectile COLORSCRAP3 PROJ_SPAWNS 0
defineprojectile COLORSCRAP3 PROJ_SOUND -1
defineprojectile COLORSCRAP3 PROJ_HITRADIUS 0
defineprojectile COLORSCRAP3 PROJ_CSTAT 128
defineprojectile COLORSCRAP3 PROJ_EXTRA 0
defineprojectile COLORSCRAP3 PROJ_CLIPDIST 1
defineprojectile COLORSCRAP3 PROJ_BSOUND -1
defineprojectile COLORSCRAP3 PROJ_ISOUND -1

defineprojectile COLORSCRAP4 PROJ_WORKSLIKE SCRAP_WORKSLIKE
defineprojectile COLORSCRAP4 PROJ_XREPEAT 32
defineprojectile COLORSCRAP4 PROJ_YREPEAT 32
defineprojectile COLORSCRAP4 PROJ_VEL 256
defineprojectile COLORSCRAP4 PROJ_DROP -256
defineprojectile COLORSCRAP4 PROJ_SPAWNS 0
defineprojectile COLORSCRAP4 PROJ_SOUND -1
defineprojectile COLORSCRAP4 PROJ_HITRADIUS 0
defineprojectile COLORSCRAP4 PROJ_CSTAT 128
defineprojectile COLORSCRAP4 PROJ_EXTRA 0 
defineprojectile COLORSCRAP4 PROJ_CLIPDIST 1
defineprojectile COLORSCRAP4 PROJ_BSOUND -1
defineprojectile COLORSCRAP4 PROJ_ISOUND -1