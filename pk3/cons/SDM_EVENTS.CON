damageeventtilerange 0 9999

defstate set_on_fire
	getactor[RETURN].extra TEMP
	ifvarl TEMP 1
		break
	
	// Team DM?
	ifvarand gametype_flags 65536
	{
		ifvare FFIRE 0 // Friendly fire is off.
		{
			getactor[RETURN].picnum TEMP
			getactor[THISACTOR].owner TEMP2
			getactor[TEMP2].picnum TEMP3
			
			ifvare TEMP APLAYER // Are both attackers players?
			ifvare TEMP3 APLAYER
			{
				ifvarvarn TEMP2 RETURN
				{
					getactor[RETURN].yvel TEMP
					getplayer[TEMP].team TEMP	
					
					getactor[TEMP2].yvel TEMP2
					getplayer[TEMP2].team TEMP2
					
					ifvarvare TEMP TEMP2 // Team matches?
					{
						break // Bail.
					}
				}
			}
		}
	}
	else ifvarand gametype_flags 4096 // All players friendly?
	{
		ifvare FFIRE 0 // Friendly fire is off.
		{
			getactor[RETURN].picnum TEMP
			getactor[THISACTOR].owner TEMP2
			getactor[TEMP2].picnum TEMP3
			
			ifvare TEMP APLAYER // Are both attackers players?
			ifvare TEMP3 APLAYER
			{
				ifvarvarn TEMP2 RETURN
				{
					break // Bail.
				}
			}
		}
	}
	
	getactor[RETURN].picnum TEMP
	ifvarn TEMP APLAYER
	{
		ifvare TEMP BOSS5 // BOSS5 can't be set on fire.
		{
			break
		}
		
		// Check if owner picnum is the same as victim picnum. (So fireflies can't burn eachother)
		getactor[THISACTOR].owner TEMP2
		getactor[TEMP2].picnum TEMP2
		ifvarvare TEMP TEMP2
		{
			break
		}
	}
	else
	{
		getactor[RETURN].yvel TEMP2
		getplayervar[TEMP2].SHIELD_HEALTH TEMP3
		ifvarg TEMP3 0 // We have a shield.
		{
			getplayervar[TEMP2].SHIELD_TYPE TEMP3
			ifvare TEMP3 SHIELDTYPE_FIRE // Fire shield prevents being set on fire.
				break
				
			ifvare TEMP3 SHIELDTYPE_WATER // So does water.
				break
		}
	}
	
	getactorvar[RETURN].BURNING_TICS TEMP
	ifvarl TEMP 117 // Burning for more than 4 tics, or not burning at all.
	{
		getactor[RETURN].cstat TEMP
		ifvarand TEMP 256 // Can be shot?
		{
			getactorvar[RETURN].BURNING_RESETFLAGS TEMP
			ifvare TEMP -1 // Haven't checked RESETFLAGS yet?
			{
				getactor[RETURN].mdflags TEMP
				setactorvar[RETURN].BURNING_RESETFLAGS TEMP // Store the flags to restore later.
				orvar TEMP 16
				setactor[RETURN].mdflags TEMP
			}
			
			getactor[THISACTOR].owner TEMP // Get owner of projectile
			setactorvar[RETURN].BURNING_TICS 120 // Start burning for 120 tics
			setactorvar[RETURN].BURNING_INFLICTOR TEMP // Store owner in victim's data
			setactor[RETURN].htpicnum FIREBALL
			
			getactor[RETURN].htextra TEMP
			ifvare TEMP -1 { setactor[RETURN].htextra 0 }
			
			getactor[RETURN].picnum TEMP
			switch TEMP
				case TREE1:
				case TREE2:
				case TIRE:
				case CONE:
				case BOX:
					getactor[RETURN].htg_t 0 TEMP
					ifvare TEMP 0 // Trigger hardcoded burn/shrink code
					{
						getactor[RETURN].cstat TEMP
						ifvarand TEMP 1 { subvar TEMP 1 }
						ifvarand TEMP 256 { subvar TEMP 256 }
						setactor[RETURN].cstat TEMP
						setactor[RETURN].htg_t 0 1
					}
					break
			endswitch
		}
	}
ends

onevent EVENT_DAMAGESPRITE
	getactor[THISACTOR].owner TEMP // DON'T OVERWRITE
	setactorvar[RETURN].LASTHITBY TEMP
	
	ifvarvare TEMP RETURN // If owner is the same as victim
	{
		getactor[RETURN].picnum TEMP2 // Make bosses unable to hurt themselves
		ifvare TEMP2 BOSS2
		{
			setvar RETURN -1
			break
		}
		else ifvare TEMP2 BOSS3
		{
			setvar RETURN -1
			break
		}
		else ifvare TEMP2 BOSS5
		{
			setvar RETURN -1
			break
		}
	}
	
	ifactor FREEZEBLAST
	{
		getactorvar[RETURN].BURNING_TICS TEMP2
		ifvarg TEMP2 0
		{
			setactor[THISACTOR].extra 1
		}
	}
	else ifactor FIREBALL
	{
		state set_on_fire
	}
	else ifactor FLAMETHROWERFLAME
	{
		state set_on_fire
	}
	else ifactor BURNING_ALT
	{
		state set_on_fire	
		setvar RETURN -1 // Do not do the usual radius damage processing
		break
	}
	else ifactor BURNING2_ALT
	{
		state set_on_fire
		setvar RETURN -1 // Do not do the usual radius damage processing
		break
	}
	else ifactor DEVASTATORMISSILE
	{
		getactor[RETURN].picnum TEMP2
		
		switch TEMP2
			case APLAYER:
				getuserdef[].return 1 TEMP2 
				ifvare TEMP2 -1 // Direct hit, not radius.
				{
					// Reduced player damage for balance.
					setvar STATE_PARAM1 3
					setvarvar STATE_PARAM2 RETURN
					setvar STATE_PARAM3 DEVASTATORMISSILE
					setvarvar STATE_PARAM4 TEMP2
					state apply_damage
					
					setvar RETURN -1 // Break out of this crap.
				}
				break
			case CRACK1:
			case CRACK2:
			case CRACK3:
			case CRACK4:
				setactor[RETURN].htpicnum RADIUSEXPLOSION // Make sure cracks can get destroyed by the devastator
				break
			default:
				getactor[RETURN].statnum TEMP2
				getuserdef[].return 1 TEMP3
				ifvare TEMP2 STAT_FALLER
				{
					setvar STATE_PARAM1 GENERICIMPACTDAMAGE // Same with STAT_FALLERs.
					setvarvar STATE_PARAM2 RETURN
					setvar STATE_PARAM3 RADIUSEXPLOSION
					getuserdef[].return 1 STATE_PARAM4
					state apply_damage
					
					setvar RETURN -1
				}
				break
		endswitch
	}
	else ifactor GROWSPARK
	{
		getactor[RETURN].picnum TEMP
		switch TEMP
			case CRACK1:
			case CRACK2:
			case CRACK3:
			case CRACK4:
				setvar RETURN -1
				break
		endswitch
	}
	
	ifvare RETURN -1
		break
		
endevent

state check_penetration
	getactor[RETURN].extra TEMP
	getactor[RETURN].htextra TEMP2
	ifvarvarl TEMP TEMP2 // Has total incoming damage exceeded target's health? (Ie. Guaranteed to die)
	{
		// Make non-shootable, allowing the rest of the shotgun blast to pass through like DOOM.
		getactor[RETURN].cstat TEMP
		ifvarand TEMP 256
		{
			subvar TEMP 256
			setactor[RETURN].cstat TEMP
			setactorvar[RETURN].PENETRATED 1
		}
	}
ends

onevent EVENT_POSTDAMAGESPRITE
	ifactor SHOTSPARK1
	{
		getactor[THISACTOR].yvel TEMP
		ifvare TEMP RAILGUNSHOT
		{
			getactor[RETURN].picnum TEMP
			ifvarn TEMP APLAYER
			{
				setactor[RETURN].htpicnum RADIUSEXPLOSION
				getactor[RETURN].htextra TEMP
				addvar TEMP 20
				setactor[RETURN].htextra TEMP
			}
			else
			{
				setactor[RETURN].htpicnum RAILGUNSHOT
			}
		}
		else ifvare TEMP SSGPELLET
		{
			getactor[RETURN].picnum TEMP
			gettiledata[TEMP].gameflags TEMP2
			
			ifvare TEMP APLAYER
			{
				state check_penetration
			}
			else ifvarand TEMP2 32 // SFLAG_BADGUY
			{
				state check_penetration
			}
			else ifvarand TEMP2 262144 // SFLAG_HARDCODED_BADGUY
			{
				state check_penetration
			}
				
			getactor[THISACTOR].htowner TEMP
			dist TEMP2 TEMP RETURN
			ifvarl TEMP2 SSG_GIB_DISTANCE // SSG gibs at point-blank
			{
				setactor[RETURN].htpicnum RADIUSEXPLOSION
			}
			else ifvarl TEMP2 SSG_MIGHT_GIB_DISTANCE
			{
				ifrnd 64
					setactor[RETURN].htpicnum RADIUSEXPLOSION
			}
		}
	}
	else ifactor DFGBALL
	{
		getactor[RETURN].picnum TEMP2
		ifvarn TEMP2 APLAYER
		{
			setactor[RETURN].htpicnum RADIUSEXPLOSION
		}
	}
	
	getactor[RETURN].picnum TEMP
	ifvare TEMP APLAYER
	{
		// STATE_PARAM1 = amount
		// STATE_PARAM2 = victim
		// STATE_PARAM3 = htpicnum
		// STATE_PARAM4 = radius damage
		getactor[RETURN].htextra STATE_PARAM1
		setvarvar STATE_PARAM2 RETURN
		getactor[RETURN].htpicnum STATE_PARAM3
		getuserdef[].return 1 STATE_PARAM4
		state process_shield_damage
		setactor[RETURN].htextra STATE_RETURN
	}
endevent

onevent EVENT_CHECKTOUCHDAMAGE
	setvarvar TEMP RETURN
	andvar TEMP 49152
	ifvare TEMP 49152
	{
		subvar RETURN 49152
		setvarvar STATE_PARAM1 RETURN
		state check_object_touch
		
		ifvarg SHIELD_HEALTH 0
		ifvare SHIELD_TYPE SHIELDTYPE_FIRE
			state set_on_fire
	}
endevent

onevent EVENT_BOTGETSPRITESCORE
	ifactor CRYSTALSHARD
	{
		getplayer[THISACTOR].shield_amount TEMP
		ifvarl TEMP 50
			setvar RETURN 15
		else ifvarl TEMP 100
			setvar RETURN 10
		else ifvarl TEMP 200
			setvar RETURN 5
		break
	}
	
	ifactor LIFEPETAL
	{
		getplayer[THISACTOR].i TEMP
		getactor[TEMP].extra TEMP
		ifvarl TEMP 25
			setvar RETURN 28
		else ifvarl TEMP 50
			setvar RETURN 21
		else ifvarl TEMP 100
			setvar RETURN 14
		break
	}
endevent

onevent EVENT_KILLIT
	ifactor FIREBALL
	{
		espawn ONFIRE
		getactor[THISACTOR].owner TEMP
		setactor[RETURN].owner TEMP
		setvar RETURN 0
		break
	}
	
	ifactor GROWSPARK
	{
		espawn EXPANDEREXPLOSION
		getactor[THISACTOR].owner TEMP
		setactor[RETURN].owner TEMP
		setvar RETURN 0
		break
	}
	
	ifactor DFGBALL
	{
		espawn DFGEXPLOSION
		getactor[THISACTOR].owner TEMP
		setactor[RETURN].owner TEMP
		setvar RETURN 0
		break
	}
	
	// Use a quick-access var here later.
	getactor[THISACTOR].picnum TEMP
	switch TEMP
		case BOTTLE1:
		case BOTTLE2:
		case BOTTLE3:
		case BOTTLE4:
		case BOTTLE5:
		case BOTTLE6:
		case BOTTLE7:
		case BOTTLE8:
		case BOTTLE10:
		case BOTTLE11:
		case BOTTLE12:
		case BOTTLE13:
		case BOTTLE14:
		case BOTTLE15:
		case BOTTLE16:
		case BOTTLE17:
		case BOTTLE18:
		case BOTTLE19:
		case FOODOBJECT1:
		case FOODOBJECT2:
		case FOODOBJECT3:
		case FOODOBJECT4:
		case FOODOBJECT5:
		case FOODOBJECT6:
		case FOODOBJECT7:
		case FOODOBJECT8:
		case FOODOBJECT9:
		case FOODOBJECT10:
		case FOODOBJECT11:
		case FOODOBJECT12:
		case FOODOBJECT13:
		case FOODOBJECT14:
		case FOODOBJECT15:
		case FOODOBJECT16:
		case FOODOBJECT17:
		case FOODOBJECT18:
		case FOODOBJECT19:
		case FOODOBJECT20:
		case JOLLYMEAL:
		case COFFEEMUG:
		case COFFEEMACHINE:
		case RUBBERCAN:
		case CANWITHSOMETHING:
		case CANWITHSOMETHING2:
		case CANWITHSOMETHING3:
		case CANWITHSOMETHING4:
		case EXPLODINGBARREL:
		case FIREBARREL:
		case FIREVASE:
		case DUKEBURGER:
		case GUNPOWDERBARREL:
		case ROBOTDOG:
		case ROBOTDOG2:
		case FEATHEREDCHICKEN:
		case SKINNEDCHICKEN:
		case DESKLAMP:
		case MAILBAG:
		case CLOCK:
		case VACUUM:
		case DOMELITE:
		case CAMERALIGHT:
		case MOVIECAMERA:
		case TRIPODCAMERA:
		case CHAIR3:
		case DURRPLANT:
		case BONG:
		case BONG2:
		case DILDO:
		case FLESHLIGHT:
		case VIBRATOR:
		case BD_SOFIA:
			state prepare_respawn_hardcoded
			break
	endswitch
	
	ifactor SHELL
	{
		randvar RANDOM_SOUND 5
		switch RANDOM_SOUND
			case 0: sound CASING1 break
			case 1: sound CASING2 break
			case 2: sound CASING3 break
			case 3: sound CASING4 break
			case 4: sound CASING5 break
			case 5: sound CASING6 break
		endswitch
		break
	}
	else ifactor SHOTGUNSHELL
	{
		randvar RANDOM_SOUND 5
		switch RANDOM_SOUND
			case 0: sound SHELL_BOUNCE1 break
			case 1: sound SHELL_BOUNCE2 break
			case 2: sound SHELL_BOUNCE3 break
			case 3: sound SHELL_BOUNCE4 break
			case 4: sound SHELL_BOUNCE5 break
			case 5: sound SHELL_BOUNCE6 break
		endswitch
		break
	}
	
	ifactor OOZFILTER
	{
		ifvare NORESPAWN 1
		{
			setvar RETURN 0
		}
		else
		{
			state prepare_respawn_hardcoded
		}
	}
	else ifactor SEENINE
	{
		ifvare NORESPAWN 1
		{
			setvar RETURN 0
		}
		else
		{
			state prepare_respawn_hardcoded
		}
	}
	else ifactor 1249 // SEENINEDEAD+1
	{
		ifvare NORESPAWN 1
		{
			setvar RETURN 0
		}
		else
		{
			state prepare_respawn_hardcoded
		}
	}
endevent

state boss_projectile_offset
	getactor[THISACTOR].ang SPAWN_ORIGANG
			
	// Calculate X position
	setvarvar TEMP SPAWN_ORIGANG
	sin TEMP2 TEMP
	divvar TEMP2 512
			
	// Set X position
	getactor[THISACTOR].x TEMP
	subvarvar TEMP TEMP2
	setactor[THISACTOR].x TEMP
			
	// Calculate Y position
	setvarvar TEMP SPAWN_ORIGANG
	addvar TEMP 1536
	sin TEMP2 TEMP
	
	getactor[THISACTOR].owner TEMP3
	getactor[TEMP3].pal TEMP3
	ifvare TEMP3 0
	{
		divvar TEMP2 128
	}
	else
	{
		divvar TEMP2 256
	}
			
	// Set Y position
	getactor[THISACTOR].y TEMP
	subvarvar TEMP TEMP2
	setactor[THISACTOR].y TEMP
			
	getactor[THISACTOR].z TEMP
	ifvare TEMP3 0
	{
		addvar TEMP 7200
	}
	else
	{
		addvar TEMP 3600
	}
	setactor[THISACTOR].z TEMP
ends

state devastator_boss_spread
	getactor[THISACTOR].ang TEMP
	addvar TEMP 96
	randvar TEMP2 192
	subvarvar TEMP TEMP2
	setactor[THISACTOR].ang TEMP
	
	getactor[THISACTOR].zvel TEMP
	addvar TEMP 512
	randvar TEMP2 1024
	subvarvar TEMP TEMP2
	setactor[THISACTOR].zvel TEMP
ends

state boss_devastatormissile_resize
	setactor[THISACTOR].xrepeat 16
	setactor[THISACTOR].yrepeat 16
	setthisprojectile[THISACTOR].txrepeat 16
	setthisprojectile[THISACTOR].tyrepeat 16
	setthisprojectile[THISACTOR].sxrepeat 16
	setthisprojectile[THISACTOR].syrepeat 16
ends

onevent EVENT_EGS
	getactor[THISACTOR].owner OWNER
	
	// TODO: Change this to quick-access vars once EDuke32 gets better MP.
	ifactor FIREBALL
	{
		setactor[THISACTOR].blend 255 // Additive Blend
		setactor[THISACTOR].mdflags 16
		
		// Calculate horizontal spread
		getactor[THISACTOR].ang TEMP
		ifspawnedby BOSS5
		{
			addvar TEMP 128
			randvar TEMP2 256
		}
		else
		{
			addvar TEMP 8
			randvar TEMP2 16
		}
		subvarvar TEMP TEMP2
		setactor[THISACTOR].ang TEMP
		
		// Calculate vertical spread
		getactor[THISACTOR].zvel TEMP
		ifspawnedby BOSS5
		{
			addvar TEMP 1024
			randvar TEMP2 2048
		}
		else
		{
			addvar TEMP 128
			randvar TEMP2 256
		}
		subvarvar TEMP TEMP2
		setactor[THISACTOR].zvel TEMP
		
		ifspawnedby BOSS5
		{
			state boss_projectile_offset
		}
		
		break
	}
	
	ifactor FIRELASER
	{
		cstator 2
		setactor[THISACTOR].blend 255
		break
	}
	
	ifactor SCRAP1
	ifspawnedby BLIMP
	{
		state set_blimp_drops
	}

	ifactor GROWSPARK
	{
		setactor[THISACTOR].blend 255
		break
	}
	
	ifactor JIBS6
	{
		ifspawnedby SHOTSPARK1
		{
			getactor[THISACTOR].owner TEMP // Shotspark
			setactor[TEMP].cstat 32768 // Hide the spark
			getactor[TEMP].htg_t 8 TEMP // Target hit
			getactor[TEMP].picnum TEMP2 // Target picnum
			
			ifvare TEMP2 APLAYER
			{
				getactor[TEMP].pal TEMP3 // Target's pal
				setactor[THISACTOR].pal TEMP3
				
				// Shield Checks
				getactor[TEMP].yvel TEMP
				getplayervar[TEMP].SHIELD_HEALTH TEMP3
				getplayervar[TEMP].SHIELD_TYPE TEMP4
				ifvarg TEMP3 0 // We have a shield
				{
					ifvare TEMP4 SHIELDTYPE_WOOD
						espawn WOODSHIELD_FX2
					else
						espawn SHARD_FX3
						
					setvarvar STATE_PARAM1 TEMP4
					state get_shield_particle_pal
					setactor[RETURN].pal STATE_RETURN
					setvar RETURN 0
					
					setactor[THISACTOR].cstat 32768
					break
				}
			}
			
			switch TEMP2
				case NEWBEAST:
					setactor[THISACTOR].pal 125
					break
				case EGG
					setactor[THISACTOR].pal 8
					break
			endswitch
			
			randvar RANDOM_SOUND 4
			switch RANDOM_SOUND
				case 0: sound BULLET_HIT1 break
				case 1: sound BULLET_HIT2 break
				case 2: sound BULLET_HIT3 break
				case 3: sound BULLET_HIT4 break
				case 4: sound BULLET_HIT5 break
			endswitch

			ifinwater
			{
				espawn BLOODINFLUID1
				getactor[THISACTOR].pal TEMP2
				setactor[RETURN].pal TEMP2
				randvar TEMP 8
				addvar TEMP 8
				setactor[RETURN].xrepeat TEMP
				setactor[RETURN].yrepeat TEMP
				setvar RETURN 0
			}
			else
			{
				espawn BLOODSPURT
				getactor[THISACTOR].pal TEMP2
				setactor[RETURN].pal TEMP2
				
				randvar TEMP 56
				addvar TEMP 8
				setactor[RETURN].xvel TEMP
				
				setvar TEMP -256
				randvar TEMP2 1280
				subvarvar TEMP TEMP2
				setactor[RETURN].zvel TEMP
				
				randvar TEMP 2047
				setactor[RETURN].ang TEMP
				setvar RETURN 0
				
				espawn BLOOD // Spawn spray effect
				getactor[THISACTOR].pal TEMP2
				setactor[RETURN].pal TEMP2
				setactorvar[RETURN].ANIMATE_LIFETIME 30
				setactorvar[RETURN].XREPEAT_MEMORY 4
				randvar TEMP2 16
				addvar TEMP2 32
				setactorvar[RETURN].YREPEAT_MEMORY TEMP2
				setvar RETURN 0
			}
		}
		
		setvar PICNUM_MEMORY JIBS6
		break
	}
	
	// Freezeblast speed buff
	ifactor FREEZEBLAST
	{
		setactor[THISACTOR].xvel 768
	}
	
	ifactor FLAMETHROWERFLAME
	{
		// Calculate horizontal spread
		getactor[THISACTOR].ang TEMP
		ifspawnedby BOSS5
		{
			addvar TEMP 128
			randvar TEMP2 256
		}
		else
		{
			addvar TEMP 32
			randvar TEMP2 64
		}
		subvarvar TEMP TEMP2
		setactor[THISACTOR].ang TEMP
		
		// Calculate vertical spread
		getactor[THISACTOR].zvel TEMP
		ifspawnedby BOSS5
		{
			addvar TEMP 1024
			randvar TEMP2 2048
		}
		else
		{
			addvar TEMP 512
			randvar TEMP2 1024
		}
		subvarvar TEMP TEMP2
		setactor[THISACTOR].zvel TEMP
		
		setactor[THISACTOR].blend 255 // Additive Blend
		break
	}
	
	ifactor DEVASTATORMISSILE
	{
		ifspawnedby BOSS5
		{
			state devastator_boss_spread
			state boss_devastatormissile_resize
		}
		else ifspawnedby BOSS2
		{
			state devastator_boss_spread
			state boss_devastatormissile_resize
		}
		else
		{
			// Calculate horizontal spread
			getactor[THISACTOR].ang TEMP
			addvar TEMP 16
			randvar TEMP2 32
			subvarvar TEMP TEMP2
			setactor[THISACTOR].ang TEMP
			
			// Calculate vertical spread
			getactor[THISACTOR].zvel TEMP
			addvar TEMP 256
			randvar TEMP2 512
			subvarvar TEMP TEMP2
			setactor[THISACTOR].zvel TEMP
		}
		
		ifspawnedby APLAYER
		{
			// Get angle and barrel
			getplayer[THISACTOR].hbomb_hold_delay TEMP3
			getplayer[THISACTOR].ang SPAWN_ORIGANG
			
			// Calculate X position
			setvarvar TEMP SPAWN_ORIGANG
			sin TEMP2 TEMP
			divvar TEMP2 512
			
			// Set X position
			getactor[THISACTOR].x TEMP
			ifvare TEMP3 1 // Check barrel
			{
				subvarvar TEMP TEMP2
			}
			else
			{
				addvarvar TEMP TEMP2
			}
			setactor[THISACTOR].x TEMP
			
			// Calculate Y position
			setvarvar TEMP SPAWN_ORIGANG
			addvar TEMP 1024
			cos TEMP2 TEMP
			divvar TEMP2 512
			
			// Set Y position
			getactor[THISACTOR].y TEMP
			ifvare TEMP3 1 // Check barrel
			{
				subvarvar TEMP TEMP2
			}
			else
			{
				addvarvar TEMP TEMP2
			}
			setactor[THISACTOR].y TEMP
			
			ifvare COOP GM_ROIDMATCH
			{
				setprojectile[DEVASTATORMISSILE].velmult 2
			}
		}
		else ifspawnedby BOSS5
		{
			state boss_projectile_offset
		}
		else ifspawnedby BOSS2
		{
			state boss_projectile_offset
		}
		break
	}
	
	getactor[THISACTOR].picnum TEMP
	switch TEMP	
		case JIBS1:
		case JIBS2:
		case JIBS3:
		case JIBS4:
		case JIBS5:
		case HEADJIB1:
        case LEGJIB1:
        case ARMJIB1:
        case LIZMANHEAD1:
        case LIZMANARM1:
        case LIZMANLEG1:
        case DUKELEG:
        case DUKEGUN:
        case DUKETORSO:
			setvarvar PICNUM_MEMORY TEMP
			break
			
		case PLASMABALL:
		case PLASMABALL2:
		case PLASMABALL3:
			setactor[THISACTOR].blend 255
			break
			
		case LASERLINE:
		case TRIPBOMB:
			setactor[THISACTOR].mdflags 16
			break
		
		case PIGJIB1:
			changespritestat THISACTOR 1
			break
			
		case APLAYER:
			setactor[THISACTOR].mdflags 16
			break
	endswitch
endevent

state reset_burn
	stopsound FIRE_CRACKLE
	
	ifwasweapon FREEZEBLAST
	{
		getactor[THISACTOR].extra TEMP
		ifvarg TEMP 0
		{
			setactor[THISACTOR].mdflags BURNING_RESETFLAGS
		}
	}
	else
	{
		setactor[THISACTOR].mdflags BURNING_RESETFLAGS
	}
	
	ifactor APLAYER
	{
		setvar STOP_BURNING 0
	}
	
	setvar BURNING_RESETFLAGS -1
	setvar BURNING_TICS 0
	setvar BURNING_INFLICTOR -1
ends

defstate burning_logic
	ifvarg BURNING_TICS 0
	{
		ifinwater { state reset_burn break }
		ifinspace { state reset_burn break }
		ifwasweapon FREEZEBLAST { state reset_burn break }
		
		findnearsprite3d TOILETWATER 800 TEMP
		ifvarn TEMP -1 { state reset_burn break }
		
		getactor[THISACTOR].extra TEMP
		ifvarl TEMP 1 { state reset_burn break }
		
		ifactor APLAYER
		{
			ifvare STOP_BURNING 1 { state reset_burn break }
			palfrom 16 64 8 0
		}
		
		// Check if on water surface
		getsector[THISACTOR].lotag TEMP
		ifvare TEMP 1
		{
			// TEMP = X
			// TEMP2 = Y
			// TEMP3 = Sector Number
			getactor[THISACTOR].x TEMP
			getactor[THISACTOR].y TEMP2
			updatesector TEMP TEMP2 TEMP3
			
			// Set TEMP to florz
			getflorzofslope TEMP3 TEMP TEMP2 TEMP
			subvar TEMP 512 // Subtract height
			
			getactor[THISACTOR].z TEMP2
			
			ifvarvarg TEMP2 TEMP // Touching floor?
			{
				state reset_burn
				break
			}
		}
		
		// Burn sound
		soundonce FIRE_CRACKLE
		
		setvarvar TEMP BURNING_TICS
		modvar TEMP 2
		ifvare TEMP 0
		{
			state spawn_random_fire
		}
		
		// Damage every 6 tics
		setvarvar TEMP BURNING_TICS
		modvar TEMP 6
		ifvare TEMP 0
		{
			setvar STATE_PARAM1 3
			setvarvar STATE_PARAM2 THISACTOR
			setvar STATE_PARAM3 FIREBALL
			setvar STATE_PARAM4 0
			state apply_damage
			setactor[THISACTOR].htowner BURNING_INFLICTOR // Override attack owner, since we're technically doing this to ourselves.
		}
		
		subvar BURNING_TICS 1
		
		ifvare BURNING_TICS 0
		{
			state reset_burn
			break
		}
	}
ends

state plasma_spread
	addvar EXTRA_MEMORY 1
	ifvarg EXTRA_MEMORY 5
	{
		ifactor PLASMABALL setvar PICNUM_MEMORY PLASMABALL2
		else ifactor PLASMABALL2 setvar PICNUM_MEMORY PLASMABALL3
		
		getactor[THISACTOR].x SPAWN_ORIGX
		getactor[THISACTOR].y SPAWN_ORIGY
		getactor[THISACTOR].z SPAWN_ORIGZ
		getactor[THISACTOR].htbposx DEST_X
		getactor[THISACTOR].htbposy DEST_Y
		getactor[THISACTOR].htbposz DEST_Z
		getactor[THISACTOR].ang SPAWN_ORIGANG
		getactor[THISACTOR].zvel SPAWN_ORIGZVEL
		getactor[THISACTOR].owner TEMP2 // Do NOT overwrite!
		
		randvar TEMP3 16
		subvar TEMP3 8
		addvarvar SPAWN_ORIGANG TEMP3
		
		randvar TEMP3 512
		subvar TEMP3 256
		addvarvar SPAWN_ORIGZVEL TEMP3
			
		eshootvar PICNUM_MEMORY
		setvarvar TEMP SPAWN_ORIGANG
		addvar TEMP PLASMARIFLE_X_SPREAD
		setactor[RETURN].ang TEMP
		setactor[RETURN].x SPAWN_ORIGX
		setactor[RETURN].y SPAWN_ORIGY
		setactor[RETURN].z SPAWN_ORIGZ
		setactor[RETURN].htbposx DEST_X
		setactor[RETURN].htbposy DEST_Y
		setactor[RETURN].htbposz DEST_Z
		setactor[RETURN].zvel SPAWN_ORIGZVEL
		setactor[RETURN].owner TEMP2
		setvar RETURN 0
			
		eshootvar PICNUM_MEMORY
		setvarvar TEMP SPAWN_ORIGANG
		subvar TEMP PLASMARIFLE_X_SPREAD
		setactor[RETURN].ang TEMP
		setactor[RETURN].x SPAWN_ORIGX
		setactor[RETURN].y SPAWN_ORIGY
		setactor[RETURN].z SPAWN_ORIGZ
		setactor[RETURN].htbposx DEST_X
		setactor[RETURN].htbposy DEST_Y
		setactor[RETURN].htbposz DEST_Z
		setactor[RETURN].zvel SPAWN_ORIGZVEL
		setactor[RETURN].owner TEMP2
		setvar RETURN 0
			
		eshootvar PICNUM_MEMORY
		setvarvar TEMP SPAWN_ORIGZVEL
		addvar TEMP PLASMARIFLE_Y_SPREAD
		setactor[RETURN].zvel TEMP
		setactor[RETURN].x SPAWN_ORIGX
		setactor[RETURN].y SPAWN_ORIGY
		setactor[RETURN].z SPAWN_ORIGZ
		setactor[RETURN].htbposx DEST_X
		setactor[RETURN].htbposy DEST_Y
		setactor[RETURN].htbposz DEST_Z
		setactor[RETURN].ang SPAWN_ORIGANG
		setactor[RETURN].owner TEMP2
		setvar RETURN 0
			
		eshootvar PICNUM_MEMORY
		setvarvar TEMP SPAWN_ORIGZVEL
		subvar TEMP PLASMARIFLE_Y_SPREAD
		setactor[RETURN].zvel TEMP
		setactor[RETURN].x SPAWN_ORIGX
		setactor[RETURN].y SPAWN_ORIGY
		setactor[RETURN].z SPAWN_ORIGZ
		setactor[RETURN].htbposx DEST_X
		setactor[RETURN].htbposy DEST_Y
		setactor[RETURN].htbposz DEST_Z
		setactor[RETURN].ang SPAWN_ORIGANG
		setactor[RETURN].owner TEMP2
		setvar RETURN 0
		
		// Center shot
		eshootvar PICNUM_MEMORY
		setactor[RETURN].x SPAWN_ORIGX
		setactor[RETURN].y SPAWN_ORIGY
		setactor[RETURN].z SPAWN_ORIGZ
		setactor[RETURN].htbposx DEST_X
		setactor[RETURN].htbposy DEST_Y
		setactor[RETURN].htbposz DEST_Z
		setactor[RETURN].ang SPAWN_ORIGANG
		setactor[RETURN].zvel SPAWN_ORIGZVEL
		setactor[RETURN].owner TEMP2
		setvar RETURN 0
		
		changespritestat THISACTOR 2
		killit
	}
ends

onevent EVENT_PREGAME
	ifvare PENETRATED 1
	{
		getactor[THISACTOR].cstat TEMP
		orvar TEMP 256
		setactor[THISACTOR].cstat TEMP
		setvar PENETRATED 0
	}
	
	ifactor WATERDRIP
	{
		getactor[THISACTOR].htg_t 1 EXTRA_MEMORY
	}
endevent

onevent EVENT_GAME
	state burning_logic
	ifactor WATERDRIP
	{
		getactor[THISACTOR].htg_t 1 TEMP
		ifvarvarn TEMP EXTRA_MEMORY
		ifvare EXTRA_MEMORY 0
		{
			getactor[THISACTOR].pal PAL_MEMORY
			getactor[THISACTOR].cstat CSTAT_MEMORY
			getactor[THISACTOR].shade TEMP3
			getactor[THISACTOR].htfloorz SPAWN_ORIGZ
			subvar CSTAT_MEMORY 32768
			espawn WATERDRIPSPLASH_FIXED
			setactor[RETURN].pal PAL_MEMORY
			setactor[RETURN].cstat CSTAT_MEMORY
			setactor[RETURN].shade TEMP3
			setactor[RETURN].z SPAWN_ORIGZ
			setvar RETURN 0
		}
		break
	}
	
	ifactor SCRAP1
	ifspawnedby BLIMP
	{
		state blimp_hack
		break
	}
	
	getactor[THISACTOR].picnum TEMP	
	switch TEMP
		case TRIPBOMB:
			getactor[THISACTOR].cstat TEMP2
			ifvare TEMP2 16
			{
				cstator 256
				setactor[THISACTOR].htflags 136
			}
			break
		case SHRINKSPARK:
			cstator 2
			setactor[THISACTOR].blend 255
			
			espawn SHRINKERTRAIL
			getactor[THISACTOR].x TEMP
			randvar TEMP2 128
			subvar TEMP2 64
			addvarvar TEMP TEMP2
			setactor[RETURN].x TEMP
			
			getactor[THISACTOR].y TEMP
			randvar TEMP2 128
			subvar TEMP2 64
			addvarvar TEMP TEMP2
			setactor[RETURN].y TEMP
			
			getactor[THISACTOR].z TEMP
			randvar TEMP2 2048
			subvar TEMP2 1024
			addvarvar TEMP TEMP2
			setactor[RETURN].z TEMP
			
			getactor[THISACTOR].htbposx TEMP
			setactor[RETURN].htbposx TEMP
			
			getactor[THISACTOR].htbposy TEMP
			setactor[RETURN].htbposy TEMP
			
			getactor[THISACTOR].htbposz TEMP
			setactor[RETURN].htbposz TEMP
			setvar RETURN 0
			break
		
		case PLASMABALL:
		case PLASMABALL2:
			state plasma_spread
			break
			
		case RESPAWNMARKERRED:
		case RESPAWNMARKERYELLOW:
		case RESPAWNMARKERGREEN:
			getactor[THISACTOR].owner TEMP
			getactor[TEMP].z TEMP2
			setactor[THISACTOR].z TEMP2
			break
			
		case WATERBUBBLEMAKER:
		case WATERBUBBLE:
			getactor[THISACTOR].sectnum TEMP2
			ifvarg TEMP2 -1
			ifvarand SECTOR_TYPES[TEMP2] SECTORTYPE_SPACE
			{
				killit
			}
			break
			
		case JIBS1:
		case JIBS2:
		case JIBS3:
		case JIBS4:
		case JIBS5:
		case DUKETORSO:
		case DUKELEG:
			addvar EXTRA_MEMORY 1 // Timer
			setvarvar TEMP EXTRA_MEMORY
			
			ifvarg Numsprites 8192
				modvar TEMP 4 // Spawn blood every 4th tic
			else
				modvar TEMP 2 // Spawn blood every 2nd tic
				
			ifvare TEMP 0
			ifvarl Numsprites 12288 // Prevent "Too Many Sprites Spawned"
			{
				espawn BLOOD
				getactor[THISACTOR].pal TEMP2
				setactor[RETURN].pal TEMP2
				setvar RETURN 0
			}
			break
		case SCRAP3:
		case 2409:
		case 2410:
		case 2411:
			ifspritepal 6
			{
				cstator 128
				espawn SPURTTRAIL
				setactor[RETURN].pal 8
				getactor[THISACTOR].htbposx TEMP
				setactor[RETURN].htbposx TEMP
				getactor[THISACTOR].htbposy TEMP
				setactor[RETURN].htbposy TEMP
				getactor[THISACTOR].htbposz TEMP
				setactor[RETURN].htbposz TEMP
				setactor[RETURN].xrepeat 40
				setactor[RETURN].yrepeat 40
				setvar RETURN 0
			}
			break
	endswitch
	
	ifactor JIBS6
	{
		ifspawnedby SHOTSPARK1
		ifinwater
		{
			changespritestat THISACTOR 2
			killit
			break
		}
		
		// Check if actor was changed from one of these.
		ifvarn PICNUM_MEMORY -1
		ifvarn PICNUM_MEMORY JIBS6
		{
			state gibsound // Impact splat noise
			ifvarl Numsprites 12288 // Prevent "Too Many Sprites"
			{
				getactor[THISACTOR].pal TEMP2
				ifvare PICNUM_MEMORY JIBS1 { espawn JIBS1_ONGROUND setactor[RETURN].pal TEMP2 }
				else ifvare PICNUM_MEMORY JIBS2 { espawn JIBS2_ONGROUND setactor[RETURN].pal TEMP2 }
				else ifvare PICNUM_MEMORY JIBS3 { espawn JIBS3_ONGROUND setactor[RETURN].pal TEMP2 }
				else ifvare PICNUM_MEMORY JIBS4 { espawn JIBS4_ONGROUND setactor[RETURN].pal TEMP2 }
				else ifvare PICNUM_MEMORY JIBS5 { espawn JIBS5_ONGROUND setactor[RETURN].pal TEMP2 }
				else ifvare PICNUM_MEMORY HEADJIB1 { espawn HEADJIB1_ONGROUND setactor[RETURN].pal TEMP2 }
				else ifvare PICNUM_MEMORY LEGJIB1 { espawn LEGJIB1_ONGROUND setactor[RETURN].pal TEMP2 }
				else ifvare PICNUM_MEMORY ARMJIB1 { espawn ARMJIB1_ONGROUND setactor[RETURN].pal TEMP2 }
				else ifvare PICNUM_MEMORY DUKETORSO { espawn DUKETORSO_ONGROUND setactor[RETURN].pal TEMP2 }
				else ifvare PICNUM_MEMORY DUKEGUN { espawn DUKEGUN_ONGROUND setactor[RETURN].pal TEMP2 }
				else ifvare PICNUM_MEMORY DUKELEG { espawn DUKELEG_ONGROUND setactor[RETURN].pal TEMP2 }
			}
			
			setvar PICNUM_MEMORY -1 // Clear this so it doesn't repeat
		}
		break
	}
endevent

state set_norespawn
		ifactor SECTOREFFECTOR
		{
			setvarvar TEMP3 HITAG_MEMORY
		}
		else // MASTERSWITCH
		{
			setvarvar TEMP3 LOTAG_MEMORY
		}
		
		getactor[CURSPRITE].hitag TEMP2
		ifvarvare TEMP3 TEMP2
		{
			setactorvar[CURSPRITE].NORESPAWN 1
		}
ends

state explosive_search_iterator
	getactor[CURSPRITE].picnum TEMP
	ifvare TEMP SEENINE
	{
		state set_norespawn
	}
	else ifvare TEMP OOZFILTER
	{
		state set_norespawn
	}
		
	nextspritestat CURSPRITE LASTSPRITE
	setvarvar LASTSPRITE CURSPRITE
ends

state search_for_explosive
	headspritestat CURSPRITE 0
	setvarvar LASTSPRITE CURSPRITE
	whilevarn CURSPRITE -1
	{
		state explosive_search_iterator
	}
		
	headspritestat CURSPRITE 6
	setvarvar LASTSPRITE CURSPRITE
	whilevarn CURSPRITE -1
	{
		state explosive_search_iterator
	}
ends

onevent EVENT_LOADACTOR
	getactor[THISACTOR].hitag HITAG_MEMORY
	getactor[THISACTOR].lotag LOTAG_MEMORY
	
	getactor[THISACTOR].picnum TEMP
	switch TEMP
	case TIMEDPLATFORM:
	case CONTEXTSOUND:
	case CUSTOMTOUCHPLATE:
	case ZTELEPORTER:
	case ZTDESTINATION:
		setactor[THISACTOR].lotag 0
		break
	case ARCTRAP:
	case MAGMAVALVE:
	case ALARMSIGN:
	case LOOPTRAIN:
		setactor[THISACTOR].lotag 0
		setactor[THISACTOR].hitag 0
		break
	case WATERBUBBLEMAKER:
		setactor[THISACTOR].lotag 0
		getactor[THISACTOR].cstat CSTAT_MEMORY
		break
	case STARTWEAPONCHANGER:
		setvarvar START_WEAPON LOTAG_MEMORY
		setactor[THISACTOR].lotag 0
		break
	case BOSS2:
	case BOSS3:
	case BOSS5:
		addvar BOSS_COUNT 1 // Hack for Duke's Nightmare
		break
	endswitch
endevent

onevent EVENT_SPAWN
	ifvarg predicting 0
	{
		redefinequote 500 EVENT_SPAWN: Something attempting to spawn during prediction!
	}
	
	ifactor MASTERSWITCH
	{
		state search_for_explosive
		break
	}
	else ifactor SECTOREFFECTOR
	{
		ifvarn LOTAG_MEMORY 13
			break

		state search_for_explosive
		break
	}
	
	ifactor RESPAWNMARKERRED
	{
		setactor[THISACTOR].mdflags 16
		break
	}

	ifactor BLOODPOOL
	{
		ifspawnedby APLAYER
		{
			setactor[THISACTOR].mdflags 16
			getactor[THISACTOR].owner TEMP
			getactor[TEMP].pal TEMP2
			setactor[THISACTOR].pal TEMP2
		}
		break
	}
	
	ifactor SPURTTRAIL
	{
		sizeat 24 24
		cstat 128
		
		ifrnd 128
			cstator 4
		ifrnd 128
			cstator 8
		
		setactor[THISACTOR].mdflags 16
		setvar ANIMATE_FLAGS ANIMATE_FLAG_BLOODBRIGHT
		orvar ANIMATE_FLAGS ANIMATE_FLAG_FADEOUT
		setvar ISADULT ADULT_LOCKOUTONLY

		setvarvar ANIMATE_STARTCLOCK ANIMATE_CLOCK // Timer
		setvar ANIMATE_LIFETIME 60 // End time
		break
	}
	
	ifactor BLOOD
	{
		getactor[THISACTOR].htpicnum TEMP
		gettiledata[TEMP].gameflags TEMP
		ifvarand TEMP 262176 { } // (NULLOP) SFLAG_BADGUY | SFLAG_HARDCODED_BADGUY
		else
		{
			// Cancel out annoying hardcoded behavior.
			getactor[THISACTOR].z TEMP
			addvar TEMP 6656
			setactor[THISACTOR].z TEMP
			setactor[THISACTOR].htbposz TEMP
			
			cstat 128
		}
		
		randvar TEMP2 16
		addvar TEMP2 16
		setactor[THISACTOR].xrepeat TEMP2
		setactor[THISACTOR].yrepeat TEMP2
		
		setvar ANIMATE_FLAGS ANIMATE_FLAG_BLOODBRIGHT
		orvar ANIMATE_FLAGS ANIMATE_FLAG_FADEOUT
		orvar ANIMATE_FLAGS ANIMATE_FLAG_SCALE
		setactor[THISACTOR].mdflags 16
		
		setvarvar ANIMATE_STARTCLOCK ANIMATE_CLOCK // Start starting frame
		setvar ANIMATE_LIFETIME 72
		setvarvar ANIMATE_STARTSIZE TEMP2
		setvar ANIMATE_ENDSIZE 72
		
		ifrnd 128
			cstator 4
		ifrnd 128
			cstator 8
		
		break
	}
	
	ifactor WATERDRIP // Fix a common mistake with WATERDRIPs
	{
		getactor[THISACTOR].cstat TEMP
		ifvarand TEMP 1
		{
			subvar TEMP 1
			setactor[THISACTOR].cstat TEMP
		}
		break
	}
	
	ifactor SHELL
	{
		getactor[THISACTOR].owner TEMP
		getactor[TEMP].yvel TEMP2
		getplayer[TEMP2].curr_weapon TEMP3
		ifvare TEMP3 CHAINGUN_WEAPON
		{
			setactor[THISACTOR].mdflags 16
			setvar EXTRA_MEMORY 1
		}
		break
	}
	
	ifactor FIRESHELL
	{
		cstat 130
		setactor[THISACTOR].shade -127
		setactor[THISACTOR].blend 255
		setactor[THISACTOR].mdflags 16
		setvar ANIMATE_FLAGS ANIMATE_FLAG_ROTATE_SCALE_AND_FADE
		
		setvarvar ANIMATE_STARTCLOCK ANIMATE_CLOCK // Timer
		
		// Defaults
		setvar ANIMATE_LIFETIME 64 // End time
		setvar ANIMATE_ROTSPEED 64 // Rotational Speed
		setvar ANIMATE_STARTSIZE 0 // Start radius
		setvar ANIMATE_ENDSIZE 80 // End radius
		
		ifspawnedby TANK
		{
			setvar ANIMATE_LIFETIME 56 // End time
			setvar ANIMATE_STARTSIZE 0 // Start radius
			setvar ANIMATE_ENDSIZE 255 // End radius
		}
		break
	}
	
	ifactor EXPANDERTRAIL
	{
		cstat 130
		setactor[THISACTOR].shade -127
		setactor[THISACTOR].blend 255
		setactor[THISACTOR].mdflags 16
		setvar ANIMATE_FLAGS ANIMATE_FLAG_ROTATE_SCALE_AND_FADE
		
		setvarvar ANIMATE_STARTCLOCK ANIMATE_CLOCK // Timer
		setvar ANIMATE_LIFETIME 16 // End time
		setvar ANIMATE_ROTSPEED 0 // Rotational Speed
		
		ifspawnedby EXPANDEREXPLOSION
		{
			cstator 32
			setvar ANIMATE_STARTSIZE 16 // Start radius
			setvar ANIMATE_ENDSIZE 128 // End radius
		}
		else
		{
			setvar ANIMATE_STARTSIZE 4 // Start radius
			setvar ANIMATE_ENDSIZE 16 // End radius
		}
		break
	}
	
	ifactor SHRINKERTRAIL
	{
		cstat 130
		setactor[THISACTOR].shade -127
		setactor[THISACTOR].blend 255
		setactor[THISACTOR].mdflags 16
		setvar ANIMATE_FLAGS ANIMATE_FLAG_ROTATE_SCALE_AND_FADE
		
		setvarvar ANIMATE_STARTCLOCK ANIMATE_CLOCK // Timer
		setvar ANIMATE_LIFETIME 32 // End time
		setvar ANIMATE_ROTSPEED 0 // Rotational Speed
		
		setvar ANIMATE_STARTSIZE 16 // Start radius
		setvar ANIMATE_ENDSIZE 0 // End radius
		
		break
	}
	
	ifactor EXPLOSION2
	{
		cstator 2
		setactor[THISACTOR].blend 255 // Additive Blend
		break
	}
	
	ifactor EXPLOSION2BOT
	{
		cstator 2
		setactor[THISACTOR].blend 255 // Additive Blend
		break
	}
	
	ifactor WATERBUBBLEMAKER
	{
		getactor[THISACTOR].pal PAL_MEMORY
		break
	}
	
	ifactor FIRELASER
	{
		cstator 2
		setactor[THISACTOR].blend 255
		break
	}
	
	ifactor BOUNCEMINE
	{
		setactor[THISACTOR].mdflags 16
		break
	}
	
	ifactor FRAMEEFFECT1
	{
		setactor[THISACTOR].mdflags 16
		break
	}
	
	getactor[THISACTOR].picnum PICNUM_MEMORY
	getactor[THISACTOR].xrepeat XREPEAT_MEMORY
	getactor[THISACTOR].yrepeat YREPEAT_MEMORY
	getactor[THISACTOR].clipdist CLIPDIST_MEMORY
	getactor[THISACTOR].extra EXTRA_MEMORY
	getactor[THISACTOR].cstat CSTAT_MEMORY
	getactor[THISACTOR].pal PAL_MEMORY
	getactor[THISACTOR].statnum STATNUM_MEMORY
	getactor[THISACTOR].sectnum SECTNUM_MEMORY
	getactor[THISACTOR].x SPAWN_ORIGX
	getactor[THISACTOR].y SPAWN_ORIGY
	getactor[THISACTOR].z SPAWN_ORIGZ
	getactor[THISACTOR].ang SPAWN_ORIGANG
	
	getactor[THISACTOR].picnum TEMP
	ifvare VOLUME 4 // Striker's Maps
	ifvare LEVEL 7 // Burning Memory
	{
		switch TEMP
			case 3591: // Alien Slime/Tentacles
			case 5376:
			case 5377:
			case 5378:
			case 5379:
			case 5406: // Hanging slime/blood
			case 5407:
			case 5408:
			case 5409:
				getactor[THISACTOR].htflags TEMP2
				orvar TEMP2 64
				setactor[THISACTOR].htflags TEMP2
				break
		endswitch
	}
	
	switch TEMP
		// XXX tiles (Hide if XXX content is off)
		case FLESHLIGHT:
		case SHARONM2:
		case LIRUANIM:
		case VIBRATOR:
		case BD_SOFIA:
		case SHARONMANIM:
		case FREYACRESCENT:
		case ROUGESPREAD:
		case COCOANIM:
		case RENARIDE:
		case COMMUNITY_XXX01:
		case IMPTAN:
		case RUBBER:
		case KRYSTALANIM:
		case KRYSTALXFOX:
			setactor[THISACTOR].mdflags 16
			setvar ISADULT ADULT_HIDE
			break
		
		// XXX tiles (Have XXX version if XXX content is on, or clean version if off.)
		case EXOTICA:
		case FEMPIC5:
		case FEMPIC6:
		case FEMPIC7:
		case FEMMAG2:
		case STRIPPERFLASH:
		case HOOKERFLASH:
		case FEM1:
		case FEM3:
		case FEM4:
		case FEM5:
		case FEM6:
		case FEM7:
		case FEM10:
		case PIRATE1A:
		case PIRATE3A:
		case TOUGHGAL:
		case NAKED1:
		case WOMAN:
		case 1330:
		case 4498:
		case 4865:
		case 4955:
		case GEECKU:
		case GEECKU2:
		case MIKHAILA:
		case MIKHAILA2:
		case CHAMPAGNE:
		case CHAMPAGNE2:
		case STRIKER:
		case STRIKERXHELEN:
		case HENTAIANIM:
		case PUSSYGRIND:
		case DAWNANIM:
		case SALLYANIM:
		case SHARONM:
		case DILDO:
			setactor[THISACTOR].mdflags 16
			setvar ISADULT ADULT_SWAP
			break
			
		// Misc Tiles
		case TRIPBOMB:
			setactor[THISACTOR].mdflags 16
			break
			
		case FOOTPRINTS:
		case FOOTPRINTS2:
		case FOOTPRINTS3:
		case FOOTPRINTS4:
			ifspawnedby APLAYER
			{
				setactor[THISACTOR].mdflags 16
			}
			break
		
		case WATERBUBBLEMAKER:
		case WATERBUBBLE:
			getactor[THISACTOR].sectnum TEMP2
			ifvarg TEMP2 -1
			ifvarand SECTOR_TYPES[TEMP2] SECTORTYPE_SPACE
			{
				killit
			}
			break
			
		case FIREFLY:
			ifvare MONSTERS_OFF 1
			{
				killit
			}
			
			cstator 257
			ifspawnedby FIREFLY
			{
				changespritestat THISACTOR 2
			}
			break
			
		case BOSS2:
		case BOSS3:
		case BOSS2STAYPUT:
		case BOSS3STAYPUT:
		case BOSS5:
		case BOSS5STAYPUT:
			getactor[THISACTOR].cstat TEMP
			ifvarand TEMP 16
			{
				changespritestat THISACTOR 0
			}
			else
			{
				ifvare MONSTERS_OFF 1
				{
					killit
				}
				
				cstator 257
				changespritestat THISACTOR 2
				
				ifspritepal 0
				{
					sizeat 80 80
					setactor[THISACTOR].clipdist 164
				}
				else
				{
					sizeat 40 40
					setactor[THISACTOR].clipdist 80
				}
			}
			break
	endswitch
	
	switch TEMP
		case FEM1:
		case FEM2:
		case FEM3:
		case FEM4:
		case FEM5:
		case FEM6:
		case FEM7:
		//case FEM8: // Dead, can't be saved.
		case FEM9:
		case FEM10:
		case TOUGHGAL:
		case NAKED1:
		case PODFEM1:
		case WOMAN:
		case PIRATE1A:
		case PIRATE3A:
			ifactor NAKED1
			{
				ifinwater { } // Drowned, can't be saved.
				else
				{
					addvar BABES_TOTAL 1
				}
			}
			else ifactor WOMAN
			{
				getactor[THISACTOR].sectnum TEMP
				ifvare TEMP 541 { } // Hack for E4L1
				else
				{
					addvar BABES_TOTAL 1
				}
			}
			else
			{
				addvar BABES_TOTAL 1
			}
			break
	endswitch
	
	switch COOP
		case GM_ROIDMATCH:
		case GM_INSTAGIB:
			state strip_items
			break
		default:
			break
	endswitch
endevent

onevent EVENT_ANIMATESPRITES // !UNSYNCHRONIZED!
	ifvarg QUAKE3BOB 0
	{
		setvarvar CL_TEMP1 ANIMATE_CLOCK
		addvarvar CL_TEMP1 QUAKE3BOB
		mulvar CL_TEMP1 6
		cos CL_TEMP2 CL_TEMP1
		divvar CL_TEMP2 6
		
		gettspr[THISACTOR].tsprz CL_TEMP1
		subvar CL_TEMP1 3072
		addvarvar CL_TEMP1 CL_TEMP2
		settspr[THISACTOR].tsprz CL_TEMP1
		
		ifactor RESPAWNMARKERRED { }
		else ifactor RESPAWNMARKERYELLOW { }
		else ifactor RESPAWNMARKERGREEN { }
		else
		{
			getactor[THISACTOR].ang CL_TEMP1
			setvarvar CL_TEMP2 ANIMATE_CLOCK
			shiftvarl CL_TEMP2 2
			addvarvar CL_TEMP1 CL_TEMP2
			settspr[THISACTOR].tsprang CL_TEMP1
		}
	}
	
	ifvarg ANIMATE_FLAGS 0
	{
		setvarvar ANIMATE_ELAPSEDTIME ANIMATE_CLOCK
		subvarvar ANIMATE_ELAPSEDTIME ANIMATE_STARTCLOCK
		
		ifvarand ANIMATE_FLAGS ANIMATE_FLAG_INTERPXYREPEAT
		{
			getactor[THISACTOR].xrepeat CL_TEMP1
			getactor[THISACTOR].yrepeat CL_TEMP2
			interpolate CL_TEMP1 ANIMATE_OLDXREPEAT CL_TEMP3
			interpolate CL_TEMP2 ANIMATE_OLDYREPEAT CL_TEMP4
			settspr[THISACTOR].tsprxrepeat CL_TEMP3
			settspr[THISACTOR].tspryrepeat CL_TEMP4
		}
		
		ifvarand ANIMATE_FLAGS ANIMATE_FLAG_SHIELDMOVE
		{
			getactor[OWNER].picnum CL_TEMP1
			ifvare CL_TEMP1 APLAYER
			{
				getactor[OWNER].yvel CL_TEMP1
				getplayer[CL_TEMP1].posx CL_TEMP2
				getplayer[CL_TEMP1].posy CL_TEMP3
				getplayer[CL_TEMP1].posz CL_TEMP4
				getplayer[CL_TEMP1].oposx CL_TEMP5
				getplayer[CL_TEMP1].oposy CL_TEMP6
				getplayer[CL_TEMP1].oposz CL_TEMP7
				
				 // Make shield TSPR inherit base player's interp
				interpolate CL_TEMP2 CL_TEMP5 TSPRX // X
				interpolate CL_TEMP3 CL_TEMP6 TSPRY // Y
				interpolate CL_TEMP4 CL_TEMP7 TSPRZ // Z
				
				ldistvar TSPRX TSPRY camerax cameray CL_TEMP2
				ifvarl CL_TEMP2 128
				ifvare display_mirror 0 // This should only happen if we're not drawing a mirror.
					settspr[THISACTOR].tsprxrepeat 0

				// Get interpolated offsets for shield effects
				interpolate DEST_X SPAWN_ORIGX CL_TEMP2 // X
				interpolate DEST_Y SPAWN_ORIGY CL_TEMP3 // Y
				interpolate DEST_Z SPAWN_ORIGZ CL_TEMP4 // Z
				
				addvarvar TSPRX CL_TEMP2
				addvarvar TSPRY CL_TEMP3
				addvarvar TSPRZ CL_TEMP4
				settspr[THISACTOR].tsprx TSPRX
				settspr[THISACTOR].tspry TSPRY
				settspr[THISACTOR].tsprz TSPRZ
			}
		}
		
		ifvarand ANIMATE_FLAGS ANIMATE_FLAG_ROTATE
		{
			// Apply rotation
			gettspr[THISACTOR].tsprang CL_TEMP1
			setvarvar CL_TEMP2 ANIMATE_ROTSPEED
			mulvarvar CL_TEMP2 ANIMATE_ELAPSEDTIME
			addvarvar CL_TEMP1 CL_TEMP2
			settspr[THISACTOR].tsprang CL_TEMP1
		}
		
		// ANIMATE_ELAPSEDTIME = timer
		// ANIMATE_LIFETIME = lifetime
		// ANIMATE_ROTSPEED = rotational speed
		// ANIMATE_STARTSIZE = start radius
		// ANIMATE_ENDSIZE = end radius
		ifvarand ANIMATE_FLAGS ANIMATE_FLAG_SCALE
		{
			ifvarl ANIMATE_LIFETIME 1 // lifetime < 1 is invalid.
				break
				
			// xrepeat = ((timer * (endradius - startradius)) / lifetime) + startradius;
			// Radius range
			setvarvar CL_TEMP1 ANIMATE_ENDSIZE
			subvarvar CL_TEMP1 ANIMATE_STARTSIZE
			
			// Resulting radius
			setvarvar CL_TEMP2 ANIMATE_ELAPSEDTIME
			mulvarvar CL_TEMP2 CL_TEMP1
			divvarvar CL_TEMP2 ANIMATE_LIFETIME
			addvarvar CL_TEMP2 ANIMATE_STARTSIZE
			
			ifvarg CL_TEMP2 255
				setvar CL_TEMP2 255
			ifvarl CL_TEMP2 0
				setvar CL_TEMP2 0
				
			// Set x/yrepeat
			settspr[THISACTOR].tsprxrepeat CL_TEMP2
			settspr[THISACTOR].tspryrepeat CL_TEMP2
		}
		
		ifvarand ANIMATE_FLAGS ANIMATE_FLAG_FADEOUT
		{
			ifvarl ANIMATE_LIFETIME 1 // lifetime < 1 is invalid.
				break
				
			ifvarvare ANIMATE_ELAPSEDTIME ANIMATE_LIFETIME
			{
				settspr[THISACTOR].tsprxrepeat 0
				break
			}
			
			ifvarvarg ANIMATE_ELAPSEDTIME ANIMATE_LIFETIME
			{
				settspr[THISACTOR].tsprxrepeat 0
				break
			}
		
			// Fade alpha over time
			setvarvar CL_TEMP2 ANIMATE_ELAPSEDTIME
			mulvar CL_TEMP2 256
			divvarvar CL_TEMP2 ANIMATE_LIFETIME
			
			ifvarg CL_TEMP2 255
				setvar CL_TEMP2 255
			ifvarl CL_TEMP2 0
				setvar CL_TEMP2 0

			// Set alpha
			setactor[THISACTOR].alpha CL_TEMP2
		}
		
		ifvarand ANIMATE_FLAGS ANIMATE_FLAG_BLOODBRIGHT
		{
			gettspr[THISACTOR].tsprshade CL_TEMP1
			gettspr[THISACTOR].tsprpal CL_TEMP2
			ifvare CL_TEMP2 6
				subvar CL_TEMP1 120
				
			subvar CL_TEMP1 6
			settspr[THISACTOR].tsprshade CL_TEMP1
		}
	}
	
	ifvarg BURNING_TICS 0
	{
		gettspr[THISACTOR].tsprpal CL_TEMP1
		ifvarn CL_TEMP1 4 // Avoid coloring the shadow.
		{
			setvarvar CL_TEMP1 totalclock
			shiftvarr CL_TEMP1 3
			modvar CL_TEMP1 4
			switch CL_TEMP1
				case 0:
					settspr[THISACTOR].tsprpal 111
					break
				
				case 1:
					settspr[THISACTOR].tsprpal 110
					break
					
				case 2:
					settspr[THISACTOR].tsprpal 2
					break
					
				case 3:
					settspr[THISACTOR].tsprpal 110
					break
			endswitch
			settspr[THISACTOR].tsprshade -127
		}
	}
	
	ifactor BURNTENEMY
	{
		settspr[THISACTOR].tsprpicnum PICNUM_MEMORY
		settspr[THISACTOR].tsprpal 4
		break
	}
	
	ifactor BURNEDCORPSE
	{
		gettspr[THISACTOR].tsprshade CL_TEMP1
		
		ifvarl CL_TEMP1 0
			setvar CL_TEMP1 0
			
		addvar CL_TEMP1 12
		settspr[THISACTOR].tsprshade CL_TEMP1
		break
	}
	
	ifactor APLAYER
	{
		ifvare DEMENTIA 1
		{	
			getactor[THISACTOR].xrepeat CL_TEMP1
			gettspr[THISACTOR].tsprcstat CL_TEMP2
			ifvarl CL_TEMP1 40
				orvar CL_TEMP2 2
			else
				orvar CL_TEMP2 514
			settspr[THISACTOR].tsprcstat CL_TEMP2
				
			gettspr[THISACTOR].tsprpal CL_TEMP1
			ifvare CL_TEMP1 6 // Nightvision unveils all
				break
			
			settspr[THISACTOR].tsprpal 4
		}
		break
	}
	
	ifactor SHADOWPLAYER
	{
		gettspr[THISACTOR].tsprpal CL_TEMP1
		ifvarn CL_TEMP1 6
			settspr[THISACTOR].tsprpal 4
		
		getactor[THISACTOR].yvel CL_TEMP1
		ifvarvare CL_TEMP1 myconnectindex
		{
			getplayer[myconnectindex].i CL_TEMP1
			ldist CL_TEMP2 THISACTOR CL_TEMP1
			ifvarl CL_TEMP2 4096
			{
				settspr[THISACTOR].tsprxrepeat 0
				settspr[THISACTOR].tspryrepeat 0
			}
		}
			
		break
	}
	
	// Hack to keep your own projectiles from blinding you.
	ifactor FIREBALL
	{
		getactor[THISACTOR].owner CL_TEMP1
		ldist CL_TEMP2 THISACTOR CL_TEMP1
		ifvarl CL_TEMP2 512
		{
			settspr[THISACTOR].tsprxrepeat 0
			settspr[THISACTOR].tspryrepeat 0
		}
		break
	}
	
	ifactor FIREBALLTRAIL
	{
		getactor[THISACTOR].htowner CL_TEMP1
		getactor[CL_TEMP1].owner CL_TEMP1
		ldist CL_TEMP2 THISACTOR CL_TEMP1
		ifvarl CL_TEMP2 512
		{
			settspr[THISACTOR].tsprxrepeat 0
			settspr[THISACTOR].tspryrepeat 0
		}
		break
	}
	
	ifactor PLASMATRAIL
	{
		getactor[THISACTOR].htowner CL_TEMP1
		getactor[CL_TEMP1].owner CL_TEMP1
		ldist CL_TEMP2 THISACTOR CL_TEMP1
		ifvarl CL_TEMP2 512
		{
			settspr[THISACTOR].tsprxrepeat 0
			settspr[THISACTOR].tspryrepeat 0
		}
		break
	}
	// ----
	
	ifactor BOUNCEMINE
	{
		getactor[THISACTOR].ang CL_TEMP1
		setvarvar CL_TEMP2 totalclock
		shiftvarl CL_TEMP2 3
		addvarvar CL_TEMP1 CL_TEMP2
		settspr[THISACTOR].tsprang CL_TEMP1
		break
	}
	
	ifactor FRAMEEFFECT1
	{
		gettspr[THISACTOR].tsprpicnum CL_TEMP1
		
		switch CL_TEMP1
			case 940: // BOUNCEMINE
			case 941:
			case 942:
			case 943:
			case 944:
				getactor[THISACTOR].owner CL_TEMP1
				getactor[CL_TEMP1].ang CL_TEMP1 // Inherit angle from owner.
				setvarvar CL_TEMP2 ANIMATE_CLOCK
				shiftvarl CL_TEMP2 3
				addvarvar CL_TEMP1 CL_TEMP2
				settspr[THISACTOR].tsprang CL_TEMP1
				break
		endswitch
		break
	}
	
	ifactor RESPAWNMARKERRED
	{
		getactor[THISACTOR].ang CL_TEMP1
		setvarvar CL_TEMP2 ANIMATE_CLOCK
		shiftvarl CL_TEMP2 3
		subvarvar CL_TEMP1 CL_TEMP2
		settspr[THISACTOR].tsprang CL_TEMP1
		break
	}
	
	ifactor RESPAWNMARKERYELLOW
	{
		getactor[THISACTOR].ang CL_TEMP1
		setvarvar CL_TEMP2 ANIMATE_CLOCK
		shiftvarl CL_TEMP2 4
		subvarvar CL_TEMP1 CL_TEMP2
		settspr[THISACTOR].tsprang CL_TEMP1
		break
	}
	
	ifactor RESPAWNMARKERGREEN
	{
		getactor[THISACTOR].ang CL_TEMP1
		setvarvar CL_TEMP2 ANIMATE_CLOCK
		shiftvarl CL_TEMP2 6
		subvarvar CL_TEMP1 CL_TEMP2
		settspr[THISACTOR].tsprang CL_TEMP1
		break
	}
	
	ifactor LASERLINE
	{
		switch CL_LASERCOLOR
			case 0: settspr[THISACTOR].tsprpicnum 5006 break
			case 1: settspr[THISACTOR].tsprpicnum 5009 break
			case 2: settspr[THISACTOR].tsprpicnum 5012 break
			case 3: settspr[THISACTOR].tsprpicnum 5015 break
		endswitch
		
		break
	}
	else ifactor TRIPBOMB
	{
		switch CL_LASERCOLOR
			case 1: settspr[THISACTOR].tsprpicnum 2592 break
			case 2: settspr[THISACTOR].tsprpicnum 2593 break
			case 3: settspr[THISACTOR].tsprpicnum 2594 break
		endswitch
		
		break
	}
	else ifactor SHELL
	{
		ifvare EXTRA_MEMORY 1
		{
			gettspr[THISACTOR].tsprpicnum CL_TEMP1
			switch CL_TEMP1
				case 2533: settspr[THISACTOR].tsprpicnum RIPPERSHELL1 break
				case 2534: settspr[THISACTOR].tsprpicnum RIPPERSHELL2 break
			endswitch
		}
		
		break
	}
	
	ifvarg ISADULT 0
	{
		getuserdef[].lockout CL_TEMP1
		ifvare CL_TEMP1 1
		{
			settspr[THISACTOR].tsprxrepeat 0
			break
		}
		
		ifvare CL_XXXCONTENT 1
		{
			ifvare ISADULT ADULT_SWAP
			{
				gettspr[THISACTOR].tsprpicnum CL_TEMP1
				switch CL_TEMP1
					// Clean tiles with XXX versions
					case EXOTICA: settspr[THISACTOR].tsprpicnum 5950 break // 766
					case FEMPIC5: settspr[THISACTOR].tsprpicnum 5951 break // 963
					case FEMPIC6: settspr[THISACTOR].tsprpicnum 5952 break // 964
					case FEMPIC7: settspr[THISACTOR].tsprpicnum 5953 break // 965
					case PIRATE1A: settspr[THISACTOR].tsprpicnum 5955 break
					case PIRATE3A: settspr[THISACTOR].tsprpicnum 5957 break
					case FEM10: settspr[THISACTOR].tsprpicnum 5959 break
					case 4865: settspr[THISACTOR].tsprpicnum 5960 break
					case 4866: settspr[THISACTOR].tsprpicnum 5961 break
					case 4867: settspr[THISACTOR].tsprpicnum 5962 break
					case 4868: settspr[THISACTOR].tsprpicnum 5963 break
					case 4869: settspr[THISACTOR].tsprpicnum 5964 break
					case 4870: settspr[THISACTOR].tsprpicnum 5965 break
					case WOMAN: settspr[THISACTOR].tsprpicnum 5966 break
					case FEMMAG2: settspr[THISACTOR].tsprpicnum 5969 break // 577
					case 4498: settspr[THISACTOR].tsprpicnum 5970 break
					case FEM3: settspr[THISACTOR].tsprpicnum 5971 break
					case HOOKERFLASH: settspr[THISACTOR].tsprpicnum 5973 break // 1339
					case FEM5: settspr[THISACTOR].tsprpicnum 5974 break
					case FEM4: settspr[THISACTOR].tsprpicnum 5975 break
					case 1330: settspr[THISACTOR].tsprpicnum 5980 break
					case FEM7: settspr[THISACTOR].tsprpicnum 5981 break
					case 1332: settspr[THISACTOR].tsprpicnum 5985 break
					case 1333: settspr[THISACTOR].tsprpicnum 5986 break
					case FEM6: settspr[THISACTOR].tsprpicnum 5987 break
					case NAKED1: settspr[THISACTOR].tsprpicnum 5988 break
					case 4955: settspr[THISACTOR].tsprpicnum 5989 break
				endswitch
			}
		}
		else
		{
			ifvare ISADULT ADULT_HIDE
			{
				settspr[THISACTOR].tsprxrepeat 0
				break
			}
			
			ifvare ISADULT ADULT_SWAP
			{
				gettspr[THISACTOR].tsprpicnum CL_TEMP1
				switch CL_TEMP1
					// XXX tiles with clean versions
					case DILDO: settspr[THISACTOR].tsprpicnum 3702 break
					case SHARONM: settspr[THISACTOR].tsprpicnum 4980 break
					case SALLYANIM: settspr[THISACTOR].tsprpicnum 4981 break
					case DAWNANIM: settspr[THISACTOR].tsprpicnum 4982 break
					case HENTAIANIM: settspr[THISACTOR].tsprpicnum 4983 break
					case STRIKERXHELEN: settspr[THISACTOR].tsprpicnum 4984 break
					case STRIKER: settspr[THISACTOR].tsprpicnum 4985 break
					case CHAMPAGNE: settspr[THISACTOR].tsprpicnum 4986 break
					case CHAMPAGNE2: settspr[THISACTOR].tsprpicnum 4979 break
					case MIKHAILA: settspr[THISACTOR].tsprpicnum 4987 break
					case MIKHAILA2: settspr[THISACTOR].tsprpicnum 4988 break
					case GEECKU2: settspr[THISACTOR].tsprpicnum 4989 break
					case GEECKU: settspr[THISACTOR].tsprpicnum 4990 break
					case PUSSYGRIND: settspr[THISACTOR].tsprpicnum 6155 break
				endswitch
			}
		}
		break
	}
	
	getactor[THISACTOR].picnum CL_TEMP1
	switch CL_TEMP1
		case BLOODPOOL:
			settspr[THISACTOR].tsprpicnum BLOODPOOL_PLAYER
			break
		case FOOTPRINTS:
			getactor[THISACTOR].pal CL_TEMP1
			ifvarn CL_TEMP1 0
			{
				settspr[THISACTOR].tsprpicnum BLOODY_FOOTPRINT
			}
			break
		case FOOTPRINTS2:
			getactor[THISACTOR].pal CL_TEMP1
			ifvarn CL_TEMP1 0
			{
				settspr[THISACTOR].tsprpicnum BLOODY_FOOTPRINT2
			}
			break
		case FOOTPRINTS3:
			getactor[THISACTOR].pal CL_TEMP1
			ifvarn CL_TEMP1 0
			{
				settspr[THISACTOR].tsprpicnum BLOODY_FOOTPRINT3
			}
			break
		case FOOTPRINTS4:
			getactor[THISACTOR].pal CL_TEMP1
			ifvarn CL_TEMP1 0
			{
				settspr[THISACTOR].tsprpicnum BLOODY_FOOTPRINT4
			}
			break
	endswitch
endevent

onevent EVENT_CHEATGETBOOT
	setvar FLAMETHROWER_AMMO MAXFREEZEAMMO
	setvar FREEZETHROWER_AMMO MAXFLAMETHROWERAMMO
	
	setvar RIPPER_AMMO MAXCHAINGUNAMMO
	setvar PLASMARIFLE_AMMO MAXPLASMARIFLEAMMO
	
	setvar RPG_AMMO MAXRPGAMMO
	setvar RAILGUN_AMMO MAXRAILGUNAMMO
	
	setvar DEVASTATOR_AMMO MAXDEVISTATORAMMO
	setvar DFG_AMMO MAXDFGAMMO
	
	// Give Primaries
	setvar STATE_PARAM2 WEAP_PRIMARY
	setvar STATE_PARAM3 1
	
	setvar STATE_PARAM1 SHOTGUN_WEAPON
	state set_have_weapon
	
	setvar STATE_PARAM1 CHAINGUN_WEAPON
	state set_have_weapon
	
	setvar STATE_PARAM1 RPG_WEAPON
	state set_have_weapon
	
	setvar STATE_PARAM1 DEVISTATOR_WEAPON
	state set_have_weapon
	
	setvar STATE_PARAM1 FREEZE_WEAPON
	state set_have_weapon
	// --------------------------
	
	// Give Secondaries
	setvar STATE_PARAM2 WEAP_SECONDARY
	setvar STATE_PARAM3 1
	
	setvar STATE_PARAM1 SHOTGUN_WEAPON
	state set_have_weapon
	
	setvar STATE_PARAM1 CHAINGUN_WEAPON
	state set_have_weapon
	
	setvar STATE_PARAM1 RPG_WEAPON
	state set_have_weapon
	
	setvar STATE_PARAM1 DEVISTATOR_WEAPON
	state set_have_weapon
	
	setvar STATE_PARAM1 FREEZE_WEAPON
	state set_have_weapon
	// --------------------------
endevent

state reset_weapons
	// Clear Subweapons
	setvar STATE_PARAM1 1
	setvar STATE_PARAM3 0 // Weapon not owned
	whilevarn STATE_PARAM1 11 // Cycle through all
	{
		setvar STATE_PARAM2 WEAP_PRIMARY
		state set_have_weapon
		
		setvar STATE_PARAM2 WEAP_SECONDARY
		state set_have_weapon
		
		setvar STATE_PARAM2 WEAP_PRIMARY
		state set_weapontype
		
		addvar STATE_PARAM1 1
	}
	
	// Clear Ammo
	setvar FLAMETHROWER_AMMO 0
	setvar FREEZETHROWER_AMMO 0
	setvar RIPPER_AMMO 0
	setvar PLASMARIFLE_AMMO 0
	setvar RPG_AMMO 0
	setvar RAILGUN_AMMO 0
	setvar DEVASTATOR_AMMO 0
	setvar DFG_AMMO 0
	
	ifvarg START_WEAPON -1
	{
		setplayer[THISACTOR].gotweapon PISTOL_WEAPON 0
		
		ifvarl START_WEAPON SSG_WEAPON
		{
			setplayer[THISACTOR].gotweapon START_WEAPON 1
			
			getplayer[THISACTOR].max_ammo_amount START_WEAPON TEMP
			divvar TEMP 2
			setplayer[THISACTOR].ammo_amount START_WEAPON TEMP
			
			ifvare START_WEAPON RPG_WEAPON
				setvarvar RPG_AMMO TEMP
			else ifvare START_WEAPON CHAINGUN_WEAPON
				setvarvar RIPPER_AMMO TEMP
			else ifvare START_WEAPON FREEZE_WEAPON
				setvarvar FREEZETHROWER_AMMO TEMP
			else ifvare START_WEAPON DEVISTATOR_WEAPON
				setvarvar DEVASTATOR_AMMO TEMP
			
			setvarvar STATE_PARAM1 START_WEAPON
			setvar STATE_PARAM2 WEAP_PRIMARY
			setvar STATE_PARAM3 1
			state set_have_weapon
		
			setplayer[THISACTOR].curr_weapon START_WEAPON
		}
	}
ends

onevent EVENT_RESETWEAPONS
	state reset_weapons
endevent

onevent EVENT_RESETPLAYER
	ifmultiplayer
	{
		ifvarand gametype_flags 32768 { }
		else
		{
			state reset_weapons
		}
	}
	else
	{
		getplayer[THISACTOR].gm TEMP
		ifvarand TEMP 8 { } // EOL?
		else
		{
			state reset_weapons
		}
	}
	
	ifvare DEMENTIA 1
	{
		setvar TEMP4 0
		
		ifrnd 4
		ifrnd 128
		{
			setvar TEMP4 1
		}
		
		ifvare HITAG_MEMORY 666
			setvar TEMP4 1
		
		ifvare TEMP4 1
		{
			ifvarg APPARITION_LAIRSPRITEID -1
			{
				setvar HITAG_MEMORY 0
				getactor[APPARITION_LAIRSPRITEID].x TEMP
				setplayer[THISACTOR].posx TEMP
				setactor[THISACTOR].x TEMP
				
				getactor[APPARITION_LAIRSPRITEID].y TEMP
				setplayer[THISACTOR].posy TEMP
				setactor[THISACTOR].y TEMP
				
				getactor[APPARITION_LAIRSPRITEID].z TEMP
				setplayer[THISACTOR].posz TEMP
				setactor[THISACTOR].z TEMP
				
				getactor[APPARITION_LAIRSPRITEID].ang TEMP
				setplayer[THISACTOR].ang TEMP
				setactor[THISACTOR].ang TEMP
				
				getactor[APPARITION_LAIRSPRITEID].sectnum TEMP
				setplayer[THISACTOR].cursectnum TEMP
				changespritesect THISACTOR TEMP
				
				quote 198
			}
		}
	}
	
	setvar SHIELD_HEALTH 0
	setvar SHIELD_TYPE 0
	setvar SHIELD_ACTOR -1
	
	setplayer[THISACTOR].sound_pitch 0
endevent

onevent EVENT_USEMEDKIT
	ifvarn predicting 0 // Desync prevention
		break
		
	getplayer[THISACTOR].firstaid_amount TEMP
	ifvarg TEMP 0
	{
		ifvarg BURNING_TICS 0
		{
			getactor[THISACTOR].extra TEMP
			ifvarl TEMP 100
			{
				palfrom 48 0 0 48
				state stop_player_burn
			}
		}
	}
endevent

onevent EVENT_STRAFELEFT
ifp pjetpack
{
	getplayer[THISACTOR].rotscrnang TEMP
	
	ifp prunning
		addvar TEMP 6
	else
		addvar TEMP 3
	
	ifvarg TEMP 45
	{
		setvar TEMP 45
	}
	setplayer[THISACTOR].rotscrnang TEMP 
}
endevent

onevent EVENT_STRAFERIGHT
ifp pjetpack
{
	getplayer[THISACTOR].rotscrnang TEMP
	
	ifp prunning
		subvar TEMP 6
	else
		subvar TEMP 3
		
	ifvarl TEMP -45
	{
		setvar TEMP -45
	}
	setplayer[THISACTOR].rotscrnang TEMP 
}
endevent

state jetpack_turn
	getplayer[THISACTOR].rotscrnang TEMP	
	getinput[THISACTOR].avel TEMP2
	mulvar TEMP2 -1
	divvar TEMP2 4
	addvarvar TEMP TEMP2
	
	ifvarl TEMP -45
	{
		setvar TEMP -45
	}
	else ifvarg TEMP 45
	{
		setvar TEMP 45
	}
	
	setplayer[THISACTOR].rotscrnang TEMP 
ends

onevent EVENT_TURNLEFT
	ifp pjetpack
	{
		state jetpack_turn
	}
	else ifinwater
	{
		state jetpack_turn
	}
endevent

onevent EVENT_TURNRIGHT
	ifp pjetpack
	{
		state jetpack_turn
	}
	else ifinwater
	{
		state jetpack_turn
	}
endevent

onevent EVENT_GETLOADTILE // !UNSYNCHRONIZED!
	ifvare COOP GM_ROIDMATCH
	{
		setvar RETURN ROIDLOAD
		break
	}
	
	ifvare VOLUME 4 // Striker's Maps
	ifvare LEVEL 7 // Burning Memory
	{
		setvar RETURN 6656
		break
	}
endevent

onevent EVENT_USESTEROIDS
	getplayer[THISACTOR].steroids_amount TEMP
	ifvare TEMP 400
	{
		state roids_voices
	}
endevent

//definegamefuncname 13 Toggle_XXX_Content
//definegamefuncname 14 Change_Tripmine_Color
defstate client_keys
	ifvarvarn screenpeek myconnectindex // Must be done by the local player.
		break
		
	getactor[THISACTOR].yvel CL_TEMP1
	ifvarvarn CL_TEMP1 myconnectindex // Not our player index? Bail.
		break
		
	getinput[THISACTOR].bits CL_TEMP1
	ifvarand CL_TEMP1 64
	{
		ifvarand CL_OLDKEYS 64 { }
		else
		{
			ifvare CL_XXXCONTENT 0
			{
				redefinequote 500 ^12XXX Content: ^08ON
				userquote 500
				setvar CL_XXXCONTENT 1
				savegamevar CL_XXXCONTENT
			}
			else
			{
				redefinequote 500 ^12XXX Content: ^02OFF
				userquote 500
				setvar CL_XXXCONTENT 0
				savegamevar CL_XXXCONTENT
			}
		}
	}
	else ifvarand CL_TEMP1 128
	{
		ifvarand CL_OLDKEYS 128 { }
		else
		{
			ifvare CL_LASERCOLOR 0
			{
				redefinequote 500 ^12Tripmine Laser Color: ^08Green
				userquote 500
				setvar CL_LASERCOLOR 1
				savegamevar CL_LASERCOLOR
			}
			else ifvare CL_LASERCOLOR 1
			{
				redefinequote 500 ^12Tripmine Laser Color: ^01Blue
				userquote 500
				setvar CL_LASERCOLOR 2
				savegamevar CL_LASERCOLOR
			}
			else ifvare CL_LASERCOLOR 2
			{
				redefinequote 500 ^12Tripmine Laser Color: ^07Yellow
				userquote 500
				setvar CL_LASERCOLOR 3
				savegamevar CL_LASERCOLOR
			}
			else ifvare CL_LASERCOLOR 3
			{
				redefinequote 500 ^12Tripmine Laser Color: ^02Red
				userquote 500
				setvar CL_LASERCOLOR 0
				savegamevar CL_LASERCOLOR
			}
		}
	}
	getinput[THISACTOR].bits CL_OLDKEYS
ends

onevent EVENT_DISPLAYSTART // !UNSYNCHRONIZED!
	setvarvar clock_diff totalclock
	subvarvar clock_diff clock_last
	setvarvar clock_last totalclock
	
	getuserdef[].pause_on CL_TEMP1
	ifvarn CL_TEMP1 1
		addvarvar ANIMATE_CLOCK clock_diff
		
	state client_keys
endevent

defstate apparition_screenfx
	ifvarg APPARITION_SPRITEID -1
	{
		dist CL_TEMP1 APPARITION_SPRITEID THISACTOR
		getactor[APPARITION_SPRITEID].cstat CL_TEMP2
			
		ifvarand CL_TEMP2 32768
			setvar CL_TEMP1 9999999
				
		ifvarl CL_TEMP1 4096
		{
			shiftvarr CL_TEMP1 4
			setvar CL_TEMP9 0
			addvarvar CL_TEMP9 CL_TEMP1
				
			ifvarl CL_TEMP9 256
				rotatespritea 0 0 65536 0 6764 0 0 1042 CL_TEMP9 0 0 xdim ydim
					
			ifvarl CL_TEMP9 1
				setvar CL_TEMP9 1
			
			setvarvar CL_TEMP8 totalclock
			shiftvarl CL_TEMP8 3
			sin CL_TEMP8 CL_TEMP8
			shiftvarr CL_TEMP8 3
			divvarvar CL_TEMP8 CL_TEMP9
			setplayer[THISACTOR].rotscrnang CL_TEMP8
		}
	}
ends

onevent EVENT_DISPLAYMENUREST // Version display. !UNSYNCHRONIZED!
	screentext 3072 316 180 65536 0 0 499 -127 6 536 0 3 5 1 1 8193 0 0 xdim ydim 
	
	switch CL_LASERCOLOR
		case 0:
			redefinequote 500 ^12Tripmine Laser Color: ^02Red
			break
		case 1:
			redefinequote 500 ^12Tripmine Laser Color: ^08Green
			break
		case 2:
			redefinequote 500 ^12Tripmine Laser Color: ^01Blue
			break
		case 3:
			redefinequote 500 ^12Tripmine Laser Color: ^07Yellow
			break
	endswitch
	
	screentext 3072 8 180 65536 0 0 500 -127 6 280 0 3 5 1 1 8192 0 0 xdim ydim
	
	ifvare CL_XXXCONTENT 1
		redefinequote 500 ^12XXX Content: ^08ON
	else
		redefinequote 500 ^12XXX Content: ^02OFF
	
	screentext 3072 8 174 65536 0 0 500 -127 6 280 0 3 5 1 1 8192 0 0 xdim ydim
endevent

onevent EVENT_DISPLAYROOMS // !UNSYNCHRONIZED!
	state handle_recoil
	state handle_shake_display
endevent

onevent EVENT_DOQUAKE
	setvarvar CL_TEMP1 totalclock
	mulvar CL_TEMP1 150
	
	setvar CL_TEMP3 10 // Intensity
	mulvarvar CL_TEMP3 RETURN
	
	ifvarg CL_TEMP3 384 // Clamp
		setvar CL_TEMP3 384
		
	sin CL_TEMP2 CL_TEMP1
	mulvarvar CL_TEMP2 CL_TEMP3
	shiftvarr CL_TEMP2 14
	addvarvar cameraz CL_TEMP2
	
	cos CL_TEMP2 CL_TEMP1
	mulvarvar CL_TEMP2 CL_TEMP3
	shiftvarr CL_TEMP2 18
	addvarvar camerax CL_TEMP2
		
	sin CL_TEMP2 CL_TEMP1
	mulvarvar CL_TEMP2 CL_TEMP3
	shiftvarr CL_TEMP2 5
	addvarvar cameraq16ang CL_TEMP2

	cos CL_TEMP2 CL_TEMP1
	mulvarvar CL_TEMP2 CL_TEMP3
	shiftvarr CL_TEMP2 5
	addvarvar cameraq16horiz CL_TEMP2
	
	setvar RETURN 0
endevent

state do_active_maphacks
	// **** ACTIVE MAPHACKS ***
	// These are what I like to call active maphacks.
	// These use heuristics to detect unmodified stock maps, and add new monsters and items.
	ifvare VOLUME 3 // Episode 4
	{
		switch LEVEL
			case 1: // Duke Burger
				setvar CL_TEMP1 673
				getactor[CL_TEMP1].picnum CL_TEMP2
				getactor[CL_TEMP1].sectnum CL_TEMP3
				getactor[CL_TEMP1].ang CL_TEMP4
				ifvare CL_TEMP2 FOOTPRINTS2
				ifvare CL_TEMP3 42
				ifvare CL_TEMP4 1536
				{
					userquote 200
					
					espawn FLAMETHROWERSPRITE
					setactor[RETURN].htpicnum FLAMETHROWERSPRITE
					setactor[RETURN].x 34688
					setactor[RETURN].y 24768
					setactor[RETURN].z -16384
					setactor[RETURN].ang 512
					setactor[RETURN].cstat 0
					setactor[RETURN].pal 0
					setactor[RETURN].xrepeat 32
					setactor[RETURN].yrepeat 32
					setactor[RETURN].owner RETURN
					setactor[RETURN].htowner RETURN
					changespritesect RETURN 159
					setvar RETURN 0
					
					espawn FLAMETHROWERAMMO
					setactor[RETURN].htpicnum FLAMETHROWERAMMO
					setactor[RETURN].x 34688
					setactor[RETURN].y 25344
					setactor[RETURN].z -16384
					setactor[RETURN].ang 640
					setactor[RETURN].cstat 0
					setactor[RETURN].pal 0
					setactor[RETURN].xrepeat 32
					setactor[RETURN].yrepeat 32
					setactor[RETURN].owner RETURN
					setactor[RETURN].htowner RETURN
					changespritesect RETURN 159
					setvar RETURN 0
				}
			break
		endswitch
	}
	
	// Keep these at the bottom.
	ifvare VOLUME 4 // Striker's Maps
	ifvare LEVEL 7 // Burning Memory
	{
		inittimer 90
		orvar DMFLAGS 256 // DMFLAG_NOPLAYERIDS
		orvar DMFLAGS 1024 // DMFLAG_NOWEAPONICONS
		setvar DEMENTIA 1
		break
	}
	
	// Map Defaults
	setvar DEMENTIA 0
	inittimer 120 // Needed to reset the timer.
ends

state find_next_locator
	// STATE_TEMP1 = CURSPRITE
	// STATE_TEMP2 = Got Sprite?
	setvar STATE_TEMP2 0
	
	headspritestat STATE_TEMP1 STAT_LOCATOR
	whilevarn STATE_TEMP1 -1
	{
		ifvarvarn CURSPRITE STATE_TEMP1
		{
			// Hitag = Path Num
			// Lotag = Place along path
			
			getactor[CURSPRITE].hitag TEMP
			getactor[STATE_TEMP1].hitag TEMP2
			
			ifvarvarg TEMP NUM_PATHS
				setvarvar NUM_PATHS TEMP
			
			ifvarvare TEMP TEMP2 // On the same path?
			{
				getactor[CURSPRITE].lotag TEMP2
				getactor[STATE_TEMP1].lotag TEMP3
				addvar TEMP2 1

				ifvarvare TEMP2 TEMP3 // This sprite next in the sequence?
				{
					//redefinequote 500 Locator %d with hitag %d found %d with lotag %d
					//qsprintf 500 500 CURSPRITE TEMP STATE_TEMP1 TEMP3
					//userquote 500
					
					setactorvar[CURSPRITE].EXTRA_MEMORY STATE_TEMP1
					setvar STATE_TEMP2 1
					setvar STATE_TEMP1 -1
					break
				}
			}
		}
		
		nextspritestat STATE_TEMP1 STATE_TEMP1
	}
	
	ifvarn STATE_TEMP2 1 // Didn't find anything, set our var to -1
		setactorvar[CURSPRITE].EXTRA_MEMORY -1
ends

onevent EVENT_PRELEVEL
	setvar START_WEAPON -1
	setvar BABES_RESCUED 0
	setvar BABES_TOTAL 0
	setvar BABES_ALLSAVED 0
	setvar LEVEL_LOADED 0
	
	setvar TEMP 0
	whilevarn TEMP MAXSECTORS
	{
		setarray SECTOR_TYPES[TEMP] 0
		setarray SECTOR_JUMPX[TEMP] 0
		setarray SECTOR_JUMPY[TEMP] 0
		setarray SECTOR_JUMPZ[TEMP] 0
		addvar TEMP 1
	}
endevent

onevent EVENT_ENTERLEVEL
	ifvare LEVEL_LOADED 0
	{
		setvar LEVEL_LOADED 1
		readgamevar CL_XXXCONTENT
		readgamevar CL_LASERCOLOR
		state do_active_maphacks
		
		headspritestat CURSPRITE STAT_LOCATOR
		whilevarn CURSPRITE -1
		{
			state find_next_locator
				
			nextspritestat CURSPRITE CURSPRITE
		}
	}
	
	ifvare DEMENTIA 1
	{
		randvar HEARTBEAT_COUNTER 60
	}
	
	setvar RETURN 1
endevent

onevent EVENT_INIT
	readgamevar CL_XXXCONTENT
	readgamevar CL_LASERCOLOR
endevent

onevent EVENT_LOOKLEFT
	setvar RETURN -1
endevent

onevent EVENT_LOOKRIGHT
	setvar RETURN -1
endevent

onevent EVENT_SOUND
	getplayer[THISACTOR].gm CL_TEMP1
	ifvarand CL_TEMP1 1
	{
		switch RETURN
			case KICK_HIT:
				setvar RETURN MENU_MOVE
				break
			case PISTOL_BODYHIT:
				setvar RETURN MENU_CONFIRM
				break
			case EXITMENUSOUND:
				setvar RETURN MENU_BACK
				break
		endswitch
	}
	
	ifvare RETURN PISTOL_BODYHIT
	{
		getactor[THISACTOR].htpicnum CL_TEMP1
		ifvare CL_TEMP1 FLAMETHROWERFLAME
		{
			setvar RETURN -1
			break
		}
	}
	
	ifvare DEMENTIA 1 // Spooky House, Motherfucker!
	{
		// Sounds out of line of sight are muffled/distorted.
		switch RETURN
			case PIPEBOMB_EXPLODE:
			case RPG_EXPLODE:
			case LASERTRIP_EXPLODE:
			case LASERTRIP_ARMING:
			case PIPEBOMB_BOUNCE:
			case DOOR_OPERATE2:
			case DUKE_ONWATER:
			case DFG_CHARGE:
				// I fucking hate how many temp vars this needs.
				// I NEED TO HURRY MY CUNT ASS UP ON GETTING QUICK-ACCESS VARS IMPLEMENTED
				getplayer[screenpeek].posx CL_TEMP1
				getplayer[screenpeek].posy CL_TEMP2
				getplayer[screenpeek].posz CL_TEMP3
				getplayer[screenpeek].cursectnum CL_TEMP4
				getactor[THISACTOR].x CL_TEMP5
				getactor[THISACTOR].y CL_TEMP6
				getactor[THISACTOR].z CL_TEMP7
				getactor[THISACTOR].sectnum CL_TEMP8
				
				cansee CL_TEMP1 CL_TEMP2 CL_TEMP3 CL_TEMP4 CL_TEMP5 CL_TEMP6 CL_TEMP7 CL_TEMP8 CL_TEMP9
				
				ifvare CL_TEMP9 0 // Can't see, let's check again, but slightly raised.
				{
					subvar CL_TEMP3 4096
					subvar CL_TEMP7 4096
					cansee CL_TEMP1 CL_TEMP2 CL_TEMP3 CL_TEMP4 CL_TEMP5 CL_TEMP6 CL_TEMP7 CL_TEMP8 CL_TEMP9
				}
				
				ifvare CL_TEMP9 0
				{
					getplayer[screenpeek].i CL_TEMP1
					dist CL_TEMP3 THISACTOR CL_TEMP1
					ifvarl CL_TEMP3 2048
						setvar CL_TEMP9 1
				}
				
				ifvare CL_TEMP9 0
				{
					ifvare RETURN PIPEBOMB_BOUNCE
						setvar RETURN DISTORTED_PIPEBOMB
					else ifvare RETURN LASERTRIP_ARMING
						setvar RETURN DISTORTED_TRIPMINE
					else ifvare RETURN DOOR_OPERATE2
						setvar RETURN DISTORTED_DOOR
					else ifvare RETURN DUKE_ONWATER
						setvar RETURN DISTORTED_ONWATER
					else ifvare RETURN DFG_CHARGE
						setvar RETURN DISTORTED_DFGCHARGE
					else
						setvar RETURN DISTORTED_EXPLOSION
				}
				break
		endswitch
		
		ifactor APLAYER
		{
			ifvare RETURN DUKE_LAND
				break
			ifvare RETURN SQUISHED
				break
			ifvare RETURN DUKE_HARTBEAT
				break
			ifvare RETURN DUKE_QUIETHEARTBEAT
				break
			ifvare RETURN DUKE_ONWATER
				break
			ifvare RETURN DISTORTED_ONWATER
				break
			ifvare RETURN DISTORTED_DFGCHARGE
				break
			ifvare RETURN NITEVISION_ONOFF
				break
			
			getactor[THISACTOR].yvel CL_TEMP1
			ifvarvarn CL_TEMP1 myconnectindex
			{
				setvar RETURN -1
				break
			}
		}
		
		// Casing sounds play less often
		ifactor SHELL
		{
			displayrandvar CL_TEMP1 100
			ifvarl CL_TEMP1 95
			{
				setvar RETURN -1
				break
			}
		}
		
		ifactor SHOTGUNSHELL
		{
			displayrandvar CL_TEMP1 100
			ifvarl CL_TEMP1 95
			{
				setvar RETURN -1
				break
			}
		}
		
		// Ricochets are a bit obnoxious and ruin this map's atmosphere.
		ifvare RETURN PISTOL_RICOCHET
		{
			setvar RETURN -1
			break
		}
		
		// Teleporter sounds replaced by random ambiance
		ifvare RETURN TELEPORTER
		{
			displayrandvar CL_TEMP1 100
			ifvarl CL_TEMP1 75 // Only 25% of the sounds should make it through
			{
				setvar RETURN -1
				break
			}
			
			displayrandvar CL_TEMP1 12
			switch CL_TEMP1
				case 0 setvar RETURN DUKE_LAND break
				case 1 setvar RETURN DUKE_HARTBEAT break
				case 2 setvar RETURN THUD break
				case 3 setvar RETURN ITEM_SPLASH break
				case 4 setvar RETURN LASERTRIP_ONWALL break
				case 5 setvar RETURN DUKE_WALKINDUCTS break
				case 6 setvar RETURN KICK_HIT break
				case 7 setvar RETURN BLOOD_SPLAT1 break
				case 8 setvar RETURN FAUCET_ON break
				case 9 setvar RETURN FAUCET_OFF break
				case 10 setvar RETURN SOMETHING_DRIPPING break
				case 11 setvar RETURN NITEVISION_ONOFF break
				case 12 setvar RETURN DOOR_OPERATE2 break
			endswitch
		}
	}
	
	ifvare RETURN VMEAT1
	{
		displayrandvar CL_TEMP1 5
		switch CL_TEMP1
			case 0 setvar RETURN VMEAT1 break
			case 1 setvar RETURN VMEAT2 break
			case 2 setvar RETURN VMEAT3 break
			case 3 setvar RETURN VMEAT4 break
			case 4 setvar RETURN VMEAT5 break
			case 5 setvar RETURN VMEAT6 break
		endswitch
		
		break
	}
	
	ifvare RETURN FP_ELECTRICARC // Electric arc should be muffled if we're on a floor above or below.
	{
		getplayer[screenpeek].posz CL_TEMP1
		getactor[THISACTOR].sectnum CL_TEMP2
		getsector[CL_TEMP2].ceilingz CL_TEMP3
		getsector[CL_TEMP2].floorz CL_TEMP4
		
		ifvarvarl CL_TEMP1 CL_TEMP3
			setvar RETURN FP_ELECTRICARC_MUFFLED
			
		ifvarvarg CL_TEMP1 CL_TEMP4
			setvar RETURN FP_ELECTRICARC_MUFFLED
			
		break
	}
	
	ifvare RETURN FP_HAZARDALARM
	{
		getplayer[screenpeek].posz CL_TEMP1
		getactor[THISACTOR].sectnum CL_TEMP2
		getactor[THISACTOR].x CL_TEMP3
		getactor[THISACTOR].y CL_TEMP4
		getceilzofslope CL_TEMP2 CL_TEMP3 CL_TEMP4 CL_TEMP5
		
		ifvarvarl CL_TEMP1 CL_TEMP5
		{
			setvar RETURN FP_HAZARDALARM_MUFFLED
			break
		}
		
		getflorzofslope CL_TEMP2 CL_TEMP3 CL_TEMP4 CL_TEMP5
		
		ifvarvarg CL_TEMP1 CL_TEMP5
		{
			setvar RETURN FP_HAZARDALARM_MUFFLED
			break
		}
		
		break
	}
	
	ifactor WATERSPLASH2
	{
		ifvare RETURN ITEM_SPLASH
		{
			ifspawnedby WATERBUBBLE
				setvar RETURN -1
		}
		break
	}
	
	ifactor SHOTSPARK1
	{
		ifvare RETURN PISTOL_RICOCHET
		{
			setvar RETURN -1
			break
		}
	}
	
	ifvare RETURN TELEPORTER
	{
		getsector[THISACTOR].floorpicnum CL_TEMP1
		switch CL_TEMP1
		{
			case 3520:
			case 3521:
			case 3522:
			case 3523:
				setvar RETURN -1
				break
		}
		endswitch
		break
	}
	
	ifvare RETURN SOMETHING_DRIPPING
	{
		displayrandvar CL_TEMP1 2
		switch CL_TEMP1
			case 0: setvar RETURN NEW_DRIP1 break
			case 1: setvar RETURN NEW_DRIP2 break
			case 2: setvar RETURN NEW_DRIP3 break
		endswitch
		
		break
	}
	
	ifactor APLAYER
	{
		ifvare RETURN DUKE_USEMEDKIT
		{
			displayrandvar CL_TEMP1 100
			ifvarl CL_TEMP1 15
				setvar RETURN DUKE_USEMEDKIT2
		}
		else ifvare RETURN DUKE_UNDERWATER
		{
			getactor[THISACTOR].sectnum TEMP2
			ifvarg TEMP2 -1
			ifvarand SECTOR_TYPES[TEMP2] SECTORTYPE_SPACE
			{
				setvar RETURN -1
			}
		}
		else ifvare RETURN DUKE_WALKINDUCTS
		{
			displayrandvar CL_TEMP1 2
			switch CL_TEMP1
				case 0: setvar RETURN DUKE_WALKINDUCTS1 break
				case 1: setvar RETURN DUKE_WALKINDUCTS2 break
				case 2: setvar RETURN DUKE_WALKINDUCTS3 break
			endswitch
		}
	}
endevent

state spawn_shadow_player
	espawn SHADOWPLAYER
	getactor[THISACTOR].yvel TEMP
	setactor[RETURN].yvel TEMP
	getactor[THISACTOR].xrepeat TEMP
	setactor[RETURN].xrepeat TEMP
	getactor[THISACTOR].yrepeat TEMP
	setactor[RETURN].yrepeat TEMP
	setvar RETURN 0
ends

// Player Input
onevent EVENT_PROCESSINPUT
	state handle_rift
	state handle_sectortypes
	state handle_jumppad_movement
	state player_updateweapons
	
	ifvare DEMENTIA 1
	{
		ifp palive
		{
			setvar TEMP3 64
			ifvarg APPARITION_SPRITEID -1
			{
				dist TEMP APPARITION_SPRITEID THISACTOR
				getactor[APPARITION_SPRITEID].cstat TEMP2
					
				ifvarand TEMP2 32768
					setvar TEMP 9999999
						
				ifvarl TEMP 8192
				{
					shiftvarr TEMP 7
					setvar TEMP3 0
					addvarvar TEMP3 TEMP
				}
			}
			
			getactor[THISACTOR].xvel TEMP
			shiftvarr TEMP 2
			subvarvar TEMP3 TEMP
			
			ifvarl TEMP3 15
				setvar TEMP3 15
						
			addvar HEARTBEAT_COUNTER 1
			setvarvar TEMP HEARTBEAT_COUNTER
			modvarvar TEMP TEMP3
			
			ifvare TEMP 0
			{
				sound DUKE_QUIETHEARTBEAT
				
				ifrnd 1
				{
					ifvare predicting 0
					{
						ifp prunning
							state spawn_shadow_player
						else ifp pwalking
							state spawn_shadow_player
					}
				}
			}
		}
	}
	
	ifvare predicting 0
	{
		state handle_shake_timer
		state handle_player_shield
		
		getplayer[THISACTOR].on_ground TEMP
		ifvare TEMP 1
		{
			getplayer[THISACTOR].lowsprite TEMP
			ifvarn TEMP -1
			{
				setvarvar STATE_PARAM1 TEMP
				state check_object_touch
				
				setvarvar RETURN TEMP
				ifvarg SHIELD_HEALTH 0
				ifvare SHIELD_TYPE SHIELDTYPE_FIRE
					state set_on_fire
				
				setvar RETURN 0
			}
		}
		
		getplayer[THISACTOR].highsprite TEMP
		ifvarn TEMP -1
		{
			getactor[TEMP].z TEMP2
			getplayer[THISACTOR].posz TEMP3
			subvar TEMP3 608
			ifvarvarg TEMP2 TEMP3
			{
				setvarvar STATE_PARAM1 TEMP
				state check_object_touch
			}
		}
		
		ifvare DEMENTIA 1
		{
			ifp pdead
			{
				getplayer[THISACTOR].sound_pitch TEMP
				ifvare TEMP 0
				{
					randvar TEMP -128
					addvar TEMP -128
					setplayer[THISACTOR].sound_pitch TEMP
				}
				
				getplayer[THISACTOR].cursectnum TEMP
				ifvarg TEMP -1
				{
					getsector[TEMP].floorshade TEMP2
					ifvarg TEMP2 24
					{
						setvar HITAG_MEMORY 666
					}
				}
			}
			else
			{
				ifvarg APPARITION_SPRITEID -1
				{
					getactor[APPARITION_SPRITEID].htg_t 0 TEMP
					modvar TEMP 4
					ifvare TEMP 0
					{
						dist TEMP APPARITION_SPRITEID THISACTOR
						getactor[APPARITION_SPRITEID].cstat TEMP2
						ifvarand TEMP2 32768
							setvar TEMP 9999999
						
						getplayer[THISACTOR].sound_pitch TEMP2
						ifvarl TEMP 4096
						{
							shiftvarr TEMP 1
							setvar TEMP2 2048
							subvarvar TEMP2 TEMP
							mulvar TEMP2 -1
							setplayer[THISACTOR].sound_pitch TEMP2
						}
						else ifvarn TEMP2 0
						{
							setplayer[THISACTOR].sound_pitch 0
						}
					}
				}
			}
		}
	}
	
	// Keep this at the bottom!
	state handle_special_attacks
endevent

// THISACTOR = Sprite index of fragged player
// RETURN = Sprite index of fragging player. Setting to -1 cancels the frag.
// getplayer[THISACTOR].frag_ps = Player index of fragging player
// getplayer[THISACTOR].wackedbyactor = Sprite index of killer, regardless if a player or not.
// THISACTOR and RETURN will be the same if killed by a non-player, so check those before checking wackedbyactor.
onevent EVENT_FRAGGED
	ifvare DEMENTIA 1
	{
		ifvarvarn THISACTOR RETURN // Killed by someone else.
		{
			getplayer[THISACTOR].frag_ps TEMP // Get killer
			ifvarvare TEMP APPARITION_TARGET // Killer is the apparition target?
			{
				ifvare APPARITION_STATE APPRSTATE_CHASE // They are chasing
				{
					// Add an additional frag for their trouble.
					getplayer[TEMP].frag TEMP2
					addvar TEMP2 1
					setplayer[TEMP].frag TEMP2
					
					// Get him to fuck off, for now.
					setplayer[TEMP].fta 150
					setplayer[TEMP].ftq 196
					setvar APPARITION_STATE APPRSTATE_NEEDTARGET
					break
				}
			}
			else
			{
				getactor[THISACTOR].yvel TEMP // Get victim index.
				ifvarvare TEMP APPARITION_TARGET // Victim is the apparition target.
				ifvare APPARITION_STATE APPRSTATE_CHASE // They are currently being chased.
				{
					setvar APPARITION_STATE APPRSTATE_RELOCATE // Relocate.
				}
			}
		}
		else // Killed by self or non-player.
		{
			getactor[THISACTOR].yvel TEMP // Get victim index.
			ifvarvare TEMP APPARITION_TARGET // Victim is the apparition target.
			{
				getplayer[THISACTOR].wackedbyactor TEMP // Get sprite ID of killer.
				ifvarvare TEMP APPARITION_SPRITEID // Is it the apparition?
				{
					setvar APPARITION_STATE APPRSTATE_NEEDTARGET // Yes. Need a new target.
				}
				else ifvare APPARITION_STATE APPRSTATE_CHASE // No, but the apparition is currently chasing.
				{
					setvar APPARITION_STATE APPRSTATE_RELOCATE // Relocate.
				}
			}
		}
	}
endevent
