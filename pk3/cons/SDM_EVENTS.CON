damageeventtilerange 0 9999

state set_on_fire
	getactor[RETURN].extra TEMP
	ifvarl TEMP 1 { break }
	
	// Team DM?
	ifvarand gametype_flags 65536
	{
		ifvare FFIRE 0 // Friendly fire is off.
		{
			getactor[RETURN].picnum TEMP
			getactor[THISACTOR].owner TEMP2
			getactor[TEMP2].picnum TEMP3
			
			ifvare TEMP APLAYER // Are both attackers players?
			ifvare TEMP3 APLAYER
			{
				ifvarvarn TEMP2 RETURN
				{
					getactor[RETURN].yvel TEMP
					getplayer[TEMP].team TEMP	
					
					getactor[TEMP2].yvel TEMP2
					getplayer[TEMP2].team TEMP2
					
					ifvarvare TEMP TEMP2 // Team matches?
					{
						break // Bail.
					}
				}
			}
		}
	}
	else ifvarand gametype_flags 4096 // All players friendly?
	{
		ifvare FFIRE 0 // Friendly fire is off.
		{
			getactor[RETURN].picnum TEMP
			getactor[THISACTOR].owner TEMP2
			getactor[TEMP2].picnum TEMP3
			
			ifvare TEMP APLAYER // Are both attackers players?
			ifvare TEMP3 APLAYER
			{
				ifvarvarn TEMP2 RETURN
				{
					break // Bail.
				}
			}
		}
	}
	
	getactor[RETURN].picnum TEMP
	ifvarn TEMP APLAYER
	{
		ifvare TEMP BOSS5 // BOSS5 can't be set on fire.
		{
			break
		}
		
		// Check if owner picnum is the same as victim picnum. (So fireflies can't burn eachother)
		getactor[RETURN].picnum TEMP
		getactor[THISACTOR].owner TEMP2
		getactor[TEMP2].picnum TEMP2
		ifvarvare TEMP TEMP2
		{
			break
		}
	}
	
	getactorvar[RETURN].BURNING_TICS TEMP
	ifvarl TEMP 117 // Burning for more than 4 tics, or not burning at all.
	{
		getactor[RETURN].cstat TEMP
		ifvarand TEMP 256 // Can be shot?
		{
			getactorvar[RETURN].BURNING_OLDPAL TEMP
			ifvare TEMP -1 // Palette not memorized yet?
			{
				getactor[RETURN].pal TEMP // Get current palette
				setactorvar[RETURN].BURNING_OLDPAL TEMP // Store it for later restoration
			}
			
			getactor[THISACTOR].owner TEMP // Get owner of projectile
			setactorvar[RETURN].BURNING_TICS 120 // Start burning for 120 tics
			setactorvar[RETURN].BURNING_INFLICTOR TEMP // Store owner in victim's data
			setactor[RETURN].htpicnum FIREBALL
			
			getactor[RETURN].htextra TEMP
			ifvare TEMP -1 { setactor[RETURN].htextra 0 }
			
			getactor[RETURN].picnum TEMP
			switch TEMP
				case TREE1:
				case TREE2:
				case TIRE:
				case CONE:
				case BOX:
					getactor[RETURN].htg_t 0 TEMP
					ifvare TEMP 0 // Trigger hardcoded burn/shrink code
					{
						getactor[RETURN].cstat TEMP
						ifvarand TEMP 1 { subvar TEMP 1 }
						ifvarand TEMP 256 { subvar TEMP 256 }
						setactor[RETURN].cstat TEMP
						setactor[RETURN].htg_t 0 1
					}
					break
			endswitch
		}
	}
ends

onevent EVENT_DAMAGESPRITE
	getactor[THISACTOR].owner TEMP // DON'T OVERWRITE
	setactorvar[RETURN].LASTHITBY TEMP
	
	ifvarvare TEMP RETURN // If owner is the same as victim
	{
		getactor[RETURN].picnum TEMP2 // Make bosses unable to hurt themselves
		ifvare TEMP2 BOSS2
		{
			setvar RETURN -1
			break
		}
		else ifvare TEMP2 BOSS3
		{
			setvar RETURN -1
			break
		}
		else ifvare TEMP2 BOSS5
		{
			setvar RETURN -1
			break
		}
	}
	
	ifactor FREEZEBLAST
	{
		getactorvar[RETURN].BURNING_TICS TEMP2
		ifvarg TEMP2 0
		{
			setactor[THISACTOR].extra 1
		}
		break
	}
	else ifactor FIREBALL
	{
		state set_on_fire
		break
	}
	else ifactor FLAMETHROWERFLAME
	{
		state set_on_fire
		break
	}
	else ifactor BURNING_ALT
	{
		state set_on_fire	
		setvar RETURN -1 // Do not do the usual radius damage processing
		break
	}
	else ifactor BURNING2_ALT
	{
		state set_on_fire
		setvar RETURN -1 // Do not do the usual radius damage processing
		break
	}
	else ifactor DEVASTATORMISSILE
	{
		getactor[RETURN].picnum TEMP2
		
		switch TEMP2
			case APLAYER:
				getuserdef[].return 1 TEMP2		
				ifvare TEMP2 -1
				{
					getactor[RETURN].htextra TEMP2
					addvar TEMP2 3
					setactor[RETURN].htextra TEMP2
					setactor[RETURN].htpicnum DEVASTATORMISSILE
					setactor[RETURN].htowner TEMP
					
					getactor[THISACTOR].ang TEMP2
					setactor[RETURN].htang TEMP2
					setvar RETURN -1 // Break out of this crap.
				}
				break
			case CRACK1:
			case CRACK2:
			case CRACK3:
			case CRACK4:
				setactor[RETURN].htpicnum RADIUSEXPLOSION
				break
			default:
				getactor[RETURN].statnum TEMP2
				ifvare TEMP2 12 // STAT_FALLER
				{
					setactor[RETURN].htpicnum RADIUSEXPLOSION
					setactor[RETURN].htextra 5
					setactor[RETURN].htowner TEMP
					setvar RETURN -1
				}
				break
		endswitch
	}
	else ifactor GROWSPARK
	{
		getactor[RETURN].picnum TEMP
		switch TEMP
			case CRACK1:
			case CRACK2:
			case CRACK3:
			case CRACK4:
				setvar RETURN -1
				break
		endswitch
	}
endevent

state check_penetration
	getactor[RETURN].extra TEMP
	getactor[RETURN].htextra TEMP2
	ifvarvarl TEMP TEMP2 // Has total incoming damage exceeded target's health? (Ie. Guaranteed to die)
	{
		// Make non-shootable, allowing the rest of the shotgun blast to pass through like DOOM.
		getactor[RETURN].cstat TEMP
		ifvarand TEMP 256
		{
			subvar TEMP 256
			setactor[RETURN].cstat TEMP
			setactorvar[RETURN].PENETRATED 1
		}
	}
ends

onevent EVENT_POSTDAMAGESPRITE
	ifactor SHOTSPARK1
	{
		getactor[THISACTOR].yvel TEMP
		ifvare TEMP RAILGUNSHOT
		{
			getactor[RETURN].picnum TEMP
			ifvarn TEMP APLAYER
			{
				setactor[RETURN].htpicnum RADIUSEXPLOSION
				getactor[RETURN].htextra TEMP
				addvar TEMP 30
				setactor[RETURN].htextra TEMP
			}
			else
			{
				setactor[RETURN].htpicnum RAILGUNSHOT
			}
		}
		else ifvare TEMP SSGPELLET
		{
			getactor[RETURN].picnum TEMP
			gettiledata[TEMP].gameflags TEMP2
			
			ifvare TEMP APLAYER
			{
				state check_penetration
			}
			else ifvarand TEMP2 32 // SFLAG_BADGUY
			{
				state check_penetration
			}
			else ifvarand TEMP2 262144 // SFLAG_HARDCODED_BADGUY
			{
				state check_penetration
			}
				
			getactor[THISACTOR].htowner TEMP
			dist TEMP2 TEMP RETURN
			ifvarl TEMP2 1024
			{
				setactor[RETURN].htpicnum RADIUSEXPLOSION
			}
			else ifvarl TEMP2 2048
			{
				ifrnd 32
					setactor[RETURN].htpicnum RADIUSEXPLOSION
			}
		}
	}
endevent

onevent EVENT_KILLIT
	ifactor FIREBALL
	{
		espawn ONFIRE
		getactor[THISACTOR].owner TEMP
		setactor[RETURN].owner TEMP
		setvar RETURN 0
		break
	}
	
	ifactor GROWSPARK
	{
		espawn EXPANDEREXPLOSION
		getactor[THISACTOR].owner TEMP
		setactor[RETURN].owner TEMP
		setvar RETURN 0
		break
	}
	
	// Use a quick-access var here later.
	getactor[THISACTOR].picnum TEMP
	switch TEMP
		case BOTTLE1:
		case BOTTLE2:
		case BOTTLE3:
		case BOTTLE4:
		case BOTTLE5:
		case BOTTLE6:
		case BOTTLE7:
		case BOTTLE8:
		case BOTTLE10:
		case BOTTLE11:
		case BOTTLE12:
		case BOTTLE13:
		case BOTTLE14:
		case BOTTLE15:
		case BOTTLE16:
		case BOTTLE17:
		case BOTTLE18:
		case BOTTLE19:
		case FOODOBJECT1:
		case FOODOBJECT2:
		case FOODOBJECT3:
		case FOODOBJECT4:
		case FOODOBJECT5:
		case FOODOBJECT6:
		case FOODOBJECT7:
		case FOODOBJECT8:
		case FOODOBJECT9:
		case FOODOBJECT10:
		case FOODOBJECT11:
		case FOODOBJECT12:
		case FOODOBJECT13:
		case FOODOBJECT14:
		case FOODOBJECT15:
		case FOODOBJECT16:
		case FOODOBJECT17:
		case FOODOBJECT18:
		case FOODOBJECT19:
		case FOODOBJECT20:
		case JOLLYMEAL:
		case COFFEEMUG:
		case COFFEEMACHINE:
		case RUBBERCAN:
		case CANWITHSOMETHING:
		case CANWITHSOMETHING2:
		case CANWITHSOMETHING3:
		case CANWITHSOMETHING4:
		case EXPLODINGBARREL:
		case FIREBARREL:
		case FIREVASE:
		case DUKEBURGER:
		case GUNPOWDERBARREL:
		case ROBOTDOG:
		case ROBOTDOG2:
		case FEATHEREDCHICKEN:
		case SKINNEDCHICKEN:
		case DESKLAMP:
		case MAILBAG:
		case CLOCK:
		case VACUUM:
		case DOMELITE:
		case CAMERALIGHT:
		case MOVIECAMERA:
		case TRIPODCAMERA:
		case CHAIR3:
		case DURRPLANT:
		case BONG:
		case BONG2:
		case DILDO:
		case FLESHLIGHT:
		case VIBRATOR:
		case BD_SOFIA:
			state prepare_respawn_hardcoded
			break
	endswitch
	
	ifactor SHELL
	{
		randvar RANDOM_SOUND 5
		switch RANDOM_SOUND
			case 0: sound CASING1 break
			case 1: sound CASING2 break
			case 2: sound CASING3 break
			case 3: sound CASING4 break
			case 4: sound CASING5 break
			case 5: sound CASING6 break
		endswitch
		break
	}
	else ifactor SHOTGUNSHELL
	{
		randvar RANDOM_SOUND 5
		switch RANDOM_SOUND
			case 0: sound SHELL_BOUNCE1 break
			case 1: sound SHELL_BOUNCE2 break
			case 2: sound SHELL_BOUNCE3 break
			case 3: sound SHELL_BOUNCE4 break
			case 4: sound SHELL_BOUNCE5 break
			case 5: sound SHELL_BOUNCE6 break
		endswitch
		break
	}
	
	ifactor OOZFILTER
	{
		ifvare NORESPAWN 1
		{
			setvar RETURN 0
		}
		else
		{
			state prepare_respawn_hardcoded
		}
	}
	else ifactor SEENINE
	{
		ifvare NORESPAWN 1
		{
			setvar RETURN 0
		}
		else
		{
			state prepare_respawn_hardcoded
		}
	}
	else ifactor 1249 // SEENINEDEAD+1
	{
		ifvare NORESPAWN 1
		{
			setvar RETURN 0
		}
		else
		{
			state prepare_respawn_hardcoded
		}
	}
endevent

state boss_projectile_offset
	getactor[THISACTOR].ang SPAWN_ORIGANG
			
	// Calculate X position
	setvarvar TEMP SPAWN_ORIGANG
	sin TEMP2 TEMP
	divvar TEMP2 512
			
	// Set X position
	getactor[THISACTOR].x TEMP
	subvarvar TEMP TEMP2
	setactor[THISACTOR].x TEMP
			
	// Calculate Y position
	setvarvar TEMP SPAWN_ORIGANG
	addvar TEMP 1536
	sin TEMP2 TEMP
	
	getactor[THISACTOR].owner TEMP3
	getactor[TEMP3].pal TEMP3
	ifvare TEMP3 0
	{
		divvar TEMP2 128
	}
	else
	{
		divvar TEMP2 256
	}
			
	// Set Y position
	getactor[THISACTOR].y TEMP
	subvarvar TEMP TEMP2
	setactor[THISACTOR].y TEMP
			
	getactor[THISACTOR].z TEMP
	ifvare TEMP3 0
	{
		addvar TEMP 7200
	}
	else
	{
		addvar TEMP 3600
	}
	setactor[THISACTOR].z TEMP
ends

state devastator_boss_spread
	getactor[THISACTOR].ang TEMP
	addvar TEMP 96
	randvar TEMP2 192
	subvarvar TEMP TEMP2
	setactor[THISACTOR].ang TEMP
	
	getactor[THISACTOR].zvel TEMP
	addvar TEMP 512
	randvar TEMP2 1024
	subvarvar TEMP TEMP2
	setactor[THISACTOR].zvel TEMP
ends

state boss_devastatormissile_resize
	setactor[THISACTOR].xrepeat 16
	setactor[THISACTOR].yrepeat 16
	setthisprojectile[THISACTOR].txrepeat 16
	setthisprojectile[THISACTOR].tyrepeat 16
	setthisprojectile[THISACTOR].sxrepeat 16
	setthisprojectile[THISACTOR].syrepeat 16
ends

onevent EVENT_EGS
	// TODO: Change this to quick-access vars once EDuke32 gets better MP.
	ifactor FIREBALL
	{
		setactor[THISACTOR].blend 255 // Additive Blend
		setactor[THISACTOR].mdflags 16
		
		// Calculate horizontal spread
		getactor[THISACTOR].ang TEMP
		ifspawnedby BOSS5
		{
			addvar TEMP 128
			randvar TEMP2 256
		}
		else
		{
			addvar TEMP 8
			randvar TEMP2 16
		}
		subvarvar TEMP TEMP2
		setactor[THISACTOR].ang TEMP
		
		// Calculate vertical spread
		getactor[THISACTOR].zvel TEMP
		ifspawnedby BOSS5
		{
			addvar TEMP 1024
			randvar TEMP2 2048
		}
		else
		{
			addvar TEMP 128
			randvar TEMP2 256
		}
		subvarvar TEMP TEMP2
		setactor[THISACTOR].zvel TEMP
		
		ifspawnedby BOSS5
		{
			state boss_projectile_offset
		}
		
		break
	}

	ifactor GROWSPARK
	{
		setactor[THISACTOR].blend 255
		break
	}
	
	ifactor JIBS6
	{
		ifspawnedby SHOTSPARK1
		{
			getactor[THISACTOR].owner TEMP // Shotspark
			getactor[TEMP].htg_t 8 TEMP // Target hit
			getactor[TEMP].picnum TEMP2 // Target picnum
			
			switch TEMP2
				case APLAYER:
					getactor[TEMP].pal TEMP2 // Target's pal
					setactor[THISACTOR].pal TEMP2
					break
				case NEWBEAST:
					setactor[THISACTOR].pal 125
					break
			endswitch
			
			randvar RANDOM_SOUND 4
			switch RANDOM_SOUND
				case 0: sound BULLET_HIT1 break
				case 1: sound BULLET_HIT2 break
				case 2: sound BULLET_HIT3 break
				case 3: sound BULLET_HIT4 break
				case 4: sound BULLET_HIT5 break
			endswitch

			ifinwater
			{
				espawn BLOODINFLUID1
				getactor[THISACTOR].pal TEMP2
				setactor[RETURN].pal TEMP2
				randvar TEMP 8
				addvar TEMP 8
				setactor[RETURN].xrepeat TEMP
				setactor[RETURN].yrepeat TEMP
				setvar RETURN 0
			}
			else
			{
				espawn BLOODSPURT
				getactor[THISACTOR].pal TEMP2
				setactor[RETURN].pal TEMP2
				
				randvar TEMP 48
				addvar TEMP 16
				setactor[RETURN].xvel TEMP
				
				setvar TEMP -512
				randvar TEMP2 1024
				subvarvar TEMP TEMP2
				setactor[RETURN].zvel TEMP
				
				randvar TEMP 2047
				setactor[RETURN].ang TEMP
				setvar RETURN 0
			}
		}
		
		break
	}
	
	// Freezeblast speed buff
	ifactor FREEZEBLAST
	{
		setactor[THISACTOR].xvel 768
	}
	
	ifactor FLAMETHROWERFLAME
	{
		// Calculate horizontal spread
		getactor[THISACTOR].ang TEMP
		ifspawnedby BOSS5
		{
			addvar TEMP 128
			randvar TEMP2 256
		}
		else
		{
			addvar TEMP 32
			randvar TEMP2 64
		}
		subvarvar TEMP TEMP2
		setactor[THISACTOR].ang TEMP
		
		// Calculate vertical spread
		getactor[THISACTOR].zvel TEMP
		ifspawnedby BOSS5
		{
			addvar TEMP 1024
			randvar TEMP2 2048
		}
		else
		{
			addvar TEMP 512
			randvar TEMP2 1024
		}
		subvarvar TEMP TEMP2
		setactor[THISACTOR].zvel TEMP
		break
	}
	
	ifactor DEVASTATORMISSILE
	{
		ifspawnedby BOSS5
		{
			state devastator_boss_spread
			state boss_devastatormissile_resize
		}
		else ifspawnedby BOSS2
		{
			state devastator_boss_spread
			state boss_devastatormissile_resize
		}
		else
		{
			// Calculate horizontal spread
			getactor[THISACTOR].ang TEMP
			addvar TEMP 16
			randvar TEMP2 32
			subvarvar TEMP TEMP2
			setactor[THISACTOR].ang TEMP
			
			// Calculate vertical spread
			getactor[THISACTOR].zvel TEMP
			addvar TEMP 256
			randvar TEMP2 512
			subvarvar TEMP TEMP2
			setactor[THISACTOR].zvel TEMP
		}
		
		ifspawnedby APLAYER
		{
			// Get angle and barrel
			getplayer[THISACTOR].hbomb_hold_delay TEMP3
			getplayer[THISACTOR].ang SPAWN_ORIGANG
			
			// Calculate X position
			setvarvar TEMP SPAWN_ORIGANG
			sin TEMP2 TEMP
			divvar TEMP2 512
			
			// Set X position
			getactor[THISACTOR].x TEMP
			ifvare TEMP3 1 // Check barrel
			{
				subvarvar TEMP TEMP2
			}
			else
			{
				addvarvar TEMP TEMP2
			}
			setactor[THISACTOR].x TEMP
			
			// Calculate Y position
			setvarvar TEMP SPAWN_ORIGANG
			addvar TEMP 1536
			sin TEMP2 TEMP
			divvar TEMP2 512
			
			// Set Y position
			getactor[THISACTOR].y TEMP
			ifvare TEMP3 1 // Check barrel
			{
				subvarvar TEMP TEMP2
			}
			else
			{
				addvarvar TEMP TEMP2
			}
			setactor[THISACTOR].y TEMP
			
			ifvare COOP GM_ROIDMATCH
			{
				setprojectile[DEVASTATORMISSILE].velmult 2
			}
		}
		else ifspawnedby BOSS5
		{
			state boss_projectile_offset
		}
		else ifspawnedby BOSS2
		{
			state boss_projectile_offset
		}
		break
	}
	
	getactor[THISACTOR].picnum TEMP
	switch TEMP	
		case JIBS1:
		case JIBS2:
		case JIBS3:
		case JIBS4:
		case JIBS5:
		case HEADJIB1:
        case LEGJIB1:
        case ARMJIB1:
        case LIZMANHEAD1:
        case LIZMANARM1:
        case LIZMANLEG1:
        case DUKELEG:
        case DUKEGUN:
        case DUKETORSO:
			setvarvar PICNUM_MEMORY TEMP
			break
			
		case PLASMABALL:
		case PLASMABALL2:
		case PLASMABALL3:
			setactor[THISACTOR].blend 255
			break
			
		case LASERLINE:
		case TRIPBOMB:
			setactor[THISACTOR].mdflags 16
			break
		
		case PIGJIB1:
			changespritestat THISACTOR 1
			break
	endswitch
endevent

state reset_burn
	stopsound FIRE_CRACKLE
	
	ifwasweapon FREEZEBLAST
	{
		getactor[THISACTOR].extra TEMP
		ifvarg TEMP 0
		{
			setactor[THISACTOR].pal BURNING_OLDPAL
		}
	}
	else
	{
		setactor[THISACTOR].pal BURNING_OLDPAL
	}
	
	ifactor APLAYER
	{
		setvar STOP_BURNING 0
	}
	
	setvar BURNING_OLDPAL -1
	setvar BURNING_TICS 0
	setvar BURNING_INFLICTOR -1
ends

state burning_logic
	ifvarg BURNING_TICS 0
	{
		ifinwater { state reset_burn break }
		ifinspace { state reset_burn break }
		ifwasweapon FREEZEBLAST { state reset_burn break }
		
		findnearsprite3d TOILETWATER 800 TEMP
		ifvarn TEMP -1 { state reset_burn break }
		
		getactor[THISACTOR].extra TEMP
		ifvarl TEMP 1 { state reset_burn break }
		
		ifactor APLAYER
		{
			ifvare STOP_BURNING 1 { state reset_burn break }
			palfrom 16 64 8 0
		}
		
		// Check if on water surface
		getsector[THISACTOR].lotag TEMP
		ifvare TEMP 1
		{
			// TEMP = X
			// TEMP2 = Y
			// TEMP3 = Sector Number
			getactor[THISACTOR].x TEMP
			getactor[THISACTOR].y TEMP2
			updatesector TEMP TEMP2 TEMP3
			
			// Set TEMP to florz
			getflorzofslope TEMP3 TEMP TEMP2 TEMP
			subvar TEMP 512 // Subtract height
			
			getactor[THISACTOR].z TEMP2
			
			ifvarvarg TEMP2 TEMP // Touching floor?
			{
				state reset_burn
				break
			}
		}
		
		// Burn sound
		soundonce FIRE_CRACKLE
		
		setvarvar TEMP BURNING_TICS
		modvar TEMP 2
		ifvare TEMP 0
		{
			state spawn_random_fire
		}
		
		// Damage every 4 tics
		setvarvar TEMP BURNING_TICS
		modvar TEMP 4
		ifvare TEMP 0
		{
			getactor[THISACTOR].htextra TEMP2
			ifactor APLAYER // Half damage for player
			{
				addvar TEMP2 2
			}
			else
			{
				addvar TEMP2 4
			}
			setactor[THISACTOR].htextra TEMP2
			
			setactor[THISACTOR].htowner BURNING_INFLICTOR
			setactor[THISACTOR].htpicnum FIREBALL
		}
		
		setactor[THISACTOR].pal 2
		
		subvar BURNING_TICS 1
		
		ifvare BURNING_TICS 0
		{
			state reset_burn
			break
		}
	}
ends

state plasma_spread
	addvar EXTRA_MEMORY 1
	ifvarg EXTRA_MEMORY 5
	{
		ifactor PLASMABALL setvar PICNUM_MEMORY PLASMABALL2
		else ifactor PLASMABALL2 setvar PICNUM_MEMORY PLASMABALL3
		
		getactor[THISACTOR].x SPAWN_ORIGX
		getactor[THISACTOR].y SPAWN_ORIGY
		getactor[THISACTOR].z SPAWN_ORIGZ
		getactor[THISACTOR].htbposx DEST_X
		getactor[THISACTOR].htbposy DEST_Y
		getactor[THISACTOR].htbposz DEST_Z
		getactor[THISACTOR].ang SPAWN_ORIGANG
		getactor[THISACTOR].zvel SPAWN_ORIGZVEL
		getactor[THISACTOR].owner TEMP2 // Do NOT overwrite!
		
		randvar TEMP3 16
		subvar TEMP3 8
		addvarvar SPAWN_ORIGANG TEMP3
		
		randvar TEMP3 512
		subvar TEMP3 256
		addvarvar SPAWN_ORIGZVEL TEMP3
			
		eshootvar PICNUM_MEMORY
		setvarvar TEMP SPAWN_ORIGANG
		addvar TEMP PLASMARIFLE_X_SPREAD
		setactor[RETURN].ang TEMP
		setactor[RETURN].x SPAWN_ORIGX
		setactor[RETURN].y SPAWN_ORIGY
		setactor[RETURN].z SPAWN_ORIGZ
		setactor[RETURN].htbposx DEST_X
		setactor[RETURN].htbposy DEST_Y
		setactor[RETURN].htbposz DEST_Z
		setactor[RETURN].zvel SPAWN_ORIGZVEL
		setactor[RETURN].owner TEMP2
		setvar RETURN 0
			
		eshootvar PICNUM_MEMORY
		setvarvar TEMP SPAWN_ORIGANG
		subvar TEMP PLASMARIFLE_X_SPREAD
		setactor[RETURN].ang TEMP
		setactor[RETURN].x SPAWN_ORIGX
		setactor[RETURN].y SPAWN_ORIGY
		setactor[RETURN].z SPAWN_ORIGZ
		setactor[RETURN].htbposx DEST_X
		setactor[RETURN].htbposy DEST_Y
		setactor[RETURN].htbposz DEST_Z
		setactor[RETURN].zvel SPAWN_ORIGZVEL
		setactor[RETURN].owner TEMP2
		setvar RETURN 0
			
		eshootvar PICNUM_MEMORY
		setvarvar TEMP SPAWN_ORIGZVEL
		addvar TEMP PLASMARIFLE_Y_SPREAD
		setactor[RETURN].zvel TEMP
		setactor[RETURN].x SPAWN_ORIGX
		setactor[RETURN].y SPAWN_ORIGY
		setactor[RETURN].z SPAWN_ORIGZ
		setactor[RETURN].htbposx DEST_X
		setactor[RETURN].htbposy DEST_Y
		setactor[RETURN].htbposz DEST_Z
		setactor[RETURN].ang SPAWN_ORIGANG
		setactor[RETURN].owner TEMP2
		setvar RETURN 0
			
		eshootvar PICNUM_MEMORY
		setvarvar TEMP SPAWN_ORIGZVEL
		subvar TEMP PLASMARIFLE_Y_SPREAD
		setactor[RETURN].zvel TEMP
		setactor[RETURN].x SPAWN_ORIGX
		setactor[RETURN].y SPAWN_ORIGY
		setactor[RETURN].z SPAWN_ORIGZ
		setactor[RETURN].htbposx DEST_X
		setactor[RETURN].htbposy DEST_Y
		setactor[RETURN].htbposz DEST_Z
		setactor[RETURN].ang SPAWN_ORIGANG
		setactor[RETURN].owner TEMP2
		setvar RETURN 0
		
		// Center shot
		eshootvar PICNUM_MEMORY
		setactor[RETURN].x SPAWN_ORIGX
		setactor[RETURN].y SPAWN_ORIGY
		setactor[RETURN].z SPAWN_ORIGZ
		setactor[RETURN].htbposx DEST_X
		setactor[RETURN].htbposy DEST_Y
		setactor[RETURN].htbposz DEST_Z
		setactor[RETURN].ang SPAWN_ORIGANG
		setactor[RETURN].zvel SPAWN_ORIGZVEL
		setactor[RETURN].owner TEMP2
		setvar RETURN 0
		
		changespritestat THISACTOR 2
		killit
	}
ends

onevent EVENT_PREGAME
	ifvare PENETRATED 1
	{
		getactor[THISACTOR].cstat TEMP
		orvar TEMP 256
		setactor[THISACTOR].cstat TEMP
		setvar PENETRATED 0
	}
	
	ifactor WATERDRIP
	{
		getactor[THISACTOR].htg_t 1 EXTRA_MEMORY
	}
endevent

onevent EVENT_GAME
	state burning_logic
	
	ifactor WATERDRIP
	{
		getactor[THISACTOR].htg_t 1 TEMP
		ifvarvarn TEMP EXTRA_MEMORY
		ifvare EXTRA_MEMORY 0
		{
			getactor[THISACTOR].pal PAL_MEMORY
			getactor[THISACTOR].cstat CSTAT_MEMORY
			getactor[THISACTOR].shade TEMP3
			getactor[THISACTOR].htfloorz SPAWN_ORIGZ
			subvar CSTAT_MEMORY 32768
			espawn WATERDRIPSPLASH_FIXED
			setactor[RETURN].pal PAL_MEMORY
			setactor[RETURN].cstat CSTAT_MEMORY
			setactor[RETURN].shade TEMP3
			setactor[RETURN].z SPAWN_ORIGZ
			setvar RETURN 0
		}
		break
	}
	
	ifactor SHRINKSPARK
	{
		cstator 2
		setactor[THISACTOR].blend 255
		
		espawn SHRINKERTRAIL
		getactor[THISACTOR].x TEMP
		randvar TEMP2 128
		subvar TEMP2 64
		addvarvar TEMP TEMP2
		setactor[RETURN].x TEMP
		
		getactor[THISACTOR].y TEMP
		randvar TEMP2 128
		subvar TEMP2 64
		addvarvar TEMP TEMP2
		setactor[RETURN].y TEMP
		
		getactor[THISACTOR].z TEMP
		randvar TEMP2 2048
		subvar TEMP2 1024
		addvarvar TEMP TEMP2
		setactor[RETURN].z TEMP
		
		getactor[THISACTOR].htbposx TEMP
		setactor[RETURN].htbposx TEMP
		
		getactor[THISACTOR].htbposy TEMP
		setactor[RETURN].htbposy TEMP
		
		getactor[THISACTOR].htbposz TEMP
		setactor[RETURN].htbposz TEMP
		setvar RETURN 0
		break
	}

	ifactor TRIPBOMB
	{
		getactor[THISACTOR].cstat TEMP	
		ifvare TEMP 16
		{
			cstator 256
			setactor[THISACTOR].htflags 136
		}
		break
	}
	
	getactor[THISACTOR].picnum TEMP	
	switch TEMP
		case PLASMABALL:
		case PLASMABALL2:
			state plasma_spread
			break
			
		case RESPAWNMARKERRED:
		case RESPAWNMARKERYELLOW:
		case RESPAWNMARKERGREEN:
			getactor[THISACTOR].owner TEMP
			getactor[TEMP].z TEMP2
			setactor[THISACTOR].z TEMP2
			break
			
		case WATERBUBBLEMAKER:
		case WATERBUBBLE:
			getactor[THISACTOR].sectnum TEMP2
			ifvarg TEMP2 -1
			ifvarand SECTOR_TYPES[TEMP2] SECTORTYPE_SPACE
			{
				killit
			}
			break
			
		case JIBS1:
		case JIBS2:
		case JIBS3:
		case JIBS4:
		case JIBS5:
		case DUKETORSO:
		case DUKELEG:
			addvar EXTRA_MEMORY 1 // Timer
			setvarvar TEMP EXTRA_MEMORY
			
			ifvarg Numsprites 10000
				modvar TEMP 4 // Spawn blood every 4th tic
			else
				modvar TEMP 2 // Spawn blood every 2nd tic
				
			ifvare TEMP 0
			ifvarl Numsprites 14000 // Prevent "Too Many Sprites Spawned"
			{
				getactor[THISACTOR].pal TEMP2
				espawn GIBBLOOD
				setactor[RETURN].pal TEMP2
				setvar RETURN 0
			}
			break
	endswitch
	
	ifactor JIBS6
	{
		ifspawnedby SHOTSPARK1
		ifinwater
		{
			changespritestat THISACTOR 2
			killit
			break
		}
		
		// Check if actor was changed from one of these.
		switch PICNUM_MEMORY
			case JIBS1:
			case JIBS2:
			case JIBS3:
			case JIBS4:
			case JIBS5:
			case HEADJIB1:
			case LEGJIB1:
			case ARMJIB1:
			case LIZMANHEAD1:
			case LIZMANARM1:
			case LIZMANLEG1:
			case DUKELEG:
			case DUKEGUN:
			case DUKETORSO:
				state gibsound // Impact splat noise
				
				ifvarl Numsprites 14000 // Prevent "Too Many Sprites"
				{
					getactor[THISACTOR].pal TEMP2
					ifvare PICNUM_MEMORY JIBS1 { espawn JIBS1_ONGROUND setactor[RETURN].pal TEMP2 }
					else ifvare PICNUM_MEMORY JIBS2 { espawn JIBS2_ONGROUND setactor[RETURN].pal TEMP2 }
					else ifvare PICNUM_MEMORY JIBS3 { espawn JIBS3_ONGROUND setactor[RETURN].pal TEMP2 }
					else ifvare PICNUM_MEMORY JIBS4 { espawn JIBS4_ONGROUND setactor[RETURN].pal TEMP2 }
					else ifvare PICNUM_MEMORY JIBS5 { espawn JIBS5_ONGROUND setactor[RETURN].pal TEMP2 }
					else ifvare PICNUM_MEMORY HEADJIB1 { espawn HEADJIB1_ONGROUND setactor[RETURN].pal TEMP2 }
					else ifvare PICNUM_MEMORY LEGJIB1 { espawn LEGJIB1_ONGROUND setactor[RETURN].pal TEMP2 }
					else ifvare PICNUM_MEMORY ARMJIB1 { espawn ARMJIB1_ONGROUND setactor[RETURN].pal TEMP2 }
					else ifvare PICNUM_MEMORY DUKETORSO { espawn DUKETORSO_ONGROUND setactor[RETURN].pal TEMP2 }
					else ifvare PICNUM_MEMORY DUKEGUN { espawn DUKEGUN_ONGROUND setactor[RETURN].pal TEMP2 }
					else ifvare PICNUM_MEMORY DUKELEG { espawn DUKELEG_ONGROUND setactor[RETURN].pal TEMP2 }
				}
				
				setvar PICNUM_MEMORY 0 // Clear this so it doesn't repeat
			break
		endswitch
	}
endevent

state set_norespawn
		ifactor SECTOREFFECTOR
		{
			setvarvar TEMP3 HITAG_MEMORY
		}
		else
		{
			setvarvar TEMP3 LOTAG_MEMORY
		}
				
		getactor[CURSPRITE].hitag TEMP2
		ifvarvare TEMP3 TEMP2
		{
			setactorvar[CURSPRITE].NORESPAWN 1
		}
ends

state explosive_search_iterator
	getactor[CURSPRITE].picnum TEMP
	ifvare TEMP SEENINE
	{
		state set_norespawn
	}
	else ifvare TEMP OOZFILTER
	{
		state set_norespawn
	}
		
	nextspritestat CURSPRITE LASTSPRITE
	setvarvar LASTSPRITE CURSPRITE
ends

state search_for_explosive
		headspritestat CURSPRITE 0
		setvarvar LASTSPRITE CURSPRITE
		whilevarn CURSPRITE -1
		{
			state explosive_search_iterator
		}
		
		headspritestat CURSPRITE 6
		setvarvar LASTSPRITE CURSPRITE
		whilevarn CURSPRITE -1
		{
			state explosive_search_iterator
		}
ends

onevent EVENT_LOADACTOR
	getactor[THISACTOR].hitag HITAG_MEMORY
	getactor[THISACTOR].lotag LOTAG_MEMORY
	
	getactor[THISACTOR].picnum TEMP
	switch TEMP
	case TIMEDPLATFORM:
	case CONTEXTSOUND:
	case CUSTOMTOUCHPLATE:
	case ZTELEPORTER:
	case ZTDESTINATION:
		setactor[THISACTOR].lotag 0
		break
	case WATERBUBBLEMAKER:
		setactor[THISACTOR].lotag 0
		getactor[THISACTOR].cstat CSTAT_MEMORY
		break
	case STARTWEAPONCHANGER:
		setvarvar START_WEAPON LOTAG_MEMORY
		setactor[THISACTOR].lotag 0
		break
	case BOSS2:
	case BOSS3:
	case BOSS5:
		addvar BOSS_COUNT 1 // Hack for Duke's Nightmare
		break
	endswitch
endevent

onevent EVENT_SPAWN
	ifactor MASTERSWITCH
	{
		state search_for_explosive
		break
	}
	else ifactor SECTOREFFECTOR
	{
		ifvarn LOTAG_MEMORY 13
		{
			break
		}
		state search_for_explosive
		break
	}
	
	ifactor RESPAWNMARKERRED
	{
		setactor[THISACTOR].mdflags 16
		break
	}

	ifactor BLOODPOOL
	{
		ifspawnedby APLAYER
		{
			setactor[THISACTOR].mdflags 16
			getactor[THISACTOR].owner TEMP
			getactor[TEMP].pal TEMP2
			setactor[THISACTOR].pal TEMP2
		}
		break
	}
	
	ifactor WATERDRIP // Fix a common mistake with WATERDRIPs
	{
		getactor[THISACTOR].cstat TEMP
		ifvarand TEMP 1
		{
			subvar TEMP 1
			setactor[THISACTOR].cstat TEMP
		}
		break
	}
	
	ifactor SHELL
	{
		getactor[THISACTOR].owner TEMP
		getactor[TEMP].yvel TEMP2
		getplayer[TEMP2].curr_weapon TEMP3
		ifvare TEMP3 CHAINGUN_WEAPON
		{
			setactor[THISACTOR].mdflags 16
			setvar EXTRA_MEMORY 1
		}
		break
	}
	
	ifactor FIRESHELL
	{
		cstat 130
		setactor[THISACTOR].shade -127
		setactor[THISACTOR].blend 255
		setactor[THISACTOR].mdflags 16
		setvar ANIMATE_FLAGS ANIMATE_FLAG_SHELLEXPANSION
		
		setvar LOTAG_MEMORY 0 // Timer
		setvar HITAG_MEMORY 64 // End time
		setvar SPAWN_ORIGANG 64 // Rotational Speed
		
		setvar XREPEAT_MEMORY 0 // Start radius
		setvar YREPEAT_MEMORY 80 // End radius
		
		ifspawnedby SHRINKEREXPLOSION // Shrinker
		{
			setvar XREPEAT_MEMORY 48 // Start radius
			setvar YREPEAT_MEMORY 0 // End radius
			setvar SPAWN_ORIGANG 32 // Rotational Speed
		}
		else ifspawnedby EXPANDEREXPLOSION // Expander
		{
			setvar HITAG_MEMORY 32 // End time
			setvar XREPEAT_MEMORY 0 // Start radius
			setvar YREPEAT_MEMORY 48 // End radius
		}
		else ifspawnedby LDEXPLOSION
		{
			setvar HITAG_MEMORY 32 // End time
			setvar XREPEAT_MEMORY 0 // Start radius
			setvar YREPEAT_MEMORY 48 // End radius
			setvar SPAWN_ORIGANG 72 // Rotational Speed
		}

		break
	}
	
	ifactor EXPANDERTRAIL
	{
		cstat 130
		setactor[THISACTOR].shade -127
		setactor[THISACTOR].blend 255
		setactor[THISACTOR].mdflags 16
		setvar ANIMATE_FLAGS ANIMATE_FLAG_SHELLEXPANSION
		
		setvar LOTAG_MEMORY 0 // Timer
		setvar HITAG_MEMORY 16 // End time
		setvar SPAWN_ORIGANG 0 // Rotational Speed
		
		ifspawnedby EXPANDEREXPLOSION
		{
			cstator 32
			setvar XREPEAT_MEMORY 16 // Start radius
			setvar YREPEAT_MEMORY 128 // End radius
		}
		else
		{
			setvar XREPEAT_MEMORY 4 // Start radius
			setvar YREPEAT_MEMORY 16 // End radius
		}
		break
	}
	
	ifactor SHRINKERTRAIL
	{
		cstat 130
		setactor[THISACTOR].shade -127
		setactor[THISACTOR].blend 255
		setactor[THISACTOR].mdflags 16
		setvar ANIMATE_FLAGS ANIMATE_FLAG_SHELLEXPANSION
		
		setvar LOTAG_MEMORY 0 // Timer
		setvar HITAG_MEMORY 32 // End time
		setvar SPAWN_ORIGANG 0 // Rotational Speed
		
		setvar XREPEAT_MEMORY 16 // Start radius
		setvar YREPEAT_MEMORY 0 // End radius
		
		break
	}
	
	ifactor EXPLOSION2
	{
		cstator 2
		setactor[THISACTOR].blend 255
		break
	}
	
	ifactor EXPLOSION2BOT
	{
		cstator 2
		setactor[THISACTOR].blend 255
		break
	}
	
	ifactor WATERBUBBLEMAKER
	{
		getactor[THISACTOR].pal PAL_MEMORY
		break
	}
	
	getactor[THISACTOR].picnum PICNUM_MEMORY
	getactor[THISACTOR].xrepeat XREPEAT_MEMORY
	getactor[THISACTOR].yrepeat YREPEAT_MEMORY
	getactor[THISACTOR].clipdist CLIPDIST_MEMORY
	getactor[THISACTOR].extra EXTRA_MEMORY
	getactor[THISACTOR].cstat CSTAT_MEMORY
	getactor[THISACTOR].pal PAL_MEMORY
	getactor[THISACTOR].statnum STATNUM_MEMORY
	getactor[THISACTOR].sectnum SECTNUM_MEMORY
	getactor[THISACTOR].x SPAWN_ORIGX
	getactor[THISACTOR].y SPAWN_ORIGY
	getactor[THISACTOR].z SPAWN_ORIGZ
	getactor[THISACTOR].ang SPAWN_ORIGANG
	
	getactor[THISACTOR].picnum TEMP
	switch TEMP
		// XXX tiles (Hide if XXX content is off)
		case FLESHLIGHT:
		case SHARONM2:
		case LIRUANIM:
		case VIBRATOR:
		case BD_SOFIA:
		case SHARONMANIM:
		case FREYACRESCENT:
		case ROUGESPREAD:
		case COCOANIM:
		case COMMUNITY_XXX01:
		case IMPTAN:
			setactor[THISACTOR].mdflags 16
			setvar ISADULT ADULT_HIDE
			break
		
		// XXX tiles (Have XXX version if XXX content is on, or clean version if off.)
		case EXOTICA:
		case FEMPIC5:
		case FEMPIC6:
		case FEMPIC7:
		case FEMMAG2:
		case STRIPPERFLASH:
		case HOOKERFLASH:
		case FEM1:
		case FEM3:
		case FEM4:
		case FEM5:
		case FEM6:
		case FEM7:
		case FEM10:
		case PIRATE1A:
		case PIRATE3A:
		case TOUGHGAL:
		case NAKED1:
		case WOMAN:
		case 1330:
		case 4498:
		case 4865:
		case GEECKU:
		case GEECKU2:
		case MIKHAILA:
		case MIKHAILA2:
		case CHAMPAGNE:
		case STRIKER:
		case STRIKERXHELEN:
		case HENTAIANIM:
		case PUSSYGRIND:
		case DAWNSEXANIM:
		case SALLYMASTURBATE:
		case SHARONM:
		case DILDO:
			setactor[THISACTOR].mdflags 16
			setvar ISADULT ADULT_SWAP
			break
			
		// Misc Tiles
		case TRIPBOMB:
			setactor[THISACTOR].mdflags 16
			break
			
		case FOOTPRINTS:
		case FOOTPRINTS2:
		case FOOTPRINTS3:
		case FOOTPRINTS4:
			ifspawnedby APLAYER
			{
				setactor[THISACTOR].mdflags 16
			}
			break
		
		case WATERBUBBLEMAKER:
		case WATERBUBBLE:
			getactor[THISACTOR].sectnum TEMP2
			ifvarg TEMP2 -1
			ifvarand SECTOR_TYPES[TEMP2] SECTORTYPE_SPACE
			{
				killit
			}
			break
			
		case FIREFLY:
			ifvare MONSTERS_OFF 1
			{
				killit
			}
			
			cstator 257
			ifspawnedby FIREFLY
			{
				changespritestat THISACTOR 2
			}
			break
			
		case BOSS2:
		case BOSS3:
		case BOSS2STAYPUT:
		case BOSS3STAYPUT:
		case BOSS5:
		case BOSS5STAYPUT:
			getactor[THISACTOR].cstat TEMP
			ifvarand TEMP 16
			{
				changespritestat THISACTOR 0
			}
			else
			{
				ifvare MONSTERS_OFF 1
				{
					killit
				}
				
				cstator 257
				changespritestat THISACTOR 2
				
				ifspritepal 0
				{
					sizeat 80 80
					setactor[THISACTOR].clipdist 164
				}
				else
				{
					sizeat 40 40
					setactor[THISACTOR].clipdist 80
				}
			}
			break
	endswitch
	
	switch TEMP
		case FEM1:
		case FEM2:
		case FEM3:
		case FEM4:
		case FEM5:
		case FEM6:
		case FEM7:
		//case FEM8: // Dead, can't be saved.
		case FEM9:
		case FEM10:
		case TOUGHGAL:
		case NAKED1:
		case PODFEM1:
		case WOMAN:
		case PIRATE1A:
		case PIRATE3A:
			ifactor NAKED1
			{
				ifinwater { } // Drowned, can't be saved.
				else
				{
					addvar BABES_TOTAL 1
				}
			}
			else ifactor WOMAN
			{
				getactor[THISACTOR].sectnum TEMP
				ifvare TEMP 541 { } // Hack for E4L1
				else
				{
					addvar BABES_TOTAL 1
				}
			}
			else
			{
				addvar BABES_TOTAL 1
			}
			break
	endswitch
	
	switch COOP
		case GM_ROIDMATCH:
		case GM_INSTAGIB:
			state strip_items
			break
		default:
			break
	endswitch
endevent

onevent EVENT_ANIMATESPRITES // !UNSYNCHRONIZED!	
	ifvarg QUAKE3BOB 0
	{
		setvarvar CL_TEMP1 totalclock
		addvarvar CL_TEMP1 QUAKE3BOB
		mulvar CL_TEMP1 6
		cos CL_TEMP2 CL_TEMP1
		divvar CL_TEMP2 6
		
		gettspr[THISACTOR].tsprz CL_TEMP1
		subvar CL_TEMP1 3072
		addvarvar CL_TEMP1 CL_TEMP2
		settspr[THISACTOR].tsprz CL_TEMP1
		
		ifactor RESPAWNMARKERRED { }
		else ifactor RESPAWNMARKERYELLOW { }
		else ifactor RESPAWNMARKERGREEN { }
		else
		{
			getactor[THISACTOR].ang CL_TEMP1
			setvarvar CL_TEMP2 totalclock
			shiftvarl CL_TEMP2 2
			addvarvar CL_TEMP1 CL_TEMP2
			settspr[THISACTOR].tsprang CL_TEMP1
		}
	}
	
	// LOTAG_MEMORY = timer
	// HITAG_MEMORY = lifetime
	// SPAWN_ORIGANG = rotational speed
	// SPAWN_ORIGZVEL = rotational offset
	// XREPEAT_MEMORY = start radius
	// YREPEAT_MEMORY = end radius
	ifvarand ANIMATE_FLAGS ANIMATE_FLAG_SHELLEXPANSION
	{	
		ifvarvare LOTAG_MEMORY HITAG_MEMORY
		{
			settspr[THISACTOR].tsprxrepeat 0
			break
		}
		
		ifvarvarg LOTAG_MEMORY HITAG_MEMORY
		{
			settspr[THISACTOR].tsprxrepeat 0
			break
		}
			
		ifvarg clock_diff 0 // Sync to 120hz timer
		{	
			getuserdef[].pause_on CL_TEMP1
			ifvarvarn ANIMATE_CLOCKLAST totalclock
			ifvare CL_TEMP1 0
			{
				// Increment timer
				addvarvar LOTAG_MEMORY clock_diff
				
				// Increment angle
				setvarvar CL_TEMP1 SPAWN_ORIGANG
				mulvarvar CL_TEMP1 clock_diff
				addvarvar SPAWN_ORIGZVEL CL_TEMP1
				
				// Set last animate tic to keep speed correct.
				setvarvar ANIMATE_CLOCKLAST totalclock
			}
		}
		
		// Apply rotation
		gettspr[THISACTOR].tsprang CL_TEMP2
		addvarvar CL_TEMP2 SPAWN_ORIGZVEL
		settspr[THISACTOR].tsprang CL_TEMP2
		
		// Radius range
		setvarvar CL_TEMP1 YREPEAT_MEMORY
		subvarvar CL_TEMP1 XREPEAT_MEMORY
		
		// Resulting radius
		setvarvar CL_TEMP2 LOTAG_MEMORY
		mulvarvar CL_TEMP2 CL_TEMP1
		divvarvar CL_TEMP2 HITAG_MEMORY
		addvarvar CL_TEMP2 XREPEAT_MEMORY
		
		ifvarg CL_TEMP2 255
			setvar CL_TEMP2 255
		ifvarl CL_TEMP2 0
			setvar CL_TEMP2 0
		
		// Set x/yrepeat
		settspr[THISACTOR].tsprxrepeat CL_TEMP2
		settspr[THISACTOR].tspryrepeat CL_TEMP2
		
		// Fade alpha over time
		setvarvar CL_TEMP2 LOTAG_MEMORY
		mulvar CL_TEMP2 256
		divvarvar CL_TEMP2 HITAG_MEMORY
		
		ifvarg CL_TEMP2 255
			setvar CL_TEMP2 255
		ifvarl CL_TEMP2 0
			setvar CL_TEMP2 0

		// Set alpha
		setactor[THISACTOR].alpha CL_TEMP2
	}
	
	// Hack to keep your own fireballs from blinding you.
	ifactor FIREBALL
	{
		getactor[THISACTOR].owner CL_TEMP1
		ldist CL_TEMP2 THISACTOR CL_TEMP1	
		ifvarl CL_TEMP2 512
		{
			settspr[THISACTOR].tsprxrepeat 0
			settspr[THISACTOR].tspryrepeat 0
		}
		break
	}
	
	ifactor FIREBALLTRAIL
	{
		getactor[THISACTOR].htowner CL_TEMP1
		getactor[CL_TEMP1].owner CL_TEMP1
		ldist CL_TEMP2 THISACTOR CL_TEMP1
		ifvarl CL_TEMP2 512
		{
			settspr[THISACTOR].tsprxrepeat 0
			settspr[THISACTOR].tspryrepeat 0
		}
		break
	}
	// ----
	
	ifactor RESPAWNMARKERRED
	{
		getactor[THISACTOR].ang CL_TEMP1
		setvarvar CL_TEMP2 totalclock
		shiftvarl CL_TEMP2 3
		subvarvar CL_TEMP1 CL_TEMP2
		settspr[THISACTOR].tsprang CL_TEMP1
		break
	}
	
	ifactor RESPAWNMARKERYELLOW
	{
		getactor[THISACTOR].ang CL_TEMP1
		setvarvar CL_TEMP2 totalclock
		shiftvarl CL_TEMP2 4
		subvarvar CL_TEMP1 CL_TEMP2
		settspr[THISACTOR].tsprang CL_TEMP1
		break
	}
	
	ifactor RESPAWNMARKERGREEN
	{
		getactor[THISACTOR].ang CL_TEMP1
		setvarvar CL_TEMP2 totalclock
		shiftvarl CL_TEMP2 6
		subvarvar CL_TEMP1 CL_TEMP2
		settspr[THISACTOR].tsprang CL_TEMP1
		break
	}
	
	ifvarg ISADULT 0
	{
		getuserdef[].lockout CL_TEMP1
		ifvare CL_TEMP1 1
		{
			settspr[THISACTOR].tsprxrepeat 0
			break
		}
		
		ifvare CL_XXXCONTENT 1
		{
			ifvare ISADULT ADULT_SWAP
			{
				gettspr[THISACTOR].tsprpicnum CL_TEMP1
				switch CL_TEMP1
					// Clean tiles with XXX versions
					case EXOTICA: settspr[THISACTOR].tsprpicnum 5950 break // 766
					case FEMPIC5: settspr[THISACTOR].tsprpicnum 5951 break // 963
					case FEMPIC6: settspr[THISACTOR].tsprpicnum 5952 break // 964
					case FEMPIC7: settspr[THISACTOR].tsprpicnum 5953 break // 965
					case PIRATE1A: settspr[THISACTOR].tsprpicnum 5955 break
					case PIRATE3A: settspr[THISACTOR].tsprpicnum 5957 break
					case FEM10: settspr[THISACTOR].tsprpicnum 5959 break
					case 4865: settspr[THISACTOR].tsprpicnum 5960 break
					case 4866: settspr[THISACTOR].tsprpicnum 5961 break
					case 4867: settspr[THISACTOR].tsprpicnum 5962 break
					case 4868: settspr[THISACTOR].tsprpicnum 5963 break
					case 4869: settspr[THISACTOR].tsprpicnum 5964 break
					case 4870: settspr[THISACTOR].tsprpicnum 5965 break
					case WOMAN: settspr[THISACTOR].tsprpicnum 5966 break
					case FEMMAG2: settspr[THISACTOR].tsprpicnum 5969 break // 577
					case 4498: settspr[THISACTOR].tsprpicnum 5970 break
					case FEM3: settspr[THISACTOR].tsprpicnum 5971 break
					case HOOKERFLASH: settspr[THISACTOR].tsprpicnum 5973 break // 1339
					case FEM5: settspr[THISACTOR].tsprpicnum 5974 break
					case FEM4: settspr[THISACTOR].tsprpicnum 5975 break
					case 1330: settspr[THISACTOR].tsprpicnum 5980 break
					case FEM7: settspr[THISACTOR].tsprpicnum 5981 break
					case 1332: settspr[THISACTOR].tsprpicnum 5985 break
					case 1333: settspr[THISACTOR].tsprpicnum 5986 break
					case FEM6: settspr[THISACTOR].tsprpicnum 5987 break
					case NAKED1: settspr[THISACTOR].tsprpicnum 5988 break
				endswitch
			}
		}
		else
		{
			ifvare ISADULT ADULT_HIDE
			{
				settspr[THISACTOR].tsprxrepeat 0
				break
			}
			
			ifvare ISADULT ADULT_SWAP
			{
				gettspr[THISACTOR].tsprpicnum CL_TEMP1
				switch CL_TEMP1
					// XXX tiles with clean versions
					case DILDO: settspr[THISACTOR].tsprpicnum 3702 break
					case SHARONM: settspr[THISACTOR].tsprpicnum 4980 break
					case SALLYMASTURBATE: settspr[THISACTOR].tsprpicnum 4981 break
					case DAWNSEXANIM: settspr[THISACTOR].tsprpicnum 4982 break
					case HENTAIANIM: settspr[THISACTOR].tsprpicnum 4983 break
					case STRIKERXHELEN: settspr[THISACTOR].tsprpicnum 4984 break
					case STRIKER: settspr[THISACTOR].tsprpicnum 4985 break
					case CHAMPAGNE: settspr[THISACTOR].tsprpicnum 4986 break
					case MIKHAILA: settspr[THISACTOR].tsprpicnum 4987 break
					case MIKHAILA2: settspr[THISACTOR].tsprpicnum 4988 break
					case GEECKU2: settspr[THISACTOR].tsprpicnum 4989 break
					case GEECKU: settspr[THISACTOR].tsprpicnum 4990 break
					case PUSSYGRIND: settspr[THISACTOR].tsprpicnum 6155 break
				endswitch
			}
		}
	}
	
	ifactor LASERLINE
	{
		switch CL_LASERCOLOR
			case 0: settspr[THISACTOR].tsprpicnum 5006 break
			case 1: settspr[THISACTOR].tsprpicnum 5009 break
			case 2: settspr[THISACTOR].tsprpicnum 5012 break
			case 3: settspr[THISACTOR].tsprpicnum 5015 break
		endswitch
		
		break
	}
	else ifactor TRIPBOMB
	{
		switch CL_LASERCOLOR
			case 1: settspr[THISACTOR].tsprpicnum 2592 break
			case 2: settspr[THISACTOR].tsprpicnum 2593 break
			case 3: settspr[THISACTOR].tsprpicnum 2594 break
		endswitch
		
		break
	}
	else ifactor SHELL
	{
		ifvare EXTRA_MEMORY 1
		{
			gettspr[THISACTOR].tsprpicnum CL_TEMP1
			switch CL_TEMP1
				case 2533: settspr[THISACTOR].tsprpicnum RIPPERSHELL1 break
				case 2534: settspr[THISACTOR].tsprpicnum RIPPERSHELL2 break
			endswitch
		}
		
		break
	}
	
	getactor[THISACTOR].picnum CL_TEMP1
	switch CL_TEMP1
		case BLOODSPURT:
		case SPURTTRAIL:
		case PIGJIB1:
			gettspr[THISACTOR].tsprshade CL_TEMP1
			subvar CL_TEMP1 6
			settspr[THISACTOR].tsprshade CL_TEMP1
			break
		case BLOODPOOL:
			settspr[THISACTOR].tsprpicnum BLOODPOOL_PLAYER
			break
		case FOOTPRINTS:
			getactor[THISACTOR].pal CL_TEMP1
			ifvarn CL_TEMP1 0
			{
				settspr[THISACTOR].tsprpicnum BLOODY_FOOTPRINT
			}
			break
		case FOOTPRINTS2:
			getactor[THISACTOR].pal CL_TEMP1
			ifvarn CL_TEMP1 0
			{
				settspr[THISACTOR].tsprpicnum BLOODY_FOOTPRINT2
			}
			break
		case FOOTPRINTS3:
			getactor[THISACTOR].pal CL_TEMP1
			ifvarn CL_TEMP1 0
			{
				settspr[THISACTOR].tsprpicnum BLOODY_FOOTPRINT3
			}
			break
		case FOOTPRINTS4:
			getactor[THISACTOR].pal CL_TEMP1
			ifvarn CL_TEMP1 0
			{
				settspr[THISACTOR].tsprpicnum BLOODY_FOOTPRINT4
			}
			break
	endswitch
endevent

onevent EVENT_CHEATGETBOOT
	setvar FLAMETHROWER_AMMO MAXFREEZEAMMO
	setvar FREEZETHROWER_AMMO MAXFLAMETHROWERAMMO
	
	setvar RIPPER_AMMO MAXCHAINGUNAMMO
	setvar PLASMARIFLE_AMMO MAXPLASMARIFLEAMMO
	
	setvar RPG_AMMO MAXRPGAMMO
	setvar RAILGUN_AMMO MAXRAILGUNAMMO
	
	// Give Primaries
	setvar STATE_PARAM2 WEAP_PRIMARY
	setvar STATE_PARAM3 1
	
	setvar STATE_PARAM1 SHOTGUN_WEAPON
	state set_have_weapon
	
	setvar STATE_PARAM1 CHAINGUN_WEAPON
	state set_have_weapon
	
	setvar STATE_PARAM1 RPG_WEAPON
	state set_have_weapon
	
	setvar STATE_PARAM1 FREEZE_WEAPON
	state set_have_weapon
	// --------------------------
	
	// Give Secondaries
	setvar STATE_PARAM2 WEAP_SECONDARY
	setvar STATE_PARAM3 1
	
	setvar STATE_PARAM1 SHOTGUN_WEAPON
	state set_have_weapon
	
	setvar STATE_PARAM1 CHAINGUN_WEAPON
	state set_have_weapon
	
	setvar STATE_PARAM1 RPG_WEAPON
	state set_have_weapon
	
	setvar STATE_PARAM1 FREEZE_WEAPON
	state set_have_weapon
	// --------------------------
endevent

state reset_weapons
	// Clear Subweapons
	setvar STATE_PARAM1 1
	setvar STATE_PARAM3 0 // Weapon not owned
	whilevarn STATE_PARAM1 11 // Cycle through all
	{
		setvar STATE_PARAM2 WEAP_PRIMARY
		state set_have_weapon
		
		setvar STATE_PARAM2 WEAP_SECONDARY
		state set_have_weapon
		
		setvar STATE_PARAM2 WEAP_PRIMARY
		state set_weapontype
		
		addvar STATE_PARAM1 1
	}
	
	// Clear Ammo
	setvar FLAMETHROWER_AMMO 0
	setvar FREEZETHROWER_AMMO 0
	setvar RIPPER_AMMO 0
	setvar PLASMARIFLE_AMMO 0
	setvar RPG_AMMO 0
	setvar RAILGUN_AMMO 0	
	
	ifvarg START_WEAPON -1
	{
		setplayer[THISACTOR].gotweapon PISTOL_WEAPON 0
		
		ifvarl START_WEAPON SSG_WEAPON
		{
			setplayer[THISACTOR].gotweapon START_WEAPON 1
			
			getplayer[THISACTOR].max_ammo_amount START_WEAPON TEMP
			divvar TEMP 2
			setplayer[THISACTOR].ammo_amount START_WEAPON TEMP
			
			ifvare START_WEAPON RPG_WEAPON
				setvarvar RPG_AMMO TEMP
			else ifvare START_WEAPON CHAINGUN_WEAPON
				setvarvar RIPPER_AMMO TEMP
			else ifvare START_WEAPON FREEZE_WEAPON
				setvarvar FREEZETHROWER_AMMO TEMP
			
			setvarvar STATE_PARAM1 START_WEAPON
			setvar STATE_PARAM2 WEAP_PRIMARY
			setvar STATE_PARAM3 1
			state set_have_weapon
		
			setplayer[THISACTOR].curr_weapon START_WEAPON
		}
	}
ends

onevent EVENT_RESETWEAPONS
	state reset_weapons
endevent

onevent EVENT_RESETPLAYER
	ifmultiplayer
	{
		ifvarand gametype_flags 32768 { }
		else
		{
			state reset_weapons
		}
	}
	else
	{
		getplayer[THISACTOR].gm TEMP
		ifvarand TEMP 8 { } // EOL?
		else
		{
			state reset_weapons
		}
	}
endevent

onevent EVENT_PRELEVEL
	setvar START_WEAPON -1
	setvar BABES_RESCUED 0
	setvar BABES_TOTAL 0
	setvar BABES_ALLSAVED 0
	
	setvar TEMP 0
	whilevarn TEMP MAXSECTORS
	{
		setarray SECTOR_TYPES[TEMP] 0
		setarray SECTOR_JUMPX[TEMP] 0
		setarray SECTOR_JUMPY[TEMP] 0
		setarray SECTOR_JUMPZ[TEMP] 0
		addvar TEMP 1
	}
endevent

onevent EVENT_USEMEDKIT
	getplayer[THISACTOR].firstaid_amount TEMP
	ifvarg TEMP 0
	{
		ifvarg BURNING_TICS 0
		{
			getactor[THISACTOR].extra TEMP
			ifvarl TEMP 100
			{
				palfrom 48 0 0 48
				state stop_player_burn
			}
		}
	}
endevent

onevent EVENT_STRAFELEFT
ifp pjetpack
{
	getplayer[THISACTOR].rotscrnang TEMP
	
	ifp prunning
		addvar TEMP 6
	else
		addvar TEMP 3
	
	ifvarg TEMP 45
	{
		setvar TEMP 45
	}
	setplayer[THISACTOR].rotscrnang TEMP 
}
endevent

onevent EVENT_STRAFERIGHT
ifp pjetpack
{
	getplayer[THISACTOR].rotscrnang TEMP
	
	ifp prunning
		subvar TEMP 6
	else
		subvar TEMP 3
		
	ifvarl TEMP -45
	{
		setvar TEMP -45
	}
	setplayer[THISACTOR].rotscrnang TEMP 
}
endevent

state jetpack_turn
	getplayer[THISACTOR].rotscrnang TEMP	
	getinput[THISACTOR].avel TEMP2
	mulvar TEMP2 -1
	divvar TEMP2 4
	addvarvar TEMP TEMP2
	
	ifvarl TEMP -45
	{
		setvar TEMP -45
	}
	else ifvarg TEMP 45
	{
		setvar TEMP 45
	}
	
	setplayer[THISACTOR].rotscrnang TEMP 
ends

onevent EVENT_TURNLEFT
	ifp pjetpack
	{
		state jetpack_turn
	}
	else ifinwater
	{
		state jetpack_turn
	}
endevent

onevent EVENT_TURNRIGHT
	ifp pjetpack
	{
		state jetpack_turn
	}
	else ifinwater
	{
		state jetpack_turn
	}
endevent

onevent EVENT_GETLOADTILE // !UNSYNCHRONIZED!
	ifvare COOP GM_ROIDMATCH
	{
		setvar RETURN ROIDLOAD
	}
endevent

onevent EVENT_USESTEROIDS
	getplayer[THISACTOR].steroids_amount TEMP
	ifvare TEMP 400
	{
		state roids_voices
	}
endevent

//definegamefuncname 13 Toggle_XXX_Content
//definegamefuncname 14 Change_Tripmine_Color
state client_keys
	getinput[THISACTOR].bits CL_TEMP1
	ifvarand CL_TEMP1 64
	{
		ifvarand CL_OLDKEYS 64 { }
		else
		{
			ifvare CL_XXXCONTENT 0
			{
				redefinequote 500 ^12XXX Content: ^08ON
				userquote 500
				setvar CL_XXXCONTENT 1
				savegamevar CL_XXXCONTENT
			}
			else
			{
				redefinequote 500 ^12XXX Content: ^02OFF
				userquote 500
				setvar CL_XXXCONTENT 0
				savegamevar CL_XXXCONTENT
			}
		}
	}
	else ifvarand CL_TEMP1 128
	{
		ifvarand CL_OLDKEYS 128 { }
		else
		{
			ifvare CL_LASERCOLOR 0
			{
				redefinequote 500 ^12Tripmine Laser Color: ^08Green
				userquote 500
				setvar CL_LASERCOLOR 1
				savegamevar CL_LASERCOLOR
			}
			else ifvare CL_LASERCOLOR 1
			{
				redefinequote 500 ^12Tripmine Laser Color: ^01Blue
				userquote 500
				setvar CL_LASERCOLOR 2
				savegamevar CL_LASERCOLOR
			}
			else ifvare CL_LASERCOLOR 2
			{
				redefinequote 500 ^12Tripmine Laser Color: ^07Yellow
				userquote 500
				setvar CL_LASERCOLOR 3
				savegamevar CL_LASERCOLOR
			}
			else ifvare CL_LASERCOLOR 3
			{
				redefinequote 500 ^12Tripmine Laser Color: ^02Red
				userquote 500
				setvar CL_LASERCOLOR 0
				savegamevar CL_LASERCOLOR
			}
		}
	}
	getinput[THISACTOR].bits CL_OLDKEYS
ends

state draw_babe_counter
	getuserdef[].levelstats CL_TEMP1
	ifvare CL_TEMP1 1
	{
		ifvarn BABES_TOTAL 0
		{
			redefinequote 500 ^12Babes Saved:^8 %d ^12/^8 %d
			qsprintf 500 500 BABES_RESCUED BABES_TOTAL
			screentext 3072 2 130 65536 0 0 500 -127 0 280 0 3 5 1 1 8196 0 0 xdim ydim
		}
	}
ends

onevent EVENT_DISPLAYSTART // !UNSYNCHRONIZED!
	setvarvar clock_diff totalclock
	subvarvar clock_diff clock_last
	setvarvar clock_last totalclock
endevent

onevent EVENT_DISPLAYREST // !UNSYNCHRONIZED!

	//redefinequote 500 %d
	//qsprintf 500 500 gametype_flags
	//minitext 48 48 500 -127 1
	
	// SO MANY FUCKING TEMP VARS
	getuserdef[].screen_size CL_TEMP1
	ifmultiplayer
	{
		ifvarg CL_TEMP1 0
		{
			ifvarn COOP GM_COOPERATIVE
			{
				setvar SCORE_PLAYERINDEX 0
				setvar SCORE_YOFFSET 8
				whilevarn SCORE_PLAYERINDEX 16
				{
					getplayer[SCORE_PLAYERINDEX].connected SCORE_PLAYERCONNECTED
					ifvare SCORE_PLAYERCONNECTED 1 // Is connected
					{
						// Print Background Bar
						myos 267 SCORE_YOFFSET NAMEBAR -127 569
						
						// Get palette
						getplayer[SCORE_PLAYERINDEX].palookup SCORE_PLAYERPAL
						
						// Get and print name
						getpname 500 SCORE_PLAYERINDEX
						screentext 3072 268 SCORE_YOFFSET 65536 0 0 500 -127 SCORE_PLAYERPAL 536 0 3 5 1 1 8192 0 0 xdim ydim 
						
						// Get and print frags
						getplayer[SCORE_PLAYERINDEX].frag SCORE_FRAGS
						getplayer[SCORE_PLAYERINDEX].fraggedself SCORE_SUICIDES
						subvarvar SCORE_FRAGS SCORE_SUICIDES
						redefinequote 500 %d
						qsprintf 500 500 SCORE_FRAGS
						screentext 3072 318 SCORE_YOFFSET 65536 0 0 500 -127 SCORE_PLAYERPAL 536 0 3 5 1 1 8193 0 0 xdim ydim 
						
						// Move y offset down
						addvar SCORE_YOFFSET 6
					}
					
					// Move on to the next player
					addvar SCORE_PLAYERINDEX 1
				}
			}
			else
			{
				state draw_babe_counter
			}
		}
	}
	else
	{
		ifvarg CL_TEMP1 0
		{
			state draw_babe_counter
		}
	}
	
	ifvarl WEAPONQUOTEALPHA 255
	{
		//gametext STARTALPHANUM 320 30 WEAPONQUOTE 0 7 16 0 0 xdim ydim
		
		screentext STARTALPHANUM 160 30 65536 0 0 WEAPONQUOTE -127 7 16 WEAPONQUOTEALPHA 6 7 0 1 8194 0 0 xdim ydim
	}
	
	ifvarg BURNING_TICS 0
	{
		screentext 3072 160 150 65536 0 0 134 -127 2 16 0 3 5 1 1 8194 0 0 xdim ydim
	}
	
	state client_keys
endevent

state health_color
	ifvarg CL_TEMP1 150
		setvar CL_TEMP2 123 // Blue
	else ifvarg CL_TEMP1 100
		setvar CL_TEMP2 126 // Purple
	else ifvarg CL_TEMP1 66
		setvar CL_TEMP2 125 // Green
	else ifvarg CL_TEMP1 33
		setvar CL_TEMP2 122 // Yellow
	else
		setvar CL_TEMP2 124 // Red
ends

onevent EVENT_DISPLAYSBAR // !UNSYNCHRONIZED!
	getuserdef[].screen_size CL_TEMP1
	ifvarl CL_TEMP1 8
	ifvarg CL_TEMP1 0
	{
		//setuserdef[].statusbarscale 100
		
		// Ammo Icon
		// Change orientation to 536 later.
		getplayer[THISACTOR].curr_weapon STATE_PARAM1
		state check_using_secondary
		
		ifvare STATE_PARAM1 HANDREMOTE_WEAPON
			setvar STATE_PARAM1 HANDBOMB_WEAPON
		
		setvar CL_TEMP1 -1
		setvar CL_TEMP2 32768
		switch STATE_PARAM1
			case FREEZE_WEAPON:
				ifvare STATE_RETURN 1
					setvar CL_TEMP1 FLAMETHROWERAMMO
				else
					setvar CL_TEMP1 FREEZEAMMO
				break
				
			case CHAINGUN_WEAPON:
				ifvare STATE_RETURN 1
					setvar CL_TEMP1 PLASMAAMMO
				else
					setvar CL_TEMP1 BATTERYAMMO
				break
				
			case RPG_WEAPON:
				ifvare STATE_RETURN 1
					setvar CL_TEMP1 RAILGUNAMMO
				else
					setvar CL_TEMP1 RPGAMMO
				break
				
			case SHOTGUN_WEAPON:
				setvar CL_TEMP1 SHOTGUNAMMO
				break
				
			case PISTOL_WEAPON:
				setvar CL_TEMP1 AMMO
				setvar CL_TEMP2 16384
				break
				
			case SHRINKER_WEAPON:
				setvar CL_TEMP1 CRYSTALAMMO
				break
				
			case GROW_WEAPON:
				setvar CL_TEMP1 GROWAMMO
				break
				
			case HANDBOMB_WEAPON:
				setvar CL_TEMP1 HBOMBAMMO
				break
				
			case DEVISTATOR_WEAPON:
				setvar CL_TEMP1 DEVISTATORAMMO
				break
				
			case TRIPBOMB_WEAPON:
				setvar CL_TEMP1 TRIPBOMBSPRITE
				break
		endswitch
		
		ifvarn CL_TEMP1 -1
		{
			setvar TEMP 295
			setvar TEMP2 186
			
			rotatespritea TEMP TEMP2 CL_TEMP2 0 CL_TEMP1 -127 4 10 128 windowx1 windowy1 windowx2 windowy2
			subvar TEMP 1
			subvar TEMP2 1
			rotatesprite TEMP TEMP2 CL_TEMP2 0 CL_TEMP1 -127 0 10 windowx1 windowy1 windowx2 windowy2
			
			// Ammo Number
			getplayer[THISACTOR].ammo_amount STATE_PARAM1 CL_TEMP1
			
			redefinequote 500 %d
			qsprintf 500 500 CL_TEMP1
			
			setvar TEMP 262
			setvar TEMP2 182
			screentext DIGITALNUM TEMP TEMP2 65536 0 0 500 -127 4 16 128 6 7 1 1 532482 0 0 xdim ydim
			subvar TEMP 1
			subvar TEMP2 1
			screentext DIGITALNUM TEMP TEMP2 65536 0 0 500 -127 125 16 0 6 7 1 1 532482 0 0 xdim ydim
		}
		
		// Duke Head
		getplayer[THISACTOR].frag CL_TEMP1
		getplayer[THISACTOR].fraggedself CL_TEMP2
		subvarvar CL_TEMP1 CL_TEMP2
		getactor[THISACTOR].pal CL_TEMP2
		
		ifvarl CL_TEMP1 0
			setvar CL_TEMP1 DUKEGACHIFACE
		else
			setvar CL_TEMP1 DUKEHUDFACE
		
		
		setvar TEMP 14
		setvar TEMP2 187
		rotatespritea TEMP TEMP2 24576 0 CL_TEMP1 -127 4 10 128 windowx1 windowy1 windowx2 windowy2
		subvar TEMP 1
		subvar TEMP2 1
		rotatesprite TEMP TEMP2 24576 0 CL_TEMP1 -127 CL_TEMP2 10 windowx1 windowy1 windowx2 windowy2
		
		// Health
		getactor[THISACTOR].extra CL_TEMP1
		redefinequote 500 %d
		qsprintf 500 500 CL_TEMP1
		
		state health_color
		
		setvar TEMP 37
		setvar TEMP2 182
		screentext DIGITALNUM TEMP TEMP2 65536 0 0 500 -127 4 16 128 6 7 1 1 532482 0 0 xdim ydim
		subvar TEMP 1
		subvar TEMP2 1
		screentext DIGITALNUM TEMP TEMP2 65536 0 0 500 -127 CL_TEMP2 16 0 6 7 1 1 532482 0 0 xdim ydim
		
		// Armor Icon
		setvar TEMP 56
		setvar TEMP2 181
		rotatespritea TEMP TEMP2 32768 0 SHIELD -127 4 16 128 windowx1 windowy1 windowx2 windowy2
		subvar TEMP 1
		subvar TEMP2 1
		rotatesprite TEMP TEMP2 32768 0 SHIELD -127 0 16 windowx1 windowy1 windowx2 windowy2
		
		// Armor Value
		getplayer[THISACTOR].shield_amount CL_TEMP1
		redefinequote 500 %d
		qsprintf 500 500 CL_TEMP1
		
		state health_color
		
		setvar TEMP 86
		setvar TEMP2 182
		screentext DIGITALNUM TEMP TEMP2 65536 0 0 500 -127 4 16 128 6 7 1 1 532482 0 0 xdim ydim
		subvar TEMP 1
		subvar TEMP2 1
		screentext DIGITALNUM TEMP TEMP2 65536 0 0 500 -127 CL_TEMP2 16 0 6 7 1 1 532482 0 0 xdim ydim
		
		// Inventory Icon
		getplayer[THISACTOR].inven_icon CL_TEMP1
		setvar CL_TEMP2 0
		
		switch CL_TEMP1
			case 1:
				setvar CL_TEMP1 FIRSTAID_ICON
				getplayer[THISACTOR].firstaid_amount TEMP3
				break
			case 2:
				setvar CL_TEMP1 STEROIDS_ICON
				getplayer[THISACTOR].steroids_amount TEMP3
				
				ifvarl TEMP3 400
				ifvarg TEMP3 0
				{
					setvar CL_TEMP2 1
				}
				
				addvar TEMP3 3
				shiftvarr TEMP3 2
				break
			case 3:
				setvar CL_TEMP1 HOLODUKE_ICON
				getplayer[THISACTOR].holoduke_on CL_TEMP2
				getplayer[THISACTOR].holoduke_amount TEMP3
				addvar TEMP3 15
				divvar TEMP3 24
				break
			case 4:
				setvar CL_TEMP1 JETPACK_ICON
				getplayer[THISACTOR].jetpack_on CL_TEMP2
				getplayer[THISACTOR].jetpack_amount TEMP3
				addvar TEMP3 15
				shiftvarr TEMP3 4
				break
			case 5:
				setvar CL_TEMP1 HEAT_ICON
				getplayer[THISACTOR].heat_on CL_TEMP2
				getplayer[THISACTOR].heat_amount TEMP3
				divvar TEMP3 12
				break
			case 6:
				setvar CL_TEMP1 AIRTANK_ICON
				getplayer[THISACTOR].scuba_on CL_TEMP2
				getplayer[THISACTOR].scuba_amount TEMP3
				addvar TEMP3 63
				shiftvarr TEMP3 6
				break
			case 7:
				setvar CL_TEMP1 BOOT_ICON
				getplayer[THISACTOR].boot_amount TEMP3
				shiftvarr TEMP3 1
				break
			default:
				setvar CL_TEMP1 -1
				break
		endswitch
		
		ifvarn CL_TEMP1 -1
		{
			setvar TEMP 113
			setvar TEMP2 188
			rotatespritea TEMP TEMP2 65536 0 CL_TEMP1 -127 4 10 128 windowx1 windowy1 windowx2 windowy2
			subvar TEMP 1
			subvar TEMP2 1
			rotatesprite TEMP TEMP2 65536 0 CL_TEMP1 -127 0 10 windowx1 windowy1 windowx2 windowy2
			
			ifvarg CL_TEMP2 0
			{
				setvar CL_TEMP1 SPINNINGNUKEICON
				setvarvar CL_TEMP2 totalclock
				divvar CL_TEMP2 2
				modvar CL_TEMP2 8
				addvarvar CL_TEMP1 CL_TEMP2
				rotatesprite 115 190 16384 0 CL_TEMP1 -127 0 10 windowx1 windowy1 windowx2 windowy2
			}
			
			setvarvar CL_TEMP1 TEMP3
			redefinequote 500 %d%%
			qsprintf 500 500 CL_TEMP1
			
			state health_color
			
			setvar TEMP 131
			setvar TEMP2 187
			screentext MINIFONT TEMP TEMP2 65536 0 0 500 -127 4 16 128 6 7 1 1 8194 0 0 xdim ydim
			subvar TEMP 1
			subvar TEMP2 1
			screentext MINIFONT TEMP TEMP2 65536 0 0 500 -127 CL_TEMP2 16 0 6 7 1 1 8194 0 0 xdim ydim
		}
		
		ifvarand gametype_flags 16384 { } // Start with all access cards
		else
		{
			// Keys
			setvar TEMP 293  // X
			setvar TEMP2 160 // Y
			setvar CL_TEMP2 0 // Key Count
			getplayer[THISACTOR].got_access CL_TEMP1
			
			ifvarand CL_TEMP1 1
				addvar CL_TEMP2 1
			ifvarand CL_TEMP1 2
				addvar CL_TEMP2 1
			ifvarand CL_TEMP1 4
				addvar CL_TEMP2 1
			
			ifvarg CL_TEMP2 1
			{
				subvar TEMP 1
				subvar TEMP2 1
			}
			ifvarg CL_TEMP2 2
			{
				subvar TEMP 2
				subvar TEMP2 2 
			}
			
			ifvarand CL_TEMP1 4 // Yellow
			{
				addvar TEMP 1
				addvar TEMP2 1 
				rotatespritea TEMP TEMP2 24576 0 ACCESSCARD -127 4 10 128 windowx1 windowy1 windowx2 windowy2
				subvar TEMP 1
				subvar TEMP2 1
				rotatesprite TEMP TEMP2 24576 0 ACCESSCARD -127 23 10 windowx1 windowy1 windowx2 windowy2
				addvar TEMP 3
				addvar TEMP2 3
			}
			
			ifvarand CL_TEMP1 2 // Red
			{
				addvar TEMP 1
				addvar TEMP2 1 
				rotatespritea TEMP TEMP2 24576 0 ACCESSCARD -127 4 10 128 windowx1 windowy1 windowx2 windowy2
				subvar TEMP 1
				subvar TEMP2 1
				rotatesprite TEMP TEMP2 24576 0 ACCESSCARD -127 21 10 windowx1 windowy1 windowx2 windowy2
				addvar TEMP 3
				addvar TEMP2 3
			}
			
			ifvarand CL_TEMP1 1 // Blue
			{
				addvar TEMP 1
				addvar TEMP2 1 
				rotatespritea TEMP TEMP2 24576 0 ACCESSCARD -127 4 10 128 windowx1 windowy1 windowx2 windowy2
				subvar TEMP 1
				subvar TEMP2 1
				rotatesprite TEMP TEMP2 24576 0 ACCESSCARD -127 0 10 windowx1 windowy1 windowx2 windowy2
				addvar TEMP 3
				addvar TEMP2 3
			}
		}
	
		setvar RETURN 1
	}
endevent

onevent EVENT_DISPLAYMENUREST // Version display. !UNSYNCHRONIZED!
	screentext 3072 316 180 65536 0 0 499 -127 6 536 0 3 5 1 1 8193 0 0 xdim ydim 
	
	switch CL_LASERCOLOR
		case 0:
			redefinequote 500 ^12Tripmine Laser Color: ^02Red
			break
		case 1:
			redefinequote 500 ^12Tripmine Laser Color: ^08Green
			break
		case 2:
			redefinequote 500 ^12Tripmine Laser Color: ^01Blue
			break
		case 3:
			redefinequote 500 ^12Tripmine Laser Color: ^07Yellow
			break
	endswitch
	
	screentext 3072 8 180 65536 0 0 500 -127 6 280 0 3 5 1 1 8192 0 0 xdim ydim
	
	ifvare CL_XXXCONTENT 1
		redefinequote 500 ^12XXX Content: ^08ON
	else
		redefinequote 500 ^12XXX Content: ^02OFF
	
	screentext 3072 8 174 65536 0 0 500 -127 6 280 0 3 5 1 1 8192 0 0 xdim ydim
endevent

onevent EVENT_DISPLAYROOMS // !UNSYNCHRONIZED!
	state handle_recoil
	state handle_shake_display
endevent

onevent EVENT_ENTERLEVEL
	readgamevar CL_XXXCONTENT
	readgamevar CL_LASERCOLOR
endevent

onevent EVENT_INIT
	readgamevar CL_XXXCONTENT
	readgamevar CL_LASERCOLOR
endevent

onevent EVENT_LOOKLEFT
	setvar RETURN -1
endevent

onevent EVENT_LOOKRIGHT
	setvar RETURN -1
endevent

onevent EVENT_SOUND
	getplayer[THISACTOR].gm CL_TEMP1
	ifvarand CL_TEMP1 1
	{
		switch RETURN
			case KICK_HIT:
				setvar RETURN MENU_MOVE
				break
			case PISTOL_BODYHIT:
				setvar RETURN MENU_CONFIRM
				break
			case EXITMENUSOUND:
				setvar RETURN MENU_BACK
				break
		endswitch
	}
	
	ifactor WATERSPLASH2
	{
		ifvare RETURN ITEM_SPLASH
		{
			ifspawnedby WATERBUBBLE
				setvar RETURN -1
		}
		break
	}
	
	ifactor SHOTSPARK1
	{
		ifvare RETURN PISTOL_RICOCHET
		{
			setvar RETURN -1
			break
		}
	}
	
	ifvare RETURN PISTOL_BODYHIT
	{
		getactor[THISACTOR].htpicnum CL_TEMP1
		ifvare CL_TEMP1 FLAMETHROWERFLAME
			setvar RETURN -1
	}
	else ifvare RETURN TELEPORTER
	{
		getsector[THISACTOR].floorpicnum CL_TEMP1
		switch CL_TEMP1
		{
			case 3520:
			case 3521:
			case 3522:
			case 3523:
				setvar RETURN -1
				break
		}
		endswitch
	}
	else ifvare RETURN SOMETHING_DRIPPING
	{
		displayrandvar CL_TEMP1 2
		switch CL_TEMP1
			case 0: setvar RETURN NEW_DRIP1 break
			case 1: setvar RETURN NEW_DRIP2 break
			case 2: setvar RETURN NEW_DRIP3 break
		endswitch
	}
	
	ifactor APLAYER
	{
		ifvare RETURN DUKE_USEMEDKIT
		{
			displayrandvar CL_TEMP1 100
			ifvarl CL_TEMP1 15
				setvar RETURN DUKE_USEMEDKIT2
		}
		else ifvare RETURN DUKE_UNDERWATER
		{
			getactor[THISACTOR].sectnum TEMP2
			ifvarg TEMP2 -1
			ifvarand SECTOR_TYPES[TEMP2] SECTORTYPE_SPACE
			{
				setvar RETURN -1
			}
		}
		else ifvare RETURN DUKE_WALKINDUCTS
		{
			displayrandvar CL_TEMP1 2
			switch CL_TEMP1
				case 0: setvar RETURN DUKE_WALKINDUCTS1 break
				case 1: setvar RETURN DUKE_WALKINDUCTS2 break
				case 2: setvar RETURN DUKE_WALKINDUCTS3 break
			endswitch
		}
	}
endevent

// Player Input
onevent EVENT_PROCESSINPUT
	state handle_rift
	state handle_sectortypes
	state handle_jumppad_movement
	state player_updateweapons
endevent
