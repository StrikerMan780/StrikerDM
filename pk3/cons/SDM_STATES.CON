state pass_on_respawn_vars
	setactorvar[RETURN].PICNUM_MEMORY PICNUM_MEMORY
	setactorvar[RETURN].HITAG_MEMORY HITAG_MEMORY
	setactorvar[RETURN].LOTAG_MEMORY LOTAG_MEMORY
	setactorvar[RETURN].XREPEAT_MEMORY XREPEAT_MEMORY
	setactorvar[RETURN].YREPEAT_MEMORY YREPEAT_MEMORY
	setactorvar[RETURN].CLIPDIST_MEMORY CLIPDIST_MEMORY
	setactorvar[RETURN].EXTRA_MEMORY EXTRA_MEMORY
	setactorvar[RETURN].CSTAT_MEMORY CSTAT_MEMORY
	setactorvar[RETURN].PAL_MEMORY PAL_MEMORY
	setactorvar[RETURN].STATNUM_MEMORY STATNUM_MEMORY
	setactorvar[RETURN].SPAWN_ORIGX SPAWN_ORIGX
	setactorvar[RETURN].SPAWN_ORIGY SPAWN_ORIGY
	setactorvar[RETURN].SPAWN_ORIGZ SPAWN_ORIGZ
	setactorvar[RETURN].SPAWN_ORIGANG SPAWN_ORIGANG
ends

state prepare_respawn_hardcoded
	ifvare COOP GM_COOPERATIVE
	{
		break // Do not respawn stuff in COOP.
	}
	else ifvarl MULTIMODE 2
	{
		break // Nor singleplayer.
	}
	
	espawn RESPAWNHANDLER
	state pass_on_respawn_vars
	setvar RETURN 0
ends

actor RESPAWNHANDLER 0
{
	ifcount RESPAWNPROPTIME
	{
		espawnvar PICNUM_MEMORY
		state pass_on_respawn_vars
		setactor[RETURN].picnum PICNUM_MEMORY
		setactor[RETURN].hitag HITAG_MEMORY
		setactor[RETURN].lotag LOTAG_MEMORY
		setactor[RETURN].xrepeat XREPEAT_MEMORY
		setactor[RETURN].yrepeat YREPEAT_MEMORY
		setactor[RETURN].clipdist CLIPDIST_MEMORY
		setactor[RETURN].extra EXTRA_MEMORY
		setactor[RETURN].cstat CSTAT_MEMORY
		setactor[RETURN].pal PAL_MEMORY
		setactor[RETURN].x SPAWN_ORIGX
		setactor[RETURN].y SPAWN_ORIGY
		setactor[RETURN].z SPAWN_ORIGZ
		setactor[RETURN].ang SPAWN_ORIGANG
		changespritestat RETURN STATNUM_MEMORY
		setvar RETURN 0
		
		ifvarand CSTAT_MEMORY 32768
		{
			// Do nothing
		}
		else
		{
			spawn TRANSPORTERSTAR
		}
		killit
	}
}
enda

state item_despawn_timer
	ifvare DESPAWN_TYPE 0
	{
		ifspawnedby CANWITHSOMETHING setvar DESPAWN_TYPE 1
		else ifspawnedby CANWITHSOMETHING2 setvar DESPAWN_TYPE 1
		else ifspawnedby CANWITHSOMETHING3 setvar DESPAWN_TYPE 1
		else ifspawnedby CANWITHSOMETHING4 setvar DESPAWN_TYPE 1
		else ifspawnedby RUBBERCAN setvar DESPAWN_TYPE 1
		else ifspawnedby SHARDFLOWER setvar DESPAWN_TYPE 1
		else ifspawnedby LIFEFLOWER setvar DESPAWN_TYPE 1
	}
	
	ifvare COOP GM_COOPERATIVE
	{
		break // Do not despawn stuff in COOP.
	}
	else ifvarl MULTIMODE 2
	{
		break // Nor singleplayer.
	}
	
	ifvare DESPAWN_TYPE 1
	{
		ifcount RESPAWNPROPTIME
		{
			killit
		}
	}
	else ifvare DESPAWN_TYPE 2
	{
		ifcount BABERESPAWNTIME
		{
			killit
		}
	}
ends

state check_if_multiplayer_only
	ifmultiplayer
	{
		setactor[THISACTOR].pal 0
	}
	else
	{
		getactor[THISACTOR].pal TEMP
		ifvarn TEMP 0
		{
			killit
		}
	}
ends

state create_spawn_marker
	espawn RESPAWNMARKERRED
	setactorvar[RETURN].QUAKE3BOB QUAKE3BOB
	setvar RETURN 0
ends

state yeet_item_on_drop
	ifspawnedby SCRAP1
		break
		
	getactor[THISACTOR].htowner TEMP
	ifvarvarn THISACTOR TEMP
	{
		getactor[THISACTOR].z SPAWN_ORIGZ
		subvar SPAWN_ORIGZ 8192
			
		setactor[THISACTOR].z SPAWN_ORIGZ
		setactor[THISACTOR].zvel -1024
	}
ends

state item_shared_code
	ifaction 0
	{
		action ANULLACTION
		cstat 0
		
		ifvare HITAG_MEMORY 1
		{
			addvar QUAKE3BOB_SEQUENCE 64
			setvarvar QUAKE3BOB QUAKE3BOB_SEQUENCE
			getactor[THISACTOR].mdflags TEMP2
			orvar TEMP2 16
			setactor[THISACTOR].mdflags TEMP2
		}
		
		getactor[THISACTOR].picnum TEMP
		switch TEMP
			case PLASMASPRITE:
			case PLASMAAMMO:
			case RAILGUNSPRITE:
			case FLAMETHROWERSPRITE:
			case FLAMETHROWERAMMO:
			case SSGSPRITE:
			case GROWSPRITEICON:
				state check_if_multiplayer_only
				state yeet_item_on_drop
				sizeat 32 32
				break
			case DFGSPRITE:
			case DFGAMMO:
				state check_if_multiplayer_only
				state yeet_item_on_drop
				sizeat 28 28
				break
			case RAILGUNAMMO:
				state check_if_multiplayer_only
				state yeet_item_on_drop
				sizeat 16 16
				break
			case HEALTHBONER:
			case ARMORBONER:
				state check_if_multiplayer_only
				state yeet_item_on_drop
				sizeat 32 28
				break
			case CRYSTALSHARD:
			case LIFEPETAL:
				state check_if_multiplayer_only
				sizeat 48 40
				setactor[THISACTOR].shade -127
				break
		endswitch
	}
	
	ifvare QUAKE3BOB 0
	ifvare TARGET -1
		fall
		
	state item_despawn_timer
ends

state roids_voices
	randvar RANDOM_SOUND 3
	switch RANDOM_SOUND
		case 0: sound DUKE_ROIDS01 break
		case 1: sound DUKE_ROIDS02 break
		case 2: sound DUKE_ROIDS03 break
		case 3: sound DUKE_ROIDS04 break
	endswitch
ends

state jib_sounds
	// Duke's got a more serious tone in this map, break so he shuts up.
	ifvare DEMENTIA 1
		break
		
	getactor[LASTHITBY].picnum TEMP
	getactor[LASTHITBY].extra TEMP2
	ifvare TEMP APLAYER
	ifvarg TEMP2 0
	ifvarvarn THISACTOR LASTHITBY
	{
		ifrnd SWEARFREQUENCY
		{
			ifvare KILLTYPE KILL_FREEZER
			{
				randvar RANDOM_SOUND 6
				switch RANDOM_SOUND
					case 0: actorsound LASTHITBY FREEZE01 break
					case 1: actorsound LASTHITBY FREEZE02 break
					case 2: actorsound LASTHITBY FREEZE03 break
					case 3: actorsound LASTHITBY FREEZE04 break
					case 4: actorsound LASTHITBY FREEZE05 break
					case 5: actorsound LASTHITBY FREEZE06 break
					case 6: actorsound LASTHITBY FREEZE07 break
				endswitch
			}
			else ifvare KILLTYPE KILL_FLAME
			{
				randvar RANDOM_SOUND 8
				switch RANDOM_SOUND
					case 0: actorsound LASTHITBY DUKE_FLAME01 break
					case 1: actorsound LASTHITBY DUKE_FLAME02 break
					case 2: actorsound LASTHITBY DUKE_FLAME03 break
					case 3: actorsound LASTHITBY DUKE_FLAME04 break
					case 4: actorsound LASTHITBY DUKE_FLAME05 break
					case 5: actorsound LASTHITBY DUKE_FLAME06 break
					case 6: actorsound LASTHITBY DUKE_FLAME07 break
					case 7: actorsound LASTHITBY DUKE_FLAME08 break
					case 8: actorsound LASTHITBY DUKE_FLAME09 break
				endswitch
			}
			else ifvare KILLTYPE KILL_SHRINKER
			{
				randvar RANDOM_SOUND 19
				switch RANDOM_SOUND
					case 0: actorsound LASTHITBY STOMP01 break
					case 1: actorsound LASTHITBY STOMP02 break
					case 2: actorsound LASTHITBY STOMP03 break
					case 3: actorsound LASTHITBY STOMP04 break
					case 4: actorsound LASTHITBY STOMP05 break
					case 5: actorsound LASTHITBY STOMP06 break
					case 6: actorsound LASTHITBY STOMP07 break
					case 7: actorsound LASTHITBY STOMP08 break
					case 8: actorsound LASTHITBY STOMP09 break
					case 9: actorsound LASTHITBY STOMP10 break
					case 10: actorsound LASTHITBY STOMP11 break
					case 11: actorsound LASTHITBY STOMP12 break
					case 12: actorsound LASTHITBY STOMP13 break
					case 13: actorsound LASTHITBY STOMP14 break
					case 14: actorsound LASTHITBY STOMP15 break
					case 15: actorsound LASTHITBY STOMP16 break
					case 16: actorsound LASTHITBY STOMP17 break
					case 17: actorsound LASTHITBY STOMP18 break
					case 18: actorsound LASTHITBY STOMP19 break
					case 19: actorsound LASTHITBY STOMP20 break
				endswitch
			}
			else
			{
				randvar RANDOM_SOUND 69
				switch RANDOM_SOUND
					case 0: actorsound LASTHITBY JIBBED_ACTOR1 break
					case 1: actorsound LASTHITBY JIBBED_ACTOR2 break
					case 2: actorsound LASTHITBY JIBBED_ACTOR3 break
					case 3: actorsound LASTHITBY JIBBED_ACTOR4 break
					case 4: actorsound LASTHITBY JIBBED_ACTOR5 break
					case 5: actorsound LASTHITBY JIBBED_ACTOR6 break
					case 6: actorsound LASTHITBY JIBBED_ACTOR7 break
					case 7: actorsound LASTHITBY JIBBED_ACTOR8 break
					case 8: actorsound LASTHITBY JIBBED_ACTOR9 break
					case 9: actorsound LASTHITBY JIBBED_ACTOR10 break
					case 10: actorsound LASTHITBY JIBBED_ACTOR11 break
					case 11: actorsound LASTHITBY JIBBED_ACTOR12 break
					case 12: actorsound LASTHITBY JIBBED_ACTOR13 break
					case 13: actorsound LASTHITBY JIBBED_ACTOR14 break
					case 14: actorsound LASTHITBY JIBBED_ACTOR15 break
					case 15: actorsound LASTHITBY SMACKED break
					case 16: actorsound LASTHITBY MDEVSPEECH break
					case 17: actorsound LASTHITBY NEWDUKEGIB01 break
					case 18: actorsound LASTHITBY NEWDUKEGIB02 break
					case 19: actorsound LASTHITBY NEWDUKEGIB03 break
					case 20: actorsound LASTHITBY NEWDUKEGIB04 break
					case 21: actorsound LASTHITBY NEWDUKEGIB05 break
					case 22: actorsound LASTHITBY NEWDUKEGIB06 break
					case 23: actorsound LASTHITBY NEWDUKEGIB07 break
					case 24: actorsound LASTHITBY NEWDUKEGIB08 break
					case 25: actorsound LASTHITBY NEWDUKEGIB09 break
					case 26: actorsound LASTHITBY NEWDUKEGIB10 break
					case 27: actorsound LASTHITBY NEWDUKEGIB11 break
					case 28: actorsound LASTHITBY NEWDUKEGIB12 break
					case 29: actorsound LASTHITBY NEWDUKEGIB13 break
					case 30: actorsound LASTHITBY NEWDUKEGIB14 break
					case 31: actorsound LASTHITBY NEWDUKEGIB15 break
					case 32: actorsound LASTHITBY NEWDUKEGIB16 break
					case 33: actorsound LASTHITBY NEWDUKEGIB17 break
					case 34: actorsound LASTHITBY NEWDUKEGIB18 break
					case 35: actorsound LASTHITBY NEWDUKEGIB19 break
					case 36: actorsound LASTHITBY NEWDUKEGIB20 break
					case 37: actorsound LASTHITBY NEWDUKEGIB21 break
					case 38: actorsound LASTHITBY NEWDUKEGIB22 break
					case 39: actorsound LASTHITBY NEWDUKEGIB23 break
					case 40: actorsound LASTHITBY NEWDUKEGIB24 break
					case 41: actorsound LASTHITBY NEWDUKEGIB25 break
					case 42: actorsound LASTHITBY NEWDUKEGIB26 break
					case 43: actorsound LASTHITBY NEWDUKEGIB27 break
					case 44: actorsound LASTHITBY NEWDUKEGIB28 break
					case 45: actorsound LASTHITBY NEWDUKEGIB29 break
					case 46: actorsound LASTHITBY NEWDUKEGIB30 break
					case 47: actorsound LASTHITBY NEWDUKEGIB31 break
					case 48: actorsound LASTHITBY NEWDUKEGIB32 break
					case 49: actorsound LASTHITBY NEWDUKEGIB33 break
					case 50: actorsound LASTHITBY NEWDUKEGIB34 break
					case 51: actorsound LASTHITBY NEWDUKEGIB35 break
					case 52: actorsound LASTHITBY NEWDUKEGIB36 break
					case 53: actorsound LASTHITBY NEWDUKEGIB37 break
					case 54: actorsound LASTHITBY NEWDUKEGIB38 break
					case 55: actorsound LASTHITBY NEWDUKEGIB39 break
					case 56: actorsound LASTHITBY NEWDUKEGIB40 break
					case 57: actorsound LASTHITBY NEWDUKEGIB41 break
					case 58: actorsound LASTHITBY NEWDUKEGIB42 break
					case 59: actorsound LASTHITBY NEWDUKEGIB43 break
					case 60: actorsound LASTHITBY NEWDUKEGIB44 break
					case 61: actorsound LASTHITBY NEWDUKEGIB45 break
					case 62: actorsound LASTHITBY NEWDUKEGIB46 break
					case 63: actorsound LASTHITBY NEWDUKEGIB47 break
					case 64: actorsound LASTHITBY NEWDUKEGIB48 break
					case 65: actorsound LASTHITBY NEWDUKEGIB49 break
					case 66: actorsound LASTHITBY NEWDUKEGIB50 break
					case 67: ifrnd 16 actorsound LASTHITBY NEWDUKEGIB51 break
					case 68: actorsound LASTHITBY NEWDUKEGIB52 break
					case 69: actorsound LASTHITBY NEWDUKEGIB53 break
					case 70: actorsound LASTHITBY NEWDUKEGIB54 break
				endswitch
			}
		}
	}
	
	setvar KILLTYPE KILL_NONE
ends

state randgetweapsnds
	// Duke's got a more serious tone in this map, break so he shuts up.
	ifvare DEMENTIA 1
		break

	randvar RANDOM_SOUND 15
	switch RANDOM_SOUND
		case 0: globalsound BONUS_SPEECH4 break
		case 1: globalsound DUKE_GETWEAPON1 break
		case 2: globalsound DUKE_GETWEAPON2 break
		case 3: globalsound DUKE_GETWEAPON3 break
		case 4: globalsound DUKE_GETWEAPON4 break
		case 5: globalsound DUKE_GETWEAPON5 break
		case 6: globalsound DUKE_GETWEAPON6 break
		case 7: globalsound DUKE_GETWEAPON7 break
		case 8: globalsound DUKE_GETWEAPON8 break
		case 9: globalsound DUKE_GETWEAPON9 break
		case 10: globalsound DUKE_GETWEAPON10 break
		case 11: globalsound DUKE_GETWEAPON11 break
		case 12: globalsound DUKE_GETWEAPON12 break
		case 13: globalsound DUKE_GETWEAPON13 break
		case 14: globalsound DUKE_GETWEAPON14 break
		case 15: globalsound DUKE_GETWEAPON15 break
	endswitch
ends

state quikweaponget_custom
  state randgetweapsnds
  palfrom 32 0 32
  killit
ends

state getcode_custom
  globalsound DUKE_GET
  palfrom 16 0 32
  ifvare RESPAWN_ITEMS 1
  {
    move RESPAWN_ACTOR_FLAG
    state create_spawn_marker
    cstat 32768
  }
  else
    killit
ends

state get_squisher
	findotherplayer TEMP
	getplayer[RETURN].i TEMP2
	setvarvar LASTHITBY TEMP2
ends

state randomize_colored_scrap
	randvar TEMP 256
	randvar TEMP2 -4096
	randvar TEMP3 2048
	setactor[RETURN].xvel TEMP
	setactor[RETURN].zvel TEMP2
	setactor[RETURN].ang TEMP3
	
	ifactor FLESHLIGHT
	{
		setactor[RETURN].pal 2
		setthisprojectile[RETURN].pal 2
	}
	else
	{
		setactor[RETURN].pal PAL_MEMORY
		setthisprojectile[RETURN].pal PAL_MEMORY
	}
	
	setvar RETURN 0
ends

state toss_colored_scrap
	eshoot COLORSCRAP1
	state randomize_colored_scrap
	eshoot COLORSCRAP2
	state randomize_colored_scrap
	eshoot COLORSCRAP3
	state randomize_colored_scrap
	eshoot COLORSCRAP4
	state randomize_colored_scrap
ends

state coloredprop_break
	ifaction 0
	{
		action ANULLACTION
		cstator 257
	}
	
	ifhitweapon
	ifdead
	{
		cstat 32768
		
		state toss_colored_scrap
		
		getactor[THISACTOR].picnum TEMP
		switch TEMP
			case BD_SOFIA:
				state toss_colored_scrap
				break
			case FLESHLIGHT:
				sound SQUISHED
			case VIBRATOR:
				sound VENT_BUST
				lotsofglass 5
				debris SCRAP1 2
				debris SCRAP2 2
				debris SCRAP3 2
				break
		endswitch
		
		killit
	}
ends

state handle_jumppad
	ifvare JUMPPAD_HIT 0
	{
		ifp ponground
		{
			// TEMP = X
			// TEMP2 = Y
			// TEMP3 = Sector Number
			getplayer[THISACTOR].posx TEMP
			getplayer[THISACTOR].posy TEMP2
			getplayer[THISACTOR].cursectnum TEMP3
			
			// Set TEMP to florz
			getflorzofslope TEMP3 TEMP TEMP2 TEMP
			subvar TEMP 16384 // Subtract height
			
			getplayer[THISACTOR].posz TEMP2			
			ifvarvarg TEMP2 TEMP // Touching floor?
			{
				sound JUMPPADSOUND
				setplayer[THISACTOR].on_ground 0 // No longer on the ground.
					
				getplayer[THISACTOR].posz TEMP // Kick them off the ground a little, to stop them from being "magnetized" to the ground.
				subvar TEMP 16384
				setplayer[THISACTOR].posz TEMP
					
				getplayer[THISACTOR].cursectnum TEMP
				ifvare SECTOR_JUMPZ[TEMP] 0
				{
					setvar TEMP2 -4096 // If not hitag is set, -4096 is the default velocity.
				}
				else ifvarg SECTOR_JUMPZ[TEMP] 0
				{
					setvar TEMP2 0
					subvarvar TEMP2 SECTOR_JUMPZ[TEMP]
				}
					
				setplayer[THISACTOR].poszv TEMP2 // Launch				
				setvar JUMPPAD_HIT 1 // They're in the air.
					
				// Set X/Y Velocities
				setvarvar TEMP2 SECTOR_JUMPX[TEMP]
				mulvar TEMP2 1024
				setvarvar JUMPPAD_XVEL TEMP2
					
				setvarvar TEMP2 SECTOR_JUMPY[TEMP]
				mulvar TEMP2 1024
				setvarvar JUMPPAD_YVEL TEMP2
			}
		}
		else
		{
			getplayer[THISACTOR].truefz TEMP
			getplayer[THISACTOR].posz TEMP2
			subvar TEMP 16384 // Subtract height
			ifvarvarg TEMP2 TEMP // Touching floor?
			{
				setplayer[THISACTOR].falling_counter 0 // Prevent fall damage
			}
		}
	}
ends

state handle_jumppad_movement
	ifvare JUMPPAD_HIT 1
	{
		setplayer[THISACTOR].falling_counter 0 // No falling damage on jump pads.
		
		ifvarn JUMPPAD_XVEL 0
		{
			setplayer[THISACTOR].posxv JUMPPAD_XVEL
		}
		
		ifvarn JUMPPAD_YVEL 0
		{
			setplayer[THISACTOR].posyv JUMPPAD_YVEL
		}
		
		ifp pdead
		{
			setvar JUMPPAD_HIT 0 // No longer launched by jump pad when player gets killed
			setvar JUMPPAD_XVEL 0
			setvar JUMPPAD_YVEL 0
		}
		else ifp ponground
		{
			setvar JUMPPAD_HIT 0 // No longer launched by jump pad when player hits the ground
			setvar JUMPPAD_XVEL 0
			setvar JUMPPAD_YVEL 0
		}
		else ifp pjetpack
		{
			setvar JUMPPAD_HIT 0 // If they use the jetpack, prevent them from cheating the jump pads to stop fall damage.
			setvar JUMPPAD_XVEL 0
			setvar JUMPPAD_YVEL 0
		}
		else ifinwater
		{
			setvar JUMPPAD_HIT 0 // Cancel out if landed in water.
			setvar JUMPPAD_XVEL 0
			setvar JUMPPAD_YVEL 0
		}
	}
ends

state handle_lowgravity
	getplayer[THISACTOR].poszv TEMP
	ifvarg TEMP 512
	{
		setplayer[THISACTOR].poszv 512
	}
	
	setplayer[THISACTOR].falling_counter 0
	
	getplayer[THISACTOR].jumping_counter TEMP
	ifvare TEMP 1261 
	{
		setplayer[THISACTOR].jumping_counter 902
	}
ends

state handle_sectortypes
	ifp palive
	{
		getplayer[THISACTOR].cursectnum TEMP
		ifvarg TEMP -1
		{
			ifvarand SECTOR_TYPES[TEMP] SECTORTYPE_LOWGRAVITY
			{
				state handle_lowgravity
			}
		}
		
		getplayer[THISACTOR].cursectnum TEMP
		ifvarg TEMP -1
		{
			ifvarand SECTOR_TYPES[TEMP] SECTORTYPE_JUMPPAD
			{
				state handle_jumppad
			}
		}
		
		getplayer[THISACTOR].cursectnum TEMP4
		ifvarg TEMP4 -1
		{
			getsector[TEMP4].lotag TEMP
			ifvare TEMP 256
			{
				getplayer[THISACTOR].posx TEMP
				getplayer[THISACTOR].posy TEMP2
				getplayer[THISACTOR].posz TEMP3
				getflorzofslope TEMP4 TEMP TEMP2 TEMP
				subvar TEMP 10240 // Subtract height
				
				ifvarvarg TEMP3 TEMP // Touching floor?
				{
					setactor[THISACTOR].htextra 1000
					setactor[THISACTOR].htpicnum RADIUSEXPLOSION
				}
			}
		}
	}
ends

state handle_rift
	ifp palive
	{
		ifinwater
		{
			break
		}
		
		getsector[THISACTOR].floorpicnum TEMP
		getsector[THISACTOR].ceilingpicnum TEMP2
		ifvarvare TEMP TEMP2
		{
			ifvare TEMP 3817
			{
				ifvare IN_RIFT 0
				{
					sound ENTER_RIFT
					palfrom 56 0 16 64
					setvar IN_RIFT 1
				}
				else
				{
					getplayer[THISACTOR].pals_time TEMP
					ifvarl TEMP 24
					{
						palfrom 24 0 16 64
					}
					
					state handle_lowgravity
				}
				
				break
			}
		}

		ifvare IN_RIFT 1
		{
			sound EXIT_RIFT
			palfrom 48 0 16 64
			setvar IN_RIFT 0
		}
	}
ends

state strip_items
	getactor[THISACTOR].picnum TEMP
	switch TEMP
		case FIRSTGUNSPRITE:
		case SHOTGUNSPRITE:
		case DEVISTATORSPRITE:
		case CHAINGUNSPRITE:
		case SHRINKERSPRITE:
		case HBOMBAMMO:
		case RPGSPRITE:
		case TRIPBOMBSPRITE:
		case FREEZESPRITE:
		case PLASMASPRITE:
		case FLAMETHROWERSPRITE:
		case RAILGUNSPRITE:
		case SSGSPRITE:
		case DFGSPRITE:
		case AMMO:
		case AMMOLOTS:
		case BATTERYAMMO:
		case FREEZEAMMO:
		case SHOTGUNAMMO:
		case CRYSTALAMMO:
		case GROWAMMO:
		case RPGAMMO:
		case DEVISTATORAMMO:
		case PLASMAAMMO:
		case RAILGUNAMMO:
		case DFGAMMO:
		case FLAMETHROWERAMMO:
		case JETPACK:
			killit
			break
		endswitch
ends

state gibsound
	randvar RANDOM_SOUND 6
	switch RANDOM_SOUND
		case 0: sound GIB_SPLAT1 break
		case 1: sound GIB_SPLAT2 break
		case 2: sound GIB_SPLAT3 break
		case 3: sound GIB_SPLAT4 break
		case 4: sound GIB_SPLAT5 break
		case 5: sound GIB_SPLAT6 break
		case 6: sound GIB_SPLAT7 break
	endswitch
ends

state spawn_random_whispysmoke
	espawn WHISPYSMOKE
	getactor[THISACTOR].x TEMP
	randvar TEMP2 256
	subvar TEMP2 128
	addvarvar TEMP TEMP2
	setactor[RETURN].x TEMP
			
	getactor[THISACTOR].y TEMP
	randvar TEMP2 256
	subvar TEMP2 128
	addvarvar TEMP TEMP2
	setactor[RETURN].y TEMP
		
	ifactor BURNEDCORPSE { }
	else
	{
		getactor[THISACTOR].z TEMP
		randvar TEMP2 8192
		subvarvar TEMP TEMP2
		setactor[RETURN].z TEMP
	}
	
	setvar RETURN 0
ends

state spawn_random_fire
	// Fire Sprites
	
	getactor[THISACTOR].picnum STATE_TEMP1
	gettiledata[STATE_TEMP1].xsize STATE_TEMP2
	gettiledata[STATE_TEMP1].ysize STATE_TEMP3
	getactor[THISACTOR].xrepeat TEMP
	getactor[THISACTOR].yrepeat TEMP2
	mulvarvar STATE_TEMP2 TEMP
	mulvarvar STATE_TEMP3 TEMP2
	
	setvarvar TEMP2 STATE_TEMP2
	addvarvar TEMP2 STATE_TEMP3
	shiftvarr TEMP2 11
	ifvarl TEMP2 1
		setvar TEMP2 1
	
	// STATE_TEMP2 = X/Y
	// STATE_TEMP3 = Z
	setvar STATE_TEMP1 0
	whilevarvarn STATE_TEMP1 TEMP2
	{
		espawn ONFIRE

		setvarvar TEMP3 STATE_TEMP2
		shiftvarr TEMP3 3
		randvarvar TEMP4 TEMP3
		shiftvarr TEMP3 1
		subvarvar TEMP4 TEMP3
		getactor[THISACTOR].x TEMP3
		addvarvar TEMP3 TEMP4
		setactor[RETURN].x TEMP3
		
		setvarvar TEMP3 STATE_TEMP2
		shiftvarr TEMP3 3
		randvarvar TEMP4 TEMP3
		shiftvarr TEMP3 1
		subvarvar TEMP4 TEMP3
		getactor[THISACTOR].y TEMP3
		addvarvar TEMP3 TEMP4
		setactor[RETURN].y TEMP3
		
		setvarvar TEMP3 STATE_TEMP3
		shiftvarl TEMP3 2
		randvarvar TEMP4 TEMP3
		getactor[THISACTOR].z TEMP3
		subvarvar TEMP3 TEMP4
		setactor[RETURN].z TEMP3
		
		addvar STATE_TEMP1 1
		
		setvar RETURN 0
	}
	
ends

state stop_player_burn
	getplayer[THISACTOR].i TEMP
	getactorvar[TEMP].BURNING_TICS TEMP
	ifvarg TEMP 0
	{
		setplayervar[THISACTOR].STOP_BURNING 1
		state spawn_random_whispysmoke
		state spawn_random_whispysmoke
		state spawn_random_whispysmoke
		state spawn_random_whispysmoke
		state spawn_random_whispysmoke
	}
ends

defstate generic_burn_death
	setactor[THISACTOR].pal 4
	state spawn_random_whispysmoke
	state spawn_random_whispysmoke
	state spawn_random_whispysmoke
	state spawn_random_whispysmoke
	state spawn_random_whispysmoke
	
	setvar KILLTYPE KILL_FLAME
	state jib_sounds
	
	espawn BURNTENEMY
	getactor[THISACTOR].xrepeat TEMP
	setactor[RETURN].xrepeat TEMP
	getactor[THISACTOR].yrepeat TEMP
	setactor[RETURN].yrepeat TEMP
	
	getactor[THISACTOR].picnum TEMP
	ifactor NEWBEAST // Special case for NEWBEAST.
		setvar TEMP 4620
	setactorvar[RETURN].PICNUM_MEMORY TEMP
	setvar RETURN 0
	
	espawn BURNING2_ALT
	setactor[RETURN].owner LASTHITBY
	setvar RETURN 0
	
	killit
ends

state gore_movement
	getactor[THISACTOR].xvel TEMP
	ifvarg TEMP 0
	{
		subvar TEMP 1
	}
	else
	{
		setvar TEMP 0
	}
	setactor[THISACTOR].xvel TEMP
	
	getactor[THISACTOR].zvel TEMP
	ifvarg TEMP 1024
	ifvarl TEMP 1280
	{
		getactor[THISACTOR].x TEMP
		getactor[THISACTOR].y TEMP2
		getactor[THISACTOR].z TEMP3
		setsprite THISACTOR TEMP TEMP2 TEMP3
	}
	
	getactor[THISACTOR].zvel TEMP
	ifvarl TEMP 6144
	{
		getsector[THISACTOR].lotag TEMP2
		ifvare TEMP2 2
		{
			ifvarl TEMP 1024
			{
				addvar TEMP 48
			}
			else
			{
				setvar TEMP 1024
			}
		}
		else
		{
			// Subtract 50 from the gravitational constant for a slower fall.
			setvarvar TEMP2 gravitationalconstant
			subvar TEMP2 50
			addvarvar TEMP TEMP2
		}
	}
	setactor[THISACTOR].zvel TEMP
	
	// Get sine of angle+512
	getactor[THISACTOR].ang TEMP2
	addvar TEMP2 512
	sin TEMP TEMP2
	
	// Multiply sine by xvel, and right-shift bits by 14
	getactor[THISACTOR].xvel TEMP2
	mulvarvar TEMP TEMP2
	shiftvarr TEMP 14
	
	// Add result to x coord.
	getactor[THISACTOR].x TEMP2
	addvarvar TEMP2 TEMP
	setactor[THISACTOR].x TEMP2
	
	// Get sine of angle
	getactor[THISACTOR].ang TEMP2
	sin TEMP TEMP2
	
	// Multiply sine by xvel, and right-shift bits by 14
	getactor[THISACTOR].xvel TEMP2
	mulvarvar TEMP TEMP2
	shiftvarr TEMP 14
	
	// Add result to y coord.
	getactor[THISACTOR].y TEMP2
	addvarvar TEMP2 TEMP
	setactor[THISACTOR].y TEMP2
	
	// Add zvel to z coord.
	getactor[THISACTOR].z TEMP
	getactor[THISACTOR].zvel TEMP2
	addvarvar TEMP TEMP2
	setactor[THISACTOR].z TEMP
ends

state spawn_tracer
	ifvare DEMENTIA 1 // No tracers in dementia mode.
		break
		
	// Check distance from owner, if closer than 4096 units, don't spawn.
	getactor[THISACTOR].owner TEMP
	ldist TEMP2 THISACTOR TEMP
	ifvarl TEMP2 4096 break
	
	// Divide distance by TRACERTIME
	divvar TEMP2 TRACERTIME
	shiftvarl TEMP2 4
	
	// Get coords of shooter.
	getactor[TEMP].picnum TEMP4
	ifvare TEMP4 APLAYER
	{
		getactor[TEMP].yvel TEMP4
		getplayer[TEMP4].oposx SPAWN_ORIGX
		getplayer[TEMP4].oposy SPAWN_ORIGY
		getplayer[TEMP4].oposz SPAWN_ORIGZ
		getplayer[TEMP4].opyoff TEMP4
		addvar SPAWN_ORIGZ 1024
		addvarvar SPAWN_ORIGZ TEMP4
	}
	else
	{
		getactor[TEMP].x SPAWN_ORIGX
		getactor[TEMP].y SPAWN_ORIGY
		getactor[TEMP].z SPAWN_ORIGZ
		subvar SPAWN_ORIGZ 8192 // Move z coord up a bit so we're not shooting from our feet.
	}
	
	// Get an X/Y offset
	getactor[THISACTOR].ang SPAWN_ORIGANG
	setvarvar TEMP3 SPAWN_ORIGANG
	addvar TEMP3 348 // ?
	cos TEMP3 TEMP3
	divvar TEMP3 512 // Offset?
	addvarvar SPAWN_ORIGX TEMP3
	
	setvarvar TEMP3 SPAWN_ORIGANG
	addvar TEMP3 348 // ?
	sin TEMP3 TEMP3
	divvar TEMP3 512 // Offset?
	addvarvar SPAWN_ORIGY TEMP3
	
	// Get coords of impact point. This will be replaced by a translation
	getactor[THISACTOR].x DEST_X
	getactor[THISACTOR].y DEST_Y
	getactor[THISACTOR].z DEST_Z
	
	// Get x/y/z translation between source and destination.
	subvarvar DEST_X SPAWN_ORIGX
	subvarvar DEST_Y SPAWN_ORIGY
	subvarvar DEST_Z SPAWN_ORIGZ
	
	// Divide translation by tracer lifetime in tics.
	// This results in how many units on x/y/z we want to move per tic.
	divvar DEST_X TRACERTIME
	divvar DEST_Y TRACERTIME
	divvar DEST_Z TRACERTIME
	
	// Get pitch based on distance and z offset.
	getangle TEMP3 TEMP2 DEST_Z
	ifvarg TEMP3 1023 // If pitch is greater than 1023, subtract 2048, like in the source.
	{
		subvar TEMP3 2048
	}
		
	// Spawn tracer at source, copy DEST_X/Y/Z
	espawnvar STATE_PARAM1
	setactor[RETURN].x SPAWN_ORIGX
	setactor[RETURN].y SPAWN_ORIGY
	setactor[RETURN].z SPAWN_ORIGZ
	setactor[RETURN].htbposx SPAWN_ORIGX
	setactor[RETURN].htbposy SPAWN_ORIGY
	setactor[RETURN].htbposz SPAWN_ORIGZ
	setactor[RETURN].pitch TEMP3 // Set model pitch
	setactorvar[RETURN].DEST_X DEST_X
	setactorvar[RETURN].DEST_Y DEST_Y
	setactorvar[RETURN].DEST_Z DEST_Z
	setvar RETURN 0
ends

state tracer_movement
	ifcount TRACERTIME killit
															// Proposed refactor?
	getactor[THISACTOR].x SPAWN_ORIGX 						// TEMP
	getactor[THISACTOR].y SPAWN_ORIGY 						// TEMP2
	getactor[THISACTOR].z SPAWN_ORIGZ 						// TEMP3
	addvarvar SPAWN_ORIGX DEST_X 							// TEMP SPAWN_ORIGX
	addvarvar SPAWN_ORIGY DEST_Y 							// TEMP2 SPAWN_ORIGY
	addvarvar SPAWN_ORIGZ DEST_Z 							// TEMP3 SPAWN_ORIGZ
	setsprite THISACTOR SPAWN_ORIGX SPAWN_ORIGY SPAWN_ORIGZ // TEMP TEMP2 TEMP3
	
	ifinwater
	{
		ifrnd 48
			spawn WATERBUBBLE
	}
ends

state spawn_explosion_spark
	espawn EXPLOSIONSPARK
	getactor[THISACTOR].pal TEMP2
	setactor[RETURN].pal TEMP2
	
	ifactor TANK
	{
		randvar TEMP 512
		addvar TEMP 128
	}
	else
	{
		randvar TEMP 128
		addvar TEMP 32
	}
	setactor[RETURN].xvel TEMP
				
	setvar TEMP -512
	randvar TEMP2 2048
	subvarvar TEMP TEMP2
	setactor[RETURN].zvel TEMP
				
	randvar TEMP 2047
	setactor[RETURN].ang TEMP
	setvar RETURN 0
ends

// STATE_PARAM1 = Base Intensity
// STATE_PARAM2 = Radius
defstate start_shake
	ifvarl STATE_PARAM2 1 // < 1 is invalid.
		break
		
	headspritestat CURSPRITE STAT_PLAYER
	setvarvar LASTSPRITE CURSPRITE
	whilevarn CURSPRITE -1
	{
		dist STATE_TEMP1 CURSPRITE THISACTOR
		getactor[CURSPRITE].yvel TEMP3
		
		ifvarn STATE_TEMP1 0
		ifvarvarl STATE_TEMP1 STATE_PARAM2
		{
			// FACTOR = DIST * BASE INTENSITY / RADIUS
			setvarvar STATE_TEMP2 STATE_PARAM1
			mulvarvar STATE_TEMP1 STATE_TEMP2
			divvarvar STATE_TEMP1 STATE_PARAM2
			
			// BASE INTENSITY / FACTOR
			subvarvar STATE_TEMP2 STATE_TEMP1
			
			getplayervar[TEMP3].SHAKE_INTENSITY STATE_TEMP1
			addvarvar STATE_TEMP1 STATE_TEMP2
			ifvarg STATE_TEMP1 512 // Cap the shake so we can't rattle the player into oblivion.
				setvar STATE_TEMP1 512
			setplayervar[TEMP3].SHAKE_INTENSITY STATE_TEMP1
			
			setplayervar[TEMP3].SHAKE_TIME 20
		}
		
		nextspritestat CURSPRITE LASTSPRITE
		setvarvar LASTSPRITE CURSPRITE
	}
	
	setvar STATE_PARAM1 0
	setvar STATE_PARAM2 0
ends

defstate handle_shake_display
	ifvarg SHAKE_INTENSITY 0
	ifvarg SHAKE_TIME 0
	{	
	/*
		// SHAKE_INTENSITY/2
		setvarvar CL_TEMP1 SHAKE_INTENSITY
		divvar CL_TEMP1 2
			
		// 0 to SHAKE_INTENSITY
		displayrandvarvar CL_TEMP2 SHAKE_INTENSITY
		subvarvar CL_TEMP2 CL_TEMP1
		addvarvar camerax CL_TEMP2
			
		// 0 to CL_TEMP1 (scaled intensity)
		displayrandvarvar CL_TEMP2 SHAKE_INTENSITY
		subvarvar CL_TEMP2 CL_TEMP1
		addvarvar cameray CL_TEMP2
	*/
		
		setvarvar CL_TEMP1 totalclock
		mulvar CL_TEMP1 150
		
		sin CL_TEMP2 CL_TEMP1
		mulvarvar CL_TEMP2 SHAKE_INTENSITY
		shiftvarr CL_TEMP2 16
		addvarvar camerax CL_TEMP2
		
		cos CL_TEMP2 CL_TEMP1
		mulvarvar CL_TEMP2 SHAKE_INTENSITY
		shiftvarr CL_TEMP2 16
		addvarvar cameray CL_TEMP2
		
		sin CL_TEMP2 CL_TEMP1
		mulvarvar CL_TEMP2 SHAKE_INTENSITY
		shiftvarr CL_TEMP2 12
		addvarvar cameraz CL_TEMP2
	}
ends

defstate handle_shake_timer
	ifvarg SHAKE_INTENSITY 0
	{
		ifvarg SHAKE_TIME 0
		{
			setvarvar TEMP SHAKE_INTENSITY
			divvarvar TEMP SHAKE_TIME
			subvarvar SHAKE_INTENSITY TEMP
			subvar SHAKE_TIME 1
		}
		else
		{
			setvar SHAKE_INTENSITY 0
		}
	}
ends

defstate underwater_blood
	ifinwater
	{
		espawn BLOODINFLUID2
		getactor[THISACTOR].pal TEMP
		setactor[RETURN].pal TEMP
		
		getactor[THISACTOR].picnum TEMP
		gettiledata[TEMP].xsize STATE_TEMP1
		gettiledata[TEMP].ysize STATE_TEMP2
		getactor[THISACTOR].xrepeat STATE_TEMP3
		getactor[THISACTOR].yrepeat STATE_TEMP4
		
		// Get Y size + offset
		gettiledata[TEMP].yoffset TEMP2 // Get Y Offset
		setvarvar TEMP STATE_TEMP2 // Copy Y size
		mulvarvar TEMP STATE_TEMP4
		mulvarvar TEMP2 STATE_TEMP4
		shiftvarl TEMP 1	// Half of sprite size to map units
		shiftvarl TEMP2 2	// Full sprite offset to map units
		addvarvar TEMP TEMP2
		
		getactor[THISACTOR].z TEMP2
		subvarvar TEMP2 TEMP
		setactor[RETURN].z TEMP2
		
		setvarvar TEMP STATE_TEMP1
		mulvarvar TEMP STATE_TEMP3
		setvarvar TEMP2 STATE_TEMP2
		mulvarvar TEMP2 STATE_TEMP4
		addvarvar TEMP TEMP2
		divvar TEMP 2
		shiftvarr TEMP 6
		
		setactor[RETURN].xrepeat TEMP
		setactor[RETURN].yrepeat TEMP
		setvar RETURN 0
	}
ends

defstate set_blimp_drops
	randvar TEMP3 26
	switch TEMP3
		case 0: setvar PICNUM_MEMORY RPGSPRITE break
		case 1: setvar PICNUM_MEMORY CHAINGUNSPRITE break
		case 2: setvar PICNUM_MEMORY DEVISTATORAMMO break
		case 3: setvar PICNUM_MEMORY RPGAMMO break
		case 4: setvar PICNUM_MEMORY RPGAMMO break
		case 5: setvar PICNUM_MEMORY JETPACK break
		case 6: setvar PICNUM_MEMORY SHIELD break
		case 7: setvar PICNUM_MEMORY FIRSTAID break
		case 8: setvar PICNUM_MEMORY STEROIDS break
		case 9: setvar PICNUM_MEMORY RPGAMMO break
		case 10: setvar PICNUM_MEMORY RPGAMMO break
		case 11: setvar PICNUM_MEMORY RPGSPRITE break
		case 12: setvar PICNUM_MEMORY RPGAMMO break
		case 13: setvar PICNUM_MEMORY FREEZESPRITE break
		case 14: setvar PICNUM_MEMORY FREEZEAMMO break
		case 15: setvar PICNUM_MEMORY SSGSPRITE break
		case 16: setvar PICNUM_MEMORY PLASMASPRITE break
		case 17: setvar PICNUM_MEMORY RAILGUNSPRITE break
		case 18: setvar PICNUM_MEMORY FLAMETHROWERSPRITE break
		case 19: setvar PICNUM_MEMORY PLASMAAMMO break
		case 20: setvar PICNUM_MEMORY FLAMETHROWERAMMO break
		case 21: setvar PICNUM_MEMORY GROWSPRITEICON break
		case 22: setvar PICNUM_MEMORY GROWAMMO break
		case 23: setvar PICNUM_MEMORY CRYSTALAMMO break
		case 24:
			setvar PICNUM_MEMORY RAILGUNAMMO
			sizeat 16 16
			break
		case 25:
			setvar PICNUM_MEMORY DFGAMMO
			sizeat 28 28
			break
		case 26:
			setvar PICNUM_MEMORY DFGSPRITE
			sizeat 28 28
			break
	endswitch
ends

defstate blimp_hack
	ifvarg PICNUM_MEMORY -1
	{
		setactor[THISACTOR].yvel PICNUM_MEMORY
		setvar PICNUM_MEMORY -1
	}
ends


// STATE_PARAM1 = Target Sprite
// STATE_PARAM2 = Z movement only distance (0 = None)
// STATE_PARAM3 = Maximum angle change per tic (0 = No Limit)
state home_on_target
	getactor[THISACTOR].xvel STATE_TEMP3 // Get our velocity, don't overwrite this until the end.
	ifvarl STATE_TEMP3 1 // No velocity, can't do shit jack, bail.
		break
		
	ldist STATE_TEMP1 THISACTOR STATE_PARAM1
	ifvarvarg STATE_TEMP1 STATE_PARAM2 // We're not in the Z movement only distance, so let's move horizontally too.
	{
		// Get X/Y positions for angle
		getactor[STATE_PARAM1].x STATE_TEMP1
		getactor[THISACTOR].x STATE_TEMP3
		subvarvar STATE_TEMP1 STATE_TEMP3
		
		getactor[STATE_PARAM1].y STATE_TEMP2
		getactor[THISACTOR].y STATE_TEMP3
		subvarvar STATE_TEMP2 STATE_TEMP3
		
		getangle STATE_TEMP3 STATE_TEMP1 STATE_TEMP2
		ifvare STATE_PARAM3 0
		{
			setactor[THISACTOR].ang STATE_TEMP3
		}
		else
		{
			getactor[THISACTOR].ang STATE_TEMP1
			
			getincangle STATE_TEMP3 STATE_TEMP1 STATE_TEMP3
			
			ifvarvarg STATE_TEMP3 STATE_PARAM3
				setvarvar STATE_TEMP3 STATE_PARAM3
			
			ifvarvarl STATE_TEMP3 -STATE_PARAM3
				setvarvar STATE_TEMP3 -STATE_PARAM3
			
			addvarvar STATE_TEMP3 STATE_TEMP1
			setactor[THISACTOR].ang STATE_TEMP3
		}
		
		cos DEST_X STATE_TEMP3
		sin DEST_Y STATE_TEMP3

		getactor[THISACTOR].xvel STATE_TEMP3 // Get our velocity, don't overwrite this until the end.
		mulvarvar DEST_X STATE_TEMP3 // Scale X/Y destination
		mulvarvar DEST_Y STATE_TEMP3
		shiftvarr DEST_X 14
		shiftvarr DEST_Y 14
	}
	else
	{
		setvar DEST_X 0
		setvar DEST_Y 0
	}
	
	getactor[STATE_PARAM1].z DEST_Z
	ifactor APPARITION { }
	else
	{
		getactor[STATE_PARAM1].picnum STATE_TEMP1
		ifvare STATE_TEMP1 APLAYER
		{
			getactor[STATE_PARAM1].yvel STATE_TEMP1
			getplayer[STATE_TEMP1].posz DEST_Z
		}
	}
	getactor[THISACTOR].z STATE_TEMP1
	subvarvar DEST_Z STATE_TEMP1
	shiftvarl DEST_Z 6
	
	ldist STATE_TEMP1 THISACTOR STATE_PARAM1
		
	ifvarl STATE_TEMP1 1 // Clamp so we don't div by zero.
		setvar STATE_TEMP1 1
		
	divvarvar DEST_Z STATE_TEMP1
	
	shiftvarl STATE_TEMP3 4 // Scale xvel to build z units to calculate speed limit
	
	ifvarvarg DEST_Z STATE_TEMP3
		setvarvar DEST_Z STATE_TEMP3
	
	ifvarvarl DEST_Z -STATE_TEMP3
		setvarvar DEST_Z -STATE_TEMP3
		
	// Finally done with the STATE_TEMP vars, can use them for whatever from here on.
			
	getactor[THISACTOR].x STATE_TEMP1
	getactor[THISACTOR].y STATE_TEMP2
	getactor[THISACTOR].z STATE_TEMP3
	addvarvar STATE_TEMP1 DEST_X
	addvarvar STATE_TEMP2 DEST_Y
	addvarvar STATE_TEMP3 DEST_Z
	setsprite THISACTOR STATE_TEMP1 STATE_TEMP2 STATE_TEMP3
ends

// Shield Types:
	// Fire: Weak to Ice, Immune to Fire, Touch sets enemies on fire, goes out in water.
	// Water: Immune to Ice, Weak to Electric (excess damage bleeds through), stops being set on fire but isn't immune to the damage, infinte oxygen.
	// Wood: Immune to Microwave, weak to fire, resistant to dark matter (DFG). Pulls in life petals, and doubles their capacity.
	// Earth: Immune to radius damage, resistant to rails, mildly weak to other damage. Pulls in crystal shards.
	// Metal: Immune to Electric, Immune to Spikes/Gradual floor damage. Weak to Microwave.
	
// STATE_PARAM1 = Player
// STATE_PARAM2 = Type
// STATE_PARAM3 = Intensity
defstate do_shield_flash
	ifvarg STATE_PARAM1 -1
	ifvarvarl STATE_PARAM1 MULTIMODE
	{
		ifvare STATE_PARAM2 SHIELDTYPE_FIRE
		{
			setplayer[STATE_PARAM1].pals 0 63 // r
			setplayer[STATE_PARAM1].pals 1 31 // g
			setplayer[STATE_PARAM1].pals 2 0 // b
		}
		else ifvare STATE_PARAM2 SHIELDTYPE_WATER
		{
			setplayer[STATE_PARAM1].pals 0 8 // r
			setplayer[STATE_PARAM1].pals 1 32 // g
			setplayer[STATE_PARAM1].pals 2 63 // b
		}
		else ifvare STATE_PARAM2 SHIELDTYPE_EARTH
		{
			setplayer[STATE_PARAM1].pals 0 64 // r
			setplayer[STATE_PARAM1].pals 1 56 // g
			setplayer[STATE_PARAM1].pals 2 0 // b
		}
		else ifvare STATE_PARAM2 SHIELDTYPE_WOOD
		{
			setplayer[STATE_PARAM1].pals 0 36 // r
			setplayer[STATE_PARAM1].pals 1 22 // g
			setplayer[STATE_PARAM1].pals 2 28 // b
		}
		else ifvare STATE_PARAM2 SHIELDTYPE_METAL
		{
			setplayer[STATE_PARAM1].pals 0 63 // r
			setplayer[STATE_PARAM1].pals 1 63 // g
			setplayer[STATE_PARAM1].pals 2 63 // b
		}
		
		
		setplayer[STATE_PARAM1].pals_time STATE_PARAM3
	}
ends

// STATE_PARAM1 = amount
// STATE_PARAM2 = victim
// STATE_PARAM3 = htpicnum
// STATE_PARAM4 = radius damage (greater than 0 = yes)
// STATE_RETURN = Amount of damage that bled through.
defstate process_shield_damage
	setvarvar STATE_RETURN STATE_PARAM1 // Store un-multiplied damage
	
	getactor[STATE_PARAM2].picnum STATE_TEMP1
	ifvare STATE_TEMP1 APLAYER
	{
		getactor[STATE_PARAM2].yvel STATE_TEMP1
		getplayervar[STATE_TEMP1].SHIELD_HEALTH STATE_TEMP2
		getplayervar[STATE_TEMP1].SHIELD_TYPE STATE_TEMP3
		
		ifvarg STATE_TEMP2 0
		{
			subvarvar STATE_RETURN STATE_TEMP2 // Take remaining shield health off bled-through damage.
			actorsound STATE_PARAM2 FP_SHIELDHIT
			
			ifvare STATE_TEMP3 SHIELDTYPE_FIRE
			{
				ifvare STATE_PARAM3 FREEZEBLAST
					mulvar STATE_PARAM1 4
				else ifvare STATE_PARAM3 FIREBALL
					setvar STATE_PARAM1 0
				else ifvare STATE_PARAM3 MAGMASPEW
					setvar STATE_PARAM1 10
				
				setvar STATE_RETURN -1 // No Bleedthrough
			}
			else ifvare STATE_TEMP3 SHIELDTYPE_WATER
			{
				switch STATE_PARAM3
					case PLASMABALL:
					case PLASMABALL2:
					case PLASMABALL3:
						shiftvarl STATE_PARAM1 2
						break
					case FREEZEBLAST:
						setvar STATE_PARAM1 0
						setvar STATE_RETURN -1
						break
					default:
						setvar STATE_RETURN -1
						break
				endswitch
			}
			else ifvare STATE_TEMP3 SHIELDTYPE_EARTH
			{
				ifvare STATE_PARAM3 RAILGUNSHOT
					shiftvarr STATE_PARAM1 2 // Quarter damage from rails
				else
					addvar STATE_PARAM1 2 // Worn out slightly quicker by other damage types.
				
				ifvarg STATE_PARAM4 0 // Radius Damage is nullified
					setvar STATE_PARAM1 0
				
				setvar STATE_RETURN -1
			}
			else ifvare STATE_TEMP3 SHIELDTYPE_WOOD
			{
				switch STATE_PARAM3
					case FIREBALL:
						shiftvarl STATE_PARAM1 2
						break
					case GROWSPARK:
						setvar STATE_PARAM1 0
						break
					case DFGTRACER:
						shiftvarr STATE_PARAM1 2
						break
					case DFGBALL:
						shiftvarr STATE_PARAM1 4
						break
				endswitch
				
				setvar STATE_RETURN -1
			}
			else ifvare STATE_TEMP3 SHIELDTYPE_METAL
			{
				switch STATE_PARAM3
					case PLASMABALL:
					case PLASMABALL2:
					case PLASMABALL3:
					case SPIKE:
						setvar STATE_PARAM1 0
						break
					case GROWSPARK:
						shiftvarl STATE_PARAM1 1
						break
				endswitch
				
				setvar STATE_RETURN -1
			}
			
			ifvarg STATE_PARAM1 0 // If any damage left, process.
			{
				subvarvar STATE_TEMP2 STATE_PARAM1
				setplayervar[STATE_TEMP1].SHIELD_HEALTH STATE_TEMP2
				
				setvarvar STATE_PARAM1 STATE_TEMP1 // Player ID
				setvarvar STATE_PARAM2 STATE_TEMP3 // Shield Type
				setvarvar STATE_PARAM3 8 // Intensity
				state do_shield_flash
			}
			else
			{
				setvar STATE_RETURN -1 // If we're doing no damage, don't let any pass either.
			}
		}
	}
ends

// Handles shield behavior on the player. (Not damage, but underlying behaviors)
defstate handle_player_shield
	ifvarg SHIELD_HEALTH 0
	{
		ifvare SHIELD_TYPE SHIELDTYPE_FIRE
		{
			ifinwater
			{
				setvar SHIELD_HEALTH 0
				setvar SHIELD_TYPE 0
			}
		}
		else ifvare SHIELD_TYPE SHIELDTYPE_WATER
		{
			ifinwater
			{
				setplayer[THISACTOR].airleft 390
			}
		}
	}
ends

// STATE_PARAM1 = Shield Type
defstate get_shield_particle_pal
	ifvare STATE_PARAM1 SHIELDTYPE_FIRE
	{
		setvar STATE_RETURN 2
		break
	}
	
	ifvare STATE_PARAM1 SHIELDTYPE_WATER
	{
		setvar STATE_RETURN 1
		break
	}
	
	ifvare STATE_PARAM1 SHIELDTYPE_EARTH
	{
		setvar STATE_RETURN 7
		break
	}
	
	ifvare STATE_PARAM1 SHIELDTYPE_WOOD
	{
		setvar STATE_RETURN 0
		break
	}
	
	ifvare STATE_PARAM1 SHIELDTYPE_METAL
	{
		setvar STATE_RETURN 27
		break
	}
ends

// STATE_PARAM1 = amount
// STATE_PARAM2 = victim
// STATE_PARAM3 = htpicnum
// STATE_PARAM4 = radius damage (passes through this state to process_shield_damage)
defstate apply_damage
	state process_shield_damage // Do shield damage first.
	ifvarg STATE_RETURN -1
	{
		getactor[STATE_PARAM2].htextra STATE_TEMP1
		addvarvar STATE_TEMP1 STATE_RETURN
		setactor[STATE_PARAM2].htextra STATE_TEMP1
		
		getactor[THISACTOR].owner STATE_TEMP1
		setactor[STATE_PARAM2].htowner STATE_TEMP1
		setactor[STATE_PARAM2].htpicnum STATE_PARAM3
		
		getactor[THISACTOR].ang STATE_TEMP1
		setactor[STATE_PARAM2].htang STATE_TEMP1
	}
ends

defstate check_object_touch
	getactor[STATE_PARAM1].picnum STATE_TEMP1
	ifvare STATE_TEMP1 BOMBFLOWER
	{
		getactorvar[STATE_PARAM1].LOTAG_MEMORY STATE_TEMP1
		getactorvar[STATE_PARAM1].EXTRA_MEMORY STATE_TEMP2
		ifvare STATE_TEMP1 0 // We're not counting down.
		ifvare STATE_TEMP2 0 // EXTRA_MEMORY should be 0.
		{
			setactorvar[STATE_PARAM1].EXTRA_MEMORY 6969
			setactorvar[STATE_PARAM1].OWNER THISACTOR
			setactor[STATE_PARAM1].owner THISACTOR
		}
	}
	else ifvare STATE_TEMP1 MAGMASPEWCAP
	{
		setvar STATE_PARAM1 999
		setvarvar STATE_PARAM2 THISACTOR
		setvar STATE_PARAM3 MAGMASPEW
		setvar STATE_PARAM4 0
		state apply_damage
	}
ends

// STATE_PARAM1 = Actor ID
defstate random_stinger
	randvar TEMP 6
	switch TEMP
		case 0: actorsound STATE_PARAM1 CREEPYAMB_02 break
		case 1: actorsound STATE_PARAM1 CREEPYAMB_03 break
		case 2: actorsound STATE_PARAM1 CREEPYAMB_09 break
		case 3: actorsound STATE_PARAM1 CREEPYAMB_10 break
		case 4: actorsound STATE_PARAM1 CREEPYAMB_11 break
		case 5: actorsound STATE_PARAM1 CREEPYAMB_17 break
		case 6: actorsound STATE_PARAM1 CREEPYAMB_18 break
	endswitch
ends

defstate zap_a_cunt
	// Can't hurt yourself unless you're too close to impact.
	ifvarvare CURSPRITE THISACTOR
	{
		ifvarg SPECIAL_ATTACK_SPR -1
		{
			dist TEMP CURSPRITE SPECIAL_ATTACK_SPR
			setvar SPECIAL_ATTACK_SPR -1
			ifvarg TEMP 2048
				break
		}
		else break
	}
	
	// Friendly fire check
	ifvarvarn CURSPRITE THISACTOR
	{
		getactor[CURSPRITE].picnum TEMP
		ifvare TEMP APLAYER
		{
			ifvarand gametype_flags 4096 // All players friendly
				break
			
			ifvarand gametype_flags 65536 // Team DM
			{
				getactor[CURSPRITE].yvel TEMP
				getplayer[TEMP].team TEMP	
				getplayer[THISACTOR].team TEMP2
						
				ifvarvare TEMP TEMP2 // Team matches?
				{
					break // Bail.
				}
			}
		}
	}
	
	// Found 40 targets? Time to bail.
	ifvare HITAG_MEMORY 40
		break
	
	getactor[CURSPRITE].cstat TEMP
	ifvarand TEMP 256
	{
		getactor[CURSPRITE].extra TEMP
		ifvarl TEMP 1 // Already dead?
			break
			
		dist TEMP CURSPRITE THISACTOR
		ifvarg TEMP 12288 // Too Far?
			break
			
		getactor[CURSPRITE].x TEMP
		getactor[CURSPRITE].y TEMP2
		getplayer[THISACTOR].posx SPAWN_ORIGX
		getplayer[THISACTOR].posy SPAWN_ORIGY
		subvarvar TEMP SPAWN_ORIGX
		subvarvar TEMP2 SPAWN_ORIGY
		getangle SPAWN_ORIGANG TEMP TEMP2
		getincangle TEMP2 SPECIAL_ATTACK_ANG SPAWN_ORIGANG
		shiftvarr TEMP2 1
		andvar TEMP2 2047
		
		ifvarg TEMP2 1023
			subvar TEMP2 2047
		ifvarl TEMP2 -1023
			addvar TEMP2 2047
		
		abs TEMP2
		
		ifvarvare CURSPRITE THISACTOR // You can damage yourself
			setvar TEMP2 0

		ifvarl TEMP2 128 // Is this asshole in our view cone?
		{
			getactor[CURSPRITE].x SPAWN_ORIGX
			getactor[CURSPRITE].y SPAWN_ORIGY
			getactor[CURSPRITE].z SPAWN_ORIGZ
			getactor[CURSPRITE].sectnum SECTNUM_MEMORY
			
			// Get picnum and dimensions
			getactor[CURSPRITE].picnum TEMP
			gettiledata[TEMP].xsize STATE_TEMP1
			gettiledata[TEMP].ysize STATE_TEMP2
			getactor[CURSPRITE].yrepeat STATE_TEMP3
			
			// Get Y size + offset
			gettiledata[TEMP].yoffset TEMP2 // Get Y Offset
			setvarvar TEMP STATE_TEMP2 // Copy Y size
			mulvarvar TEMP STATE_TEMP3 // Multiply by YREPEAT
			mulvarvar TEMP2 STATE_TEMP3 // Multiply by YREPEAT
			shiftvarl TEMP 1	// Half of sprite size to map units
			shiftvarl TEMP2 2	// Full sprite offset to map units
			addvarvar TEMP TEMP2
			
			// Sub yzize/offset from z coord
			subvarvar SPAWN_ORIGZ TEMP
			
			getplayer[THISACTOR].posx TEMP
			getplayer[THISACTOR].posy TEMP2
			getplayer[THISACTOR].posz TEMP3
			getplayer[THISACTOR].cursectnum SPAWN_ORIGANG
			cansee SPAWN_ORIGX SPAWN_ORIGY SPAWN_ORIGZ SECTNUM_MEMORY TEMP TEMP2 TEMP3 SPAWN_ORIGANG EXTRA_MEMORY
			ifvare EXTRA_MEMORY 1
			{
				// Zap the cunt
				//setactor[CURSPRITE].htowner THISACTOR
				getactor[CURSPRITE].picnum TEMP
				
				setvar STATE_PARAM1 DFG_TRACER_STRENGTH
				setvarvar STATE_PARAM2 CURSPRITE
				
				ifvare TEMP APLAYER
				{
					setvar STATE_PARAM3 DFGTRACER
				}
				else
				{
					setvar STATE_PARAM3 RADIUSEXPLOSION
					mulvar STATE_PARAM1 3 // Triple damage to monsters
				}

				setvarvar STATE_PARAM4 0
				state apply_damage
				
				espawn DFGTRACER
				setactor[RETURN].x SPAWN_ORIGX
				setactor[RETURN].y SPAWN_ORIGY
				setactor[RETURN].z SPAWN_ORIGZ
				setactor[RETURN].cstat 128
				setactor[RETURN].xrepeat 56
				setactor[RETURN].yrepeat 56
				setvar RETURN 0
				
				addvar HITAG_MEMORY 1
			}
		}
	}
ends

defstate apparition_screenfx
	ifvarg APPARITION_SPRITEID -1
	{
		getactor[APPARITION_SPRITEID].x CL_TEMP1
		getactor[APPARITION_SPRITEID].y CL_TEMP2
		getactor[APPARITION_SPRITEID].z CL_TEMP3
		
		distvar camerax cameray cameraz CL_TEMP1 CL_TEMP2 CL_TEMP3 CL_TEMP1
		getactor[APPARITION_SPRITEID].cstat CL_TEMP2
			
		ifvarand CL_TEMP2 32768
			setvar CL_TEMP1 9999999
				
		ifvarl CL_TEMP1 4097
		{
			// Linear range conversion from 0-4096 to 0-255
			setvarvar CL_TEMP9 CL_TEMP1
			mulvar CL_TEMP9 255
			divvar CL_TEMP9 4096
			rotatespritea 0 0 65536 0 6764 0 0 1042 CL_TEMP9 0 0 xdim ydim
			
			setvar CL_TEMP9 4096
			subvarvar CL_TEMP9 CL_TEMP1
			ifvarg CL_TEMP9 0
			{
				setvarvar CL_TEMP8 totalclock
				shiftvarl CL_TEMP8 3
				sin CL_TEMP8 CL_TEMP8
				mulvarvar CL_TEMP8 CL_TEMP9
				shiftvarr CL_TEMP8 18
				setplayer[THISACTOR].rotscrnang CL_TEMP8
				setplayer[THISACTOR].orotscrnang CL_TEMP8
			}
		}
	}
ends

defstate handle_special_attacks
	ifvarg predicting 0  // Safeguard
		break
	
	ifvare SPECIAL_ATTACK SPEC_ATTACK_DFG
	{
		setvar SPECIAL_ATTACK 0
		setvar HITAG_MEMORY 0
		
		headspritestat CURSPRITE STAT_PLAYER
		whilevarn CURSPRITE -1
		{
			state zap_a_cunt
			
			nextspritestat CURSPRITE CURSPRITE
		}
		
		headspritestat CURSPRITE STAT_ACTOR
		whilevarn CURSPRITE -1
		{
			state zap_a_cunt
			
			nextspritestat CURSPRITE CURSPRITE
		}
		
		headspritestat CURSPRITE STAT_ZOMBIEACTOR
		whilevarn CURSPRITE -1
		{
			state zap_a_cunt
			
			nextspritestat CURSPRITE CURSPRITE
		}

		headspritestat CURSPRITE STAT_STANDABLE
		whilevarn CURSPRITE -1
		{
			state zap_a_cunt
			
			nextspritestat CURSPRITE CURSPRITE
		}
	}
ends
